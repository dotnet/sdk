.\" Automatically generated by Pandoc 2.18
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "dotnet-environment-variables" "7" "2024-10-02" "" ".NET Documentation"
.hy
.SH NAME
.PP
dotnet-environment-variables - .NET environment variables
.SH DESCRIPTION
.PP
\f[B]This article applies to:\f[R] \[u2714]\[uFE0F] .NET Core 3.1 SDK and later versions
.PP
In this article, you\[cq]ll learn about the environment variables used by .NET.
Some environment variables are used by the .NET runtime, while others are only used by the .NET SDK and .NET CLI.
Some environment variables are used by all three components.
.SS .NET runtime environment variables
.SS \f[V]DOTNET_SYSTEM_NET_HTTP_*\f[R]
.PP
There are several global HTTP environment variable settings:
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_NET_HTTP_ENABLEACTIVITYPROPAGATION\f[R]
.RS 2
.IP \[bu] 2
Indicates whether or not to enable activity propagation of the diagnostic handler for global HTTP settings.
.RE
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2SUPPORT\f[R]
.RS 2
.IP \[bu] 2
When set to \f[V]false\f[R] or \f[V]0\f[R], disables HTTP/2 support, which is enabled by default.
.RE
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP3SUPPORT\f[R]
.RS 2
.IP \[bu] 2
When set to \f[V]true\f[R] or \f[V]1\f[R], enables HTTP/3 support, which is disabled by default.
.RE
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2FLOWCONTROL_DISABLEDYNAMICWINDOWSIZING\f[R]
.RS 2
.IP \[bu] 2
When set to \f[V]false\f[R] or \f[V]0\f[R], overrides the default and disables the HTTP/2 dynamic window scaling algorithm.
.RE
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_FLOWCONTROL_MAXSTREAMWINDOWSIZE\f[R]
.RS 2
.IP \[bu] 2
Defaults to 16 MB.
When overridden, the maximum size of the HTTP/2 stream receive window cannot be less than 65,535.
.RE
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_FLOWCONTROL_STREAMWINDOWSCALETHRESHOLDMULTIPLIER\f[R]
.RS 2
.IP \[bu] 2
Defaults to 1.0.
When overridden, higher values result in a shorter window but slower downloads.
Can\[cq]t be less than 0.
.RE
.SS \f[V]DOTNET_SYSTEM_GLOBALIZATION_*\f[R]
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_GLOBALIZATION_INVARIANT\f[R]: See set invariant mode.
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_GLOBALIZATION_PREDEFINED_CULTURES_ONLY\f[R]: Specifies whether to load only predefined cultures.
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_GLOBALIZATION_APPLOCALICU\f[R]: Indicates whether to use the app-local International Components of Unicode (ICU).
For more information, see App-local ICU.
.SS Set invariant mode
.PP
Applications can enable the invariant mode in any of the following ways:
.IP "1." 3
In the project file:
.RS 4
.IP
.nf
\f[C]
<PropertyGroup>
    <InvariantGlobalization>true</InvariantGlobalization>
</PropertyGroup>
\f[R]
.fi
.RE
.IP "2." 3
In the \f[I]runtimeconfig.json\f[R] file:
.RS 4
.IP
.nf
\f[C]
{
    \[dq]runtimeOptions\[dq]: {
        \[dq]configProperties\[dq]: {
            \[dq]System.Globalization.Invariant\[dq]: true
        }
    }
}
\f[R]
.fi
.RE
.IP "3." 3
By setting environment variable value \f[V]DOTNET_SYSTEM_GLOBALIZATION_INVARIANT\f[R] to \f[V]true\f[R] or \f[V]1\f[R].
.RS
.PP
A value set in the project file or \f[I]runtimeconfig.json\f[R] has a higher priority than the environment variable.
.RE
.PP
For more information, see .NET Globalization Invariant Mode (https://github.com/dotnet/runtime/blob/main/docs/design/features/globalization-invariant-mode.md).
.SS \f[V]DOTNET_SYSTEM_GLOBALIZATION_USENLS\f[R]
.PP
This applies to Windows only.
For globalization to use National Language Support (NLS), set \f[V]DOTNET_SYSTEM_GLOBALIZATION_USENLS\f[R] to either \f[V]true\f[R] or \f[V]1\f[R].
To not use it, set \f[V]DOTNET_SYSTEM_GLOBALIZATION_USENLS\f[R] to either \f[V]false\f[R] or \f[V]0\f[R].
.SS \f[V]DOTNET_SYSTEM_NET_SOCKETS_*\f[R]
.PP
This section focuses on two \f[V]System.Net.Sockets\f[R] environment variables:
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS\f[R]
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_NET_SOCKETS_THREAD_COUNT\f[R]
.PP
Socket continuations are dispatched to the <xref:System.Threading.ThreadPool?displayProperty=fullName> from the event thread.
This avoids continuations blocking the event handling.
To allow continuations to run directly on the event thread, set \f[V]DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS\f[R] to \f[V]1\f[R].
It\[cq]s disabled by default.
.RS
.PP
This setting can make performance worse if there is expensive work that will end up holding onto the IO thread for longer than needed.
Test to make sure this setting helps performance.
.RE
.PP
Using TechEmpower benchmarks that generate a lot of small socket reads and writes under a very high load, a single socket engine is capable of keeping busy up to thirty x64 and eight Arm64 CPU cores.
The vast majority of real-life scenarios will never generate such a huge load (hundreds of thousands of requests per second), and having a single producer is almost always enough.
However, to be sure that extreme loads can be handled, you can use \f[V]DOTNET_SYSTEM_NET_SOCKETS_THREAD_COUNT\f[R] to override the calculated value.
When not overridden, the following value is used:
.IP \[bu] 2
When \f[V]DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS\f[R] is \f[V]1\f[R], the <xref:System.Environment.ProcessorCount?displayProperty=nameWithType> value is used.
.IP \[bu] 2
When \f[V]DOTNET_SYSTEM_NET_SOCKETS_INLINE_COMPLETIONS\f[R] is not \f[V]1\f[R], <xref:System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture?displayProperty=nameWithType> is evaluated:
.RS 2
.IP \[bu] 2
When Arm or Arm64 the cores per engine value is set to \f[V]8\f[R], otherwise \f[V]30\f[R].
.RE
.IP \[bu] 2
Using the determined cores per engine, the maximum value of either \f[V]1\f[R] or <xref:System.Environment.ProcessorCount?displayProperty=nameWithType> over the cores per engine.
.SS \f[V]DOTNET_SYSTEM_NET_DISABLEIPV6\f[R]
.PP
Helps determine whether or not Internet Protocol version 6 (IPv6) is disabled.
When set to either \f[V]true\f[R] or \f[V]1\f[R], IPv6 is disabled unless otherwise specified in the <xref:System.AppContext?displayProperty=nameWithType>.
.SS \f[V]DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER\f[R]
.PP
You can use one of the following mechanisms to configure a process to use the older \f[V]HttpClientHandler\f[R]:
.PP
From code, use the \f[V]AppContext\f[R] class:
.IP
.nf
\f[C]
AppContext.SetSwitch(\[dq]System.Net.Http.UseSocketsHttpHandler\[dq], false);
\f[R]
.fi
.PP
The \f[V]AppContext\f[R] switch can also be set by a config file.
For more information configuring switches, see AppContext for library consumers.
.PP
The same can be achieved via the environment variable \f[V]DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER\f[R].
To opt-out, set the value to either \f[V]false\f[R] or \f[V]0\f[R].
.RS
.PP
Starting in .NET 5, this setting to use <xref:System.Net.Http.HttpClientHandler> is no longer available.
.RE
.SS \f[V]DOTNET_Jit*\f[R] and \f[V]DOTNET_GC*\f[R]
.PP
There are two stressing-related features for the JIT and JIT-generated GC information: JIT Stress and GC Hole Stress.
These features provide a way during development to discover edge cases and more \[lq]real world\[rq] scenarios without having to develop complex applications.
The following environment variables are available:
.IP \[bu] 2
\f[V]DOTNET_JitStress\f[R]
.IP \[bu] 2
\f[V]DOTNET_JitStressModeNamesOnly\f[R]
.IP \[bu] 2
\f[V]DOTNET_GCStress\f[R]
.SS JIT stress
.PP
Enabling JIT Stress can be done in several ways.
Set \f[V]DOTNET_JitStress\f[R] to a non-zero integer value to generate varying levels of JIT optimizations based on a hash of the method\[cq]s name.
To apply all optimizations set \f[V]DOTNET_JitStress=2\f[R], for example.
Another way to enable JIT Stress is by setting \f[V]DOTNET_JitStressModeNamesOnly=1\f[R] and then requesting the stress modes, space-delimited, in the \f[V]DOTNET_JitStressModeNames\f[R] variable.
.PP
As an example, consider:
.IP
.nf
\f[C]
DOTNET_JitStressModeNames=STRESS_USE_CMOV STRESS_64RSLT_MUL STRESS_LCL_FLDS
\f[R]
.fi
.SS GC Hole stress
.PP
Enabling GC Hole Stress causes GCs to always occur in specific locations and that helps to track down GC holes.
GC Hole Stress can be enabled using the \f[V]DOTNET_GCStress\f[R] environment variable.
.PP
For more information, see Investigating JIT and GC Hole stress (https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/jit/investigate-stress.md).
.SS JIT memory barriers
.PP
The code generator for Arm64 allows all \f[V]MemoryBarriers\f[R] instructions to be removed by setting \f[V]DOTNET_JitNoMemoryBarriers\f[R] to \f[V]1\f[R].
.SS \f[V]DOTNET_RUNNING_IN_CONTAINER\f[R] and \f[V]DOTNET_RUNNING_IN_CONTAINERS\f[R]
.PP
The official .NET images (Windows and Linux) set the well-known environment variables:
.IP \[bu] 2
\f[V]DOTNET_RUNNING_IN_CONTAINER\f[R]
.IP \[bu] 2
\f[V]DOTNET_RUNNING_IN_CONTAINERS\f[R]
.PP
These values are used to determine when your ASP.NET Core workloads are running in the context of a container.
.SS \f[V]DOTNET_SYSTEM_CONSOLE_ALLOW_ANSI_COLOR_REDIRECTION\f[R]
.PP
When <xref:System.Console.IsOutputRedirected?displayProperty=nameWithType> is \f[V]true\f[R], you can emit ANSI color code by setting \f[V]DOTNET_SYSTEM_CONSOLE_ALLOW_ANSI_COLOR_REDIRECTION\f[R] to either \f[V]1\f[R] or \f[V]true\f[R].
.SS \f[V]DOTNET_SYSTEM_DIAGNOSTICS\f[R] and related variables
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_DIAGNOSTICS_DEFAULTACTIVITYIDFORMATISHIERARCHIAL\f[R]: When \f[V]1\f[R] or \f[V]true\f[R], the default \f[I]Activity Id\f[R] format is hierarchical.
.IP \[bu] 2
\f[V]DOTNET_SYSTEM_RUNTIME_CACHING_TRACING\f[R]: When running as Debug, tracing can be enabled when this is \f[V]true\f[R].
.SS \f[V]DOTNET_DiagnosticPorts\f[R]
.PP
Configures alternate endpoints where diagnostic tools can communicate with the .NET runtime.
See the Diagnostic Port documentation for more information.
.SS \f[V]DOTNET_DefaultDiagnosticPortSuspend\f[R]
.PP
Configures the runtime to pause during startup and wait for the \f[I]Diagnostics IPC ResumeStartup\f[R] command from the specified diagnostic port when set to 1.
Defaults to 0.
See the Diagnostic Port documentation for more information.
.SS \f[V]DOTNET_EnableDiagnostics\f[R]
.PP
When set to \f[V]0\f[R], disables debugging, profiling, and other diagnostics via the Diagnostic Port and can\[cq]t be overridden by other diagnostics settings.
Defaults to \f[V]1\f[R].
.SS \f[V]DOTNET_EnableDiagnostics_IPC\f[R]
.PP
Starting with .NET 8, when set to \f[V]0\f[R], disables the Diagnostic Port and can\[cq]t be overridden by other diagnostics settings.
Defaults to \f[V]1\f[R].
.SS \f[V]DOTNET_EnableDiagnostics_Debugger\f[R]
.PP
Starting with .NET 8, when set to \f[V]0\f[R], disables debugging and can\[cq]t be overridden by other diagnostics settings.
Defaults to \f[V]1\f[R].
.SS \f[V]DOTNET_EnableDiagnostics_Profiler\f[R]
.PP
Starting with .NET 8, when set to \f[V]0\f[R], disables profiling and can\[cq]t be overridden by other diagnostics settings.
Defaults to \f[V]1\f[R].
.SS EventPipe variables
.PP
See EventPipe environment variables for more information.
.IP \[bu] 2
\f[V]DOTNET_EnableEventPipe\f[R]: When set to \f[V]1\f[R], enables tracing via EventPipe.
.IP \[bu] 2
\f[V]DOTNET_EventPipeOutputPath\f[R]: The output path where the trace will be written.
.IP \[bu] 2
\f[V]DOTNET_EventPipeOutputStreaming\f[R]: When set to \f[V]1\f[R], enables streaming to the output file while the app is running.
By default trace information is accumulated in a circular buffer and the contents are written at app shutdown.
.SS .NET SDK and CLI environment variables
.SS \f[V]DOTNET_ROOT\f[R], \f[V]DOTNET_ROOT(x86)\f[R], \f[V]DOTNET_ROOT_X86\f[R], \f[V]DOTNET_ROOT_X64\f[R]
.PP
Specifies the location of the .NET runtimes, if they are not installed in the default location.
The default location on Windows is \f[V]C:\[rs]Program Files\[rs]dotnet\f[R].
The default location on macOS is \f[V]/usr/local/share/dotnet\f[R].
The default location for the x64 runtimes on an arm64 OS is under an x64 subfolder (so \f[V]C:\[rs]Program Files\[rs]dotnet\[rs]x64\f[R] on windows and \f[V]/usr/local/share/dotnet/x64\f[R] on macOS.
The default location on Linux varies depending on distro and installment method.
The default location on Ubuntu 22.04 is \f[V]/usr/share/dotnet\f[R] (when installed from \f[V]packages.microsoft.com\f[R]) or \f[V]/usr/lib/dotnet\f[R] (when installed from Jammy feed).
For more information, see the following resources:
.IP \[bu] 2
Troubleshoot app launch failures
.IP \[bu] 2
GitHub issue dotnet/core#7699 (https://github.com/dotnet/core/issues/7699)
.IP \[bu] 2
GitHub issue dotnet/runtime#79237 (https://github.com/dotnet/runtime/issues/79237)
.PP
This environment variable is used only when running apps via generated executables (apphosts).
\f[V]DOTNET_ROOT(x86)\f[R] is used instead when running a 32-bit executable on a 64-bit OS.
\f[V]DOTNET_ROOT_X64\f[R] is used instead when running a 64-bit executable on an ARM64 OS.
.SS \f[V]DOTNET_HOST_PATH\f[R]
.PP
Specifies the absolute path to a \f[V]dotnet\f[R] host (\f[V]dotnet.exe\f[R] on Windows, \f[V]dotnet\f[R] on Linux and macOS) that was used to launch the currently-running \f[V]dotnet\f[R] process.
This is used by the .NET SDK to help tools that run during .NET SDK commands ensure they use the same \f[V]dotnet\f[R] runtime for any child \f[V]dotnet\f[R] processes they create for the duration of the command.
Tools and MSBuild Tasks within the SDK that invoke binaries via the \f[V]dotnet\f[R] host are expected to honor this environment variable to ensure a consistent experience.
.PP
Tools that invoke \f[V]dotnet\f[R] during an SDK command should use the following algorithm to locate it:
.IP \[bu] 2
if \f[V]DOTNET_HOST_PATH\f[R] is set, use that value directly
.IP \[bu] 2
otherwise, rely on \f[V]dotnet\f[R] via the system\[cq]s \f[V]PATH\f[R]
.RS
.PP
\f[V]DOTNET_HOST_PATH\f[R] is not a general solution for locating the \f[V]dotnet\f[R] host.
It is only intended to be used by tools that are invoked by the .NET SDK.
.RE
.SS \f[V]DOTNET_LAUNCH_PROFILE\f[R]
.PP
The dotnet run command sets this variable to the selected launch profile.
.PP
Given the following \f[I]launchSettings.json\f[R] file:
.IP
.nf
\f[C]
{
  \[dq]profiles\[dq]: {
    \[dq]First\[dq]: {
      \[dq]commandName\[dq]: \[dq]Project\[dq],
    },
    \[dq]Second\[dq]: {
      \[dq]commandName\[dq]: \[dq]Project\[dq],
    }
  }
}
\f[R]
.fi
.PP
And the following \f[I]Program.cs\f[R] file:
.IP
.nf
\f[C]
var value = Environment.GetEnvironmentVariable(\[dq]DOTNET_LAUNCH_PROFILE\[dq]);
Console.WriteLine($\[dq]DOTNET_LAUNCH_PROFILE={value}\[dq]);
\f[R]
.fi
.PP
The following scenarios produce the output shown:
.IP \[bu] 2
Launch profile specified and exists
.RS 2
.IP
.nf
\f[C]
$ dotnet run --launch-profile First
DOTNET_LAUNCH_PROFILE=First
\f[R]
.fi
.RE
.IP \[bu] 2
Launch profile not specified, first one selected
.RS 2
.IP
.nf
\f[C]
$ dotnet run
DOTNET_LAUNCH_PROFILE=First
\f[R]
.fi
.RE
.IP \[bu] 2
Launch profile specified but does not exist
.RS 2
.IP
.nf
\f[C]
$ dotnet run --launch-profile Third
The launch profile \[dq]Third\[dq] could not be applied.
A launch profile with the name \[aq]Third\[aq] doesn\[aq]t exist.
DOTNET_LAUNCH_PROFILE=
\f[R]
.fi
.RE
.IP \[bu] 2
Launch with no profile
.RS 2
.IP
.nf
\f[C]
$ dotnet run --no-launch-profile
DOTNET_LAUNCH_PROFILE=
\f[R]
.fi
.RE
.SS \f[V]NUGET_PACKAGES\f[R]
.PP
The global packages folder.
If not set, it defaults to \f[V]\[ti]/.nuget/packages\f[R] on Unix or \f[V]%userprofile%\[rs].nuget\[rs]packages\f[R] on Windows.
.SS \f[V]DOTNET_SERVICING\f[R]
.PP
Specifies the location of the servicing index to use by the shared host when loading the runtime.
.SS \f[V]DOTNET_NOLOGO\f[R]
.PP
Specifies whether .NET welcome and telemetry messages are displayed on the first run.
Set to \f[V]true\f[R] to mute these messages (values \f[V]true\f[R], \f[V]1\f[R], or \f[V]yes\f[R] accepted) or set to \f[V]false\f[R] to allow them (values \f[V]false\f[R], \f[V]0\f[R], or \f[V]no\f[R] accepted).
If not set, the default is \f[V]false\f[R] and the messages will be displayed on the first run.
This flag does not affect telemetry (see \f[V]DOTNET_CLI_TELEMETRY_OPTOUT\f[R] for opting out of sending telemetry).
.SS \f[V]DOTNET_CLI_PERF_LOG\f[R]
.PP
Specifies whether performance details about the current CLI session are logged.
Enabled when set to \f[V]1\f[R], \f[V]true\f[R], or \f[V]yes\f[R].
This is disabled by default.
.SS \f[V]DOTNET_GENERATE_ASPNET_CERTIFICATE\f[R]
.PP
Specifies whether to generate an ASP.NET Core certificate.
The default value is \f[V]true\f[R], but this can be overridden by setting this environment variable to either \f[V]0\f[R], \f[V]false\f[R], or \f[V]no\f[R].
.SS \f[V]DOTNET_ADD_GLOBAL_TOOLS_TO_PATH\f[R]
.PP
Specifies whether to add global tools to the \f[V]PATH\f[R] environment variable.
The default is \f[V]true\f[R].
To not add global tools to the path, set to \f[V]0\f[R], \f[V]false\f[R], or \f[V]no\f[R].
.SS \f[V]DOTNET_CLI_TELEMETRY_OPTOUT\f[R]
.PP
Specifies whether data about the .NET tools usage is collected and sent to Microsoft.
Set to \f[V]true\f[R] to opt-out of the telemetry feature (values \f[V]true\f[R], \f[V]1\f[R], or \f[V]yes\f[R] accepted).
Otherwise, set to \f[V]false\f[R] to opt in to the telemetry features (values \f[V]false\f[R], \f[V]0\f[R], or \f[V]no\f[R] accepted).
If not set, the default is \f[V]false\f[R] and the telemetry feature is active.
.SS \f[V]DOTNET_SKIP_FIRST_TIME_EXPERIENCE\f[R]
.PP
If \f[V]DOTNET_SKIP_FIRST_TIME_EXPERIENCE\f[R] is set to \f[V]true\f[R], the \f[V]NuGetFallbackFolder\f[R] won\[cq]t be expanded to disk and a shorter welcome message and telemetry notice will be shown.
.RS
.PP
This environment variable is no longer supported in .NET Core 3.0 and later.
Use \f[V]DOTNET_NOLOGO\f[R] as a replacement.
.RE
.SS \f[V]DOTNET_MULTILEVEL_LOOKUP\f[R]
.PP
Specifies whether the .NET runtime, shared framework, or SDK are resolved from the global location.
If not set, it defaults to 1 (logical \f[V]true\f[R]).
Set the value to 0 (logical \f[V]false\f[R]) to not resolve from the global location and have isolated .NET installations.
For more information about multi-level lookup, see Multi-level SharedFX Lookup (https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/multilevel-sharedfx-lookup.md).
.RS
.PP
This environment variable only applies to applications that target .NET 6 and earlier versions.
Starting in .NET 7, .NET only looks for frameworks in one location.
For more information, see Multi-level lookup is disabled.
.RE
.SS \f[V]DOTNET_ROLL_FORWARD\f[R]
.PP
Determines roll forward behavior.
For more information, see the \f[V]--roll-forward\f[R] option for the \f[V]dotnet\f[R] command.
.SS \f[V]DOTNET_ROLL_FORWARD_TO_PRERELEASE\f[R]
.PP
If set to \f[V]1\f[R] (enabled), enables rolling forward to a pre-release version from a release version.
By default (\f[V]0\f[R] - disabled), when a release version of .NET runtime is requested, roll-forward will only consider installed release versions.
.PP
For more information, see the \f[V]--roll-forward\f[R] option for the \f[V]dotnet\f[R] command
.SS \f[V]DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX\f[R]
.PP
Disables minor version roll forward, if set to \f[V]0\f[R].
This setting is superseded in .NET Core 3.0 by \f[V]DOTNET_ROLL_FORWARD\f[R].
The new settings should be used instead.
.SS \f[V]DOTNET_CLI_FORCE_UTF8_ENCODING\f[R]
.PP
Forces the use of UTF-8 encoding in the console, even for older versions of Windows 10 that don\[cq]t fully support UTF-8.
For more information, see SDK no longer changes console encoding when finished.
.SS \f[V]DOTNET_CLI_UI_LANGUAGE\f[R]
.PP
Sets the language of the CLI UI using a locale value such as \f[V]en-us\f[R].
The supported values are the same as for Visual Studio.
For more information, see the section on changing the installer language in the Visual Studio installation documentation.
The .NET resource manager rules apply, so you don\[cq]t have to pick an exact match\[em]you can also pick descendants in the \f[V]CultureInfo\f[R] tree.
For example, if you set it to \f[V]fr-CA\f[R], the CLI will find and use the \f[V]fr\f[R] translations.
If you set it to a language that is not supported, the CLI falls back to English.
.SS \f[V]DOTNET_DISABLE_GUI_ERRORS\f[R]
.PP
For GUI-enabled generated executables - disables dialog popup, which normally shows for certain classes of errors.
It only writes to \f[V]stderr\f[R] and exits in those cases.
.SS \f[V]DOTNET_ADDITIONAL_DEPS\f[R]
.PP
Equivalent to CLI option \f[V]--additional-deps\f[R].
.SS \f[V]DOTNET_RUNTIME_ID\f[R]
.PP
Overrides the detected RID.
.SS \f[V]DOTNET_SHARED_STORE\f[R]
.PP
Location of the \[lq]shared store\[rq] which assembly resolution falls back to in some cases.
.SS \f[V]DOTNET_STARTUP_HOOKS\f[R]
.PP
List of assemblies to load and execute startup hooks from.
.SS \f[V]DOTNET_BUNDLE_EXTRACT_BASE_DIR\f[R]
.PP
Specifies a directory to which a single-file application is extracted before it is executed.
.PP
For more information, see Single-file executables.
.SS \f[V]DOTNET_CLI_HOME\f[R]
.PP
Specifies the location that supporting files for .NET CLI commands should be written to.
For example:
.IP \[bu] 2
User-writable paths for workload packs, manifests, and other supporting data.
.IP \[bu] 2
First-run sentinel/lock files for aspects of the .NET CLI\[cq]s first-run migrations and notification experiences.
.IP \[bu] 2
The default .NET local tool installation location.
.SS \f[V]DOTNET_CLI_CONTEXT_*\f[R]
.IP \[bu] 2
\f[V]DOTNET_CLI_CONTEXT_VERBOSE\f[R]: To enable a verbose context, set to \f[V]true\f[R].
.IP \[bu] 2
\f[V]DOTNET_CLI_CONTEXT_ANSI_PASS_THRU\f[R]: To enable an ANSI pass-through, set to \f[V]true\f[R].
.SS \f[V]DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_DISABLE\f[R]
.PP
Disables background download of advertising manifests for workloads.
Default is \f[V]false\f[R] - not disabled.
If set to \f[V]true\f[R], downloading is disabled.
For more information, see Advertising manifests.
.SS \f[V]DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_INTERVAL_HOURS\f[R]
.PP
Specifies the minimum number of hours between background downloads of advertising manifests for workloads.
The default is \f[V]24\f[R], which is no more frequently than once a day.
For more information, see Advertising manifests.
.SS \f[V]DOTNET_TOOLS_ALLOW_MANIFEST_IN_ROOT\f[R]
.PP
Specifies whether .NET SDK local tools search for tool manifest files in the root folder on Windows.
The default is \f[V]false\f[R].
.SS \f[V]COREHOST_TRACE\f[R]
.PP
Controls diagnostics tracing from the hosting components, such as \f[V]dotnet.exe\f[R], \f[V]hostfxr\f[R], and \f[V]hostpolicy\f[R].
.IP \[bu] 2
\f[V]COREHOST_TRACE=[0/1]\f[R] - default is \f[V]0\f[R] - tracing disabled.
If set to \f[V]1\f[R], diagnostics tracing is enabled.
.IP \[bu] 2
\f[V]COREHOST_TRACEFILE=<file path>\f[R] - has an effect only if tracing is enabled by setting \f[V]COREHOST_TRACE=1\f[R].
When set, the tracing information is written to the specified file; otherwise, the trace information is written to \f[V]stderr\f[R].
.IP \[bu] 2
\f[V]COREHOST_TRACE_VERBOSITY=[1/2/3/4]\f[R] - default is \f[V]4\f[R].
The setting is used only when tracing is enabled via \f[V]COREHOST_TRACE=1\f[R].
.RS 2
.IP \[bu] 2
\f[V]4\f[R] - all tracing information is written
.IP \[bu] 2
\f[V]3\f[R] - only informational, warning, and error messages are written
.IP \[bu] 2
\f[V]2\f[R] - only warning and error messages are written
.IP \[bu] 2
\f[V]1\f[R] - only error messages are written
.RE
.PP
The typical way to get detailed trace information about application startup is to set \f[V]COREHOST_TRACE=1\f[R] and\f[V]COREHOST_TRACEFILE=host_trace.txt\f[R] and then run the application.
A new file \f[V]host_trace.txt\f[R] will be created in the current directory with the detailed information.
.SS \f[V]SuppressNETCoreSdkPreviewMessage\f[R]
.PP
If set to \f[V]true\f[R], invoking \f[V]dotnet\f[R] won\[cq]t produce a warning when a preview SDK is being used.
.SS Configure MSBuild in the .NET CLI
.PP
To execute MSBuild out-of-process, set the \f[V]DOTNET_CLI_RUN_MSBUILD_OUTOFPROC\f[R] environment variable to either \f[V]1\f[R], \f[V]true\f[R], or \f[V]yes\f[R].
By default, MSBuild will execute in-proc.
To force MSBuild to use an external working node long-living process for building projects, set \f[V]DOTNET_CLI_USE_MSBUILDNOINPROCNODE\f[R] to \f[V]1\f[R], \f[V]true\f[R], or \f[V]yes\f[R].
This will set the \f[V]MSBUILDNOINPROCNODE\f[R] environment variable to \f[V]1\f[R], which is referred to as \f[I]MSBuild Server V1\f[R], as the entry process forwards most of the work to it.
.SS \f[V]DOTNET_MSBUILD_SDK_RESOLVER_*\f[R]
.PP
These are overrides that are used to force the resolved SDK tasks and targets to come from a given base directory and report a given version to MSBuild, which may be \f[V]null\f[R] if unknown.
One key use case for this is to test SDK tasks and targets without deploying them by using the .NET Core SDK.
.IP \[bu] 2
\f[V]DOTNET_MSBUILD_SDK_RESOLVER_SDKS_DIR\f[R]: Overrides the .NET SDK directory.
.IP \[bu] 2
\f[V]DOTNET_MSBUILD_SDK_RESOLVER_SDKS_VER\f[R]: Overrides the .NET SDK version.
.IP \[bu] 2
\f[V]DOTNET_MSBUILD_SDK_RESOLVER_CLI_DIR\f[R]: Overrides the \f[I]dotnet.exe\f[R] directory path.
.SS \f[V]DOTNET_NEW_PREFERRED_LANG\f[R]
.PP
Configures the default programming language for the \f[V]dotnet new\f[R] command when the \f[V]-lang|--language\f[R] switch is omitted.
The default value is \f[V]C#\f[R].
Valid values are \f[V]C#\f[R], \f[V]F#\f[R], or \f[V]VB\f[R].
For more information, see dotnet new.
.SH \f[V]dotnet watch\f[R] ENVIRONMENT VARIABLES
.PP
For information about \f[V]dotnet watch\f[R] settings that are available as environment variables, see dotnet watch environment variables.
.SH SEE ALSO
.IP \[bu] 2
dotnet command
.IP \[bu] 2
Runtime Configuration Files (https://github.com/dotnet/sdk/blob/main/documentation/specs/runtime-configuration-file.md)
.IP \[bu] 2
\&.NET runtime configuration settings
