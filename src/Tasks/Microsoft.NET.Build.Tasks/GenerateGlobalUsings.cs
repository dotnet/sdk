// Copyright (c) .NET Foundation and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Build.Framework;

namespace Microsoft.NET.Build.Tasks
{
    public sealed class GenerateGlobalUsings : TaskBase
    {
        [Required]
        public ITaskItem[] Usings { get; set; }

        [Output]
        public string[] Lines { get; set; }

        protected override void ExecuteCore()
        {
            if (Usings.Length == 0)
            {
                Lines = Array.Empty<string>();
                return;
            }

            var usings = Usings.Select(UsingInfo.Read)
                .Distinct(UsingInfoComparer.Instance)
                .OrderBy(static k => k, UsingInfoComparer.Instance)
                .ToArray();

            var lines = new List<string>();
            lines.Add("// <auto-generated/>");

            var lineBuilder = new StringBuilder();
            foreach (var @using in usings)
            {
                lineBuilder.Clear();
                lineBuilder.Append("global using ");

                if (@using.Static)
                {
                    lineBuilder.Append("static ");
                }

                if (!string.IsNullOrEmpty(@using.Alias))
                {
                    lineBuilder.Append(@using.Alias)
                        .Append(" = ");
                }

                lineBuilder.Append("global::")
                    .Append(@using.Namespace)
                    .Append(';');

                lines.Add(lineBuilder.ToString());
            }

            // Minimally define all referenced namespaces to avoid generating a compiler error when the project's
            // target framework does not reference an assembly with that namespace by default
            // (https://github.com/dotnet/sdk/issues/24909).
            foreach (var @using in usings.Where(static u => !u.Static && string.IsNullOrEmpty(u.Alias)))
            {
                lines.Add($"namespace {@using.Namespace} {{ }}");
            }

            Lines = lines.ToArray();
        }

        private readonly struct UsingInfo
        {
            public static UsingInfo Read(ITaskItem taskItem)
            {
                return new UsingInfo(
                    taskItem.ItemSpec,
                    taskItem.GetBooleanMetadata("Static") == true,
                    taskItem.GetMetadata("Alias"));
            }

            private UsingInfo(string @namespace, bool @static, string alias)
            {
                Namespace = @namespace;
                Static = @static;
                Alias = alias;
            }

            public string Namespace { get; }
            public bool Static { get; }
            public string Alias { get; }
        }

        private sealed class UsingInfoComparer : IComparer<UsingInfo>, IEqualityComparer<UsingInfo>
        {
            public static readonly UsingInfoComparer Instance = new();

            public int Compare(UsingInfo x, UsingInfo y)
            {
                var @static = x.Static.CompareTo(y.Static);
                if (@static != 0)
                {
                    return @static;
                }

                var alias = x.Alias.CompareTo(y.Alias);
                if (alias != 0)
                {
                    return alias;
                }

                return StringComparer.Ordinal.Compare(x.Namespace, y.Namespace);
            }

            public bool Equals(UsingInfo x, UsingInfo y)
            {
                return Compare(x, y) == 0;
            }

            public int GetHashCode(UsingInfo obj)
            {
                return StringComparer.Ordinal.GetHashCode(obj.Namespace);
            }
        }
    }
}
