using System;
using System.Collections.Generic;
using System.IO;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using Microsoft.Build.Framework;

namespace Microsoft.NET.Build.Tasks
{
    public class GenerateResxSource : TaskBase
    {
        [Required]
        public ITaskItem[] ResxFiles { get; set; }

        [Required]
        public string Language { get; set; }

        protected override void ExecuteCore()
        {
            // The algorithm used by this class is mostly borrowed from:
            // https://github.com/dotnet/roslyn-tools/blob/master/sdks/RepoToolset/tools/GenerateResxSource.csx,
            // heavily modified for readability.

            foreach (ITaskItem item in ResxFiles)
            {
                string codeBehindPath = item.GetMetadata("CodeBehindFile");
                if (string.IsNullOrEmpty(codeBehindPath))
                    throw new BuildErrorException("Item '{0}' does not have CodeBehindFile metadata", item.ItemSpec);

                try
                {
                    if (Language.ToUpperInvariant() == "C#")
                    {
                        WriteCSharpCodeBehind(item, codeBehindPath);
                    }
                    else if (Language.ToUpperInvariant() == "VB")
                    {
                        WriteVisualBasicCodeBehind(item, codeBehindPath);
                    }
                    else
                    {
                        throw new BuildErrorException($"Unrecognized language '{Language}'");
                    }
                }
                catch (InvalidDataException e)
                {
                    throw new BuildErrorException($"Error parsing file '{item.ItemSpec}': {e.Message}", e);
                }
            }
        }

        private static bool IsLetterCharacter(char ch)
        {
            switch (char.GetUnicodeCategory(ch))
            {
                case UnicodeCategory.UppercaseLetter:
                case UnicodeCategory.LowercaseLetter:
                case UnicodeCategory.TitlecaseLetter:
                case UnicodeCategory.ModifierLetter:
                case UnicodeCategory.OtherLetter:
                case UnicodeCategory.LetterNumber:
                    return true;

                default:
                    return false;
            }
        }

        private void WriteCSharpCodeBehind(ITaskItem resxFile, string codeBehindFile)
        {
            StringBuilder builder = new StringBuilder();

            builder.AppendLine("// <auto-generated />");
            builder.AppendLine("using System.Reflection");
            builder.AppendLine();

            string resourceName = resxFile.GetMetadata("ManifestResourceName");
            string[] nameParts = resourceName.Split('.');
            string namespaceName, className, classIndent;
            if (nameParts.Length > 1)
            {
                namespaceName = string.Join(".", nameParts, 0, nameParts.Length - 1);
                className = nameParts.Last();
                classIndent = "    ";
            }
            else
            {
                namespaceName = null;
                className = nameParts[0];
                classIndent = "";
            }

            string memberIndent = classIndent + "    ";

            if (namespaceName != null)
                builder.AppendLine($"namespace {namespaceName} {{");

            builder.AppendLine($"{classIndent}internal static class {className}");
            builder.AppendLine("{");

            builder.AppendLine($"{memberIndent}internal static global::System.Globalization.CultureInfo Culture {{ get; set; }}");
            builder.AppendLine($"{memberIndent}internal static global::System.Resources.ResourceManager ResourceManager {{ get; }} = new global::System.Resources.ResourceManager(\"{resourceName}\", typeof({className}).GetTypeInfo().Assembly);");
            builder.AppendLine();

            foreach (var node in XDocument.Load(resxFile.ItemSpec).Descendants("data"))
            {
                string name = node.Attribute("name")?.Value ?? throw new InvalidDataException("Missing resource name");
                string value = node.Elements("value").FirstOrDefault()?.Value.Trim() ?? throw new InvalidDataException($"Missing resource value: '{name}'");
                string comment = node.Elements("comment").FirstOrDefault()?.Value.Trim();

                if (name == "")
                    throw new InvalidDataException("Empty resource name");

                // If the comment was provided by the developer, use that.
                // Otherwise, generate a default comment like the old ResX generator does.
                if (comment == null)
                {
                    const int maxDocCommentLength = 256;
                    if (value.Length > maxDocCommentLength)
                        comment = "Looks up a localized string similar to " + value.Substring(0, maxDocCommentLength) + " [truncated].";
                    else
                        comment = $"Looks up a localized string similar to {value}.";
                }

                string escapedTrimmedValue = new XAttribute("summary", comment).ToString();
                foreach (var line in escapedTrimmedValue.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None))
                    builder.AppendLine($"{memberIndent}/// {line}");

                string identifier = IsLetterCharacter(name[0]) ? name : "_" + name;
                builder.AppendLine($"{memberIndent}internal static string {identifier} => ResourceManager.GetString(\"{name}\", Culture);");
            }

            builder.Append($"{classIndent}}}");

            if (namespaceName != null)
                builder.AppendLine("}");

            File.WriteAllText(codeBehindFile, builder.ToString());
        }

        private void WriteVisualBasicCodeBehind(ITaskItem resxFile, string codeBehindFile)
        {
            StringBuilder builder = new StringBuilder();

            builder.AppendLine("' <auto-generated />");
            builder.AppendLine("Imports System.Reflection");
            builder.AppendLine();

            string resourceName = resxFile.GetMetadata("ManifestResourceName");
            string[] nameParts = resourceName.Split('.');
            string namespaceName, className, classIndent;
            if (nameParts.Length > 1)
            {
                namespaceName = string.Join(".", nameParts, 0, nameParts.Length - 1);
                className = nameParts.Last();
                classIndent = "    ";
            }
            else
            {
                namespaceName = null;
                className = nameParts[0];
                classIndent = "";
            }

            string memberIndent = classIndent + "    ";

            if (namespaceName != null)
                builder.AppendLine($"Namespace {namespaceName}");

            builder.AppendLine($"{classIndent}Friend Class {className}");
            builder.AppendLine($"{memberIndent}Private Sub New()");
            builder.AppendLine($"{memberIndent}End Sub");
            builder.AppendLine();

            builder.AppendLine($"{memberIndent}Friend Shared Property Culture As Global.System.Globalization.CultureInfo");
            builder.AppendLine($"{memberIndent}Friend Shared ReadOnly Property ResourceManager As New Global.System.Resources.ResourceManager ResourceManager(\"{resourceName}\", GetType({className}).GetTypeInfo().Assembly);");
            builder.AppendLine();

            foreach (var node in XDocument.Load(resxFile.ItemSpec).Descendants("data"))
            {
                string name = node.Attribute("name")?.Value ?? throw new InvalidDataException("Missing resource name");
                string value = node.Elements("value").FirstOrDefault()?.Value.Trim() ?? throw new InvalidDataException($"Missing resource value: '{name}'");
                string comment = node.Elements("comment").FirstOrDefault()?.Value.Trim();

                if (name == "")
                    throw new InvalidDataException("Empty resource name");

                // If the comment was provided by the developer, use that.
                // Otherwise, generate a default comment like the old ResX generator does.
                if (comment == null)
                {
                    const int maxDocCommentLength = 256;
                    if (value.Length > maxDocCommentLength)
                        comment = "Looks up a localized string similar to " + value.Substring(0, maxDocCommentLength) + " [truncated].";
                    else
                        comment = $"Looks up a localized string similar to {value}.";
                }

                string escapedTrimmedValue = new XAttribute("summary", comment).ToString();
                foreach (var line in escapedTrimmedValue.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None))
                    builder.AppendLine($"{memberIndent}''' {line}");

                string identifier = IsLetterCharacter(name[0]) ? name : "_" + name;
                builder.AppendLine($"{memberIndent}Friend Shared ReadOnly Property {identifier} As String");
                builder.AppendLine($"{memberIndent}    Get");
                builder.AppendLine($"{memberIndent}        Return ResourceManager.GetString(\"{name}\", Culture)");
                builder.AppendLine($"{memberIndent}    End Get");
                builder.AppendLine($"{memberIndent}End Property");
                builder.AppendLine();
            }

            builder.Append($"{classIndent}End Class");

            if (namespaceName != null)
                builder.AppendLine("End Namespace");

            File.WriteAllText(codeBehindFile, builder.ToString());
        }
    }
}
