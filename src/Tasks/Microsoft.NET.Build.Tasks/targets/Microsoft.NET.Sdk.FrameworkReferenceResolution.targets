<!--
***********************************************************************************************
Microsoft.NET.Sdk.FrameworkReferenceResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
<Project>
  <PropertyGroup>
    <ResolveAssemblyReferencesDependsOn>
      $(ResolveAssemblyReferencesDependsOn);
      ResolveTargetingPackAssets;
    </ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>

  <UsingTask TaskName="CreateWindowsSdkKnownFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="GetPackagesToPrune" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="CheckForDuplicateFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ProcessFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveAppHosts" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />


  <!-- Don't add Windows SDK framework reference for C++ by default, as C++ doesn't use it and it would be an unnecessary download for possible
       transitive framework references. -->
  <Target Name="AddWindowsSdkKnownFrameworkReferences"
          Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(TargetPlatformIdentifier)' == 'Windows'
                     And ('$(Language)' != 'C++' Or '$(IncludeWindowsSDKRefFrameworkReferences)' == 'true')">

    <!-- Remove Windows SDK KnownFrameworkReference items from BundledVersions.props (they will eventually be removed, but that is in a different repo so
         we can't do the change atomically). -->
    <ItemGroup>
      <KnownFrameworkReference Remove="Microsoft.Windows.SDK.NET.Ref" />
    </ItemGroup>

    <!-- Generate KnownFrameworkReference items for the Windows SDK pack -->
    <CreateWindowsSdkKnownFrameworkReferences
      UseWindowsSDKPreview="$(UseWindowsSDKPreview)"
      WindowsSdkPackageVersion="$(WindowsSdkPackageVersion)"
      WindowsSdkPackageMinimumRevision="$(WindowsSdkPackageMinimumRevision)"
      TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
      TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)"
      TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
      TargetPlatformVersion="$(TargetPlatformVersion)"
      WindowsSdkSupportedTargetPlatformVersions="@(WindowsSdkSupportedTargetPlatformVersion)">

      <Output TaskParameter="KnownFrameworkReferences" ItemName="KnownFrameworkReference" />

    </CreateWindowsSdkKnownFrameworkReferences>
  </Target>

  <!-- TODO: https://github.com/dotnet/sdk/issues/49917 Remove the framework based condition when the data for netcoreapp2.1 and below is fixed-->
  <!-- Package pruning is expected to be enable for all TFMs for multi-targeted projects, so still generate the pruning data when RestoreEnablePackagePruning is '' which implies a multi-targeted project. -->
  <Target Name="AddPrunePackageReferences" BeforeTargets="CollectPrunePackageReferences"
          DependsOnTargets="ProcessFrameworkReferences"
          Condition="'$(RestoreEnablePackagePruning)' == 'true' OR '$(RestoreEnablePackagePruning)' == ''">
    <PropertyGroup>
      <PrunePackageDataRoot Condition="'$(PrunePackageDataRoot)' == ''">$(NetCoreRoot)\sdk\$(NETCoreSdkVersion)\PrunePackageData\</PrunePackageDataRoot>
      <PrunePackageTargetingPackRoots Condition="'$(PrunePackageTargetingPackRoots)' == ''">$(NetCoreTargetingPackRoot)</PrunePackageTargetingPackRoots>
      <AllowMissingPrunePackageData Condition="'$(AllowMissingPrunePackageData)' == ''">false</AllowMissingPrunePackageData>
    </PropertyGroup>

    <GetPackagesToPrune TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
                        TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)"
                        FrameworkReferences="@(FrameworkReference)"
                        TargetingPacks="@(TargetingPack)"
                        TargetingPackRoots="$(PrunePackageTargetingPackRoots)"
                        PrunePackageDataRoot="$(PrunePackageDataRoot)"
                        AllowMissingPrunePackageData="$(AllowMissingPrunePackageData)">
      <Output TaskParameter="PackagesToPrune" ItemName="PrunePackageReference" />
    </GetPackagesToPrune>

  </Target>

  <!--
    ============================================================
                                        ProcessFrameworkReferences (Refactored)

    The following targets break down framework reference resolution into logical steps.
    Set UseRefactoredFrameworkReferenceResolution=false to use the original monolithic task.
    ============================================================
    -->

  <!--
    Compute settings that determine which packs are needed based on deployment model.
    -->
  <Target Name="_ComputeFrameworkReferenceSettings">
    <!-- Determine if deployment model requires runtime-specific components -->
    <PropertyGroup>
      <_DeploymentRequiresRuntimeComponents>false</_DeploymentRequiresRuntimeComponents>
      <_DeploymentRequiresRuntimeComponents Condition="'$(SelfContained)' == 'true'">true</_DeploymentRequiresRuntimeComponents>
      <_DeploymentRequiresRuntimeComponents Condition="'$(PublishReadyToRun)' == 'true'">true</_DeploymentRequiresRuntimeComponents>
      <_DeploymentRequiresRuntimeComponents Condition="'$(_RequiresILLinkPack)' == 'true'">true</_DeploymentRequiresRuntimeComponents>

      <!-- Normalize RuntimeIdentifier: treat 'any' as null for platform-agnostic builds -->
      <_EffectiveRuntimeIdentifier Condition="'$(RuntimeIdentifier)' != 'any'">$(RuntimeIdentifier)</_EffectiveRuntimeIdentifier>

      <!-- Determine if project is platform-specific -->
      <_ProjectIsPlatformSpecific Condition="'$(_EffectiveRuntimeIdentifier)' != ''">true</_ProjectIsPlatformSpecific>
    </PropertyGroup>
  </Target>

  <!--
    Filter KnownFrameworkReferences and KnownRuntimePacks by target framework.
    Parses TargetFramework metadata (e.g., "net9.0-windows10.0") into components.
    Uses VersionEquals for proper version normalization (5.0.0.0 == 5.0).
    -->
  <Target Name="_FilterApplicableFrameworkReferences"
          DependsOnTargets="_ComputeFrameworkReferenceSettings">
    <ItemGroup>
      <!-- Parse TargetFramework into components and filter KnownFrameworkReferences -->
      <!-- MSBuild functions: GetTargetFrameworkIdentifier, GetTargetFrameworkVersion, GetTargetPlatformIdentifier, GetTargetPlatformVersion -->
      <_KnownFrameworkReferenceMatchingTFI Include="@(KnownFrameworkReference)"
        Condition="$([MSBuild]::GetTargetFrameworkIdentifier('%(KnownFrameworkReference.TargetFramework)')) == '$(TargetFrameworkIdentifier)'" />

      <!-- Filter by TFM version using VersionEquals for normalization -->
      <_ApplicableKnownFrameworkReference Include="@(_KnownFrameworkReferenceMatchingTFI)"
        Condition="$([MSBuild]::VersionEquals($([MSBuild]::GetTargetFrameworkVersion('%(_KnownFrameworkReferenceMatchingTFI.TargetFramework)', 2)), '$(_TargetFrameworkVersionWithoutV)'))" />

      <!-- Parse platform identifier from TargetFramework and filter if both are specified -->
      <_ApplicableKnownFrameworkReference Remove="@(_ApplicableKnownFrameworkReference)"
        Condition="'$(TargetPlatformIdentifier)' != '' AND
                   $([MSBuild]::GetTargetPlatformIdentifier('%(_ApplicableKnownFrameworkReference.TargetFramework)')) != '' AND
                   $([MSBuild]::GetTargetPlatformIdentifier('%(_ApplicableKnownFrameworkReference.TargetFramework)')) != '$(TargetPlatformIdentifier)'" />

      <!-- Parse platform version from TargetFramework and filter if both are specified (using VersionEquals) -->
      <_ApplicableKnownFrameworkReference Remove="@(_ApplicableKnownFrameworkReference)"
        Condition="'$(TargetPlatformVersion)' != '' AND
                   $([MSBuild]::GetTargetPlatformVersion('%(_ApplicableKnownFrameworkReference.TargetFramework)', 2)) != '' AND
                   !$([MSBuild]::VersionEquals($([MSBuild]::GetTargetPlatformVersion('%(_ApplicableKnownFrameworkReference.TargetFramework)', 2)), '$(TargetPlatformVersion)'))" />
    </ItemGroup>

    <ItemGroup>
      <!-- Same filtering for KnownRuntimePacks -->
      <_KnownRuntimePackMatchingTFI Include="@(KnownRuntimePack)"
        Condition="$([MSBuild]::GetTargetFrameworkIdentifier('%(KnownRuntimePack.TargetFramework)')) == '$(TargetFrameworkIdentifier)'" />

      <_ApplicableKnownRuntimePack Include="@(_KnownRuntimePackMatchingTFI)"
        Condition="$([MSBuild]::VersionEquals($([MSBuild]::GetTargetFrameworkVersion('%(_KnownRuntimePackMatchingTFI.TargetFramework)', 2)), '$(_TargetFrameworkVersionWithoutV)'))" />

      <_ApplicableKnownRuntimePack Remove="@(_ApplicableKnownRuntimePack)"
        Condition="'$(TargetPlatformIdentifier)' != '' AND
                   $([MSBuild]::GetTargetPlatformIdentifier('%(_ApplicableKnownRuntimePack.TargetFramework)')) != '' AND
                   $([MSBuild]::GetTargetPlatformIdentifier('%(_ApplicableKnownRuntimePack.TargetFramework)')) != '$(TargetPlatformIdentifier)'" />

      <_ApplicableKnownRuntimePack Remove="@(_ApplicableKnownRuntimePack)"
        Condition="'$(TargetPlatformVersion)' != '' AND
                   $([MSBuild]::GetTargetPlatformVersion('%(_ApplicableKnownRuntimePack.TargetFramework)', 2)) != '' AND
                   !$([MSBuild]::VersionEquals($([MSBuild]::GetTargetPlatformVersion('%(_ApplicableKnownRuntimePack.TargetFramework)', 2)), '$(TargetPlatformVersion)'))" />
    </ItemGroup>
  </Target>

  <!--
    Validate that Windows-only frameworks aren't referenced on non-Windows platforms.
    -->
  <Target Name="_ValidateWindowsOnlyFrameworks"
          DependsOnTargets="_JoinFrameworkReferencesWithKnownData">
    <ItemGroup>
      <_WindowsOnlyFrameworkReference Include="@(_JoinedFrameworkReference)"
        Condition="'%(_JoinedFrameworkReference.IsWindowsOnly)' == 'true'" />
    </ItemGroup>

    <NetSdkError Condition="'@(_WindowsOnlyFrameworkReference)' != '' AND
                            '$(OS)' != 'Windows_NT' AND
                            '$(EnableWindowsTargeting)' != 'true'"
                 ResourceName="WindowsDesktopFrameworkRequiresWindows" />

    <!-- Remove Windows-only frameworks from processing on non-Windows -->
    <ItemGroup Condition="'$(OS)' != 'Windows_NT' AND '$(EnableWindowsTargeting)' != 'true'">
      <_ApplicableKnownFrameworkReference Remove="@(_ApplicableKnownFrameworkReference)"
        Condition="'%(_ApplicableKnownFrameworkReference.IsWindowsOnly)' == 'true'" />
      <_JoinedFrameworkReference Remove="@(_JoinedFrameworkReference)"
        Condition="'%(_JoinedFrameworkReference.IsWindowsOnly)' == 'true'" />
    </ItemGroup>
  </Target>

  <!--
    Join user FrameworkReferences with KnownFrameworkReferences to combine metadata.
    -->
  <Target Name="_JoinFrameworkReferencesWithKnownData"
          DependsOnTargets="_FilterApplicableFrameworkReferences">
    <JoinItems Left="@(_ApplicableKnownFrameworkReference)"
               Right="@(FrameworkReference)"
               LeftMetadata="*"
               RightMetadata="TargetingPackVersion;RuntimeFrameworkVersion;RuntimePackLabels;TargetLatestRuntimePatch"
               ItemSpecToUse="Left">
      <Output TaskParameter="JoinResult" ItemName="_JoinedFrameworkReference" />
    </JoinItems>

    <ItemGroup>
      <!-- All of the newly-joined framework references are directly referenced -->
      <_JoinedFrameworkReference>
        <WasReferencedDirectly>true</WasReferencedDirectly>
      </_JoinedFrameworkReference>
    </ItemGroup>

    <!-- Also include framework references without user reference if not disabling transitive -->
    <ItemGroup Condition="'$(DisableTransitiveFrameworkReferenceDownloads)' != 'true'">
      <_UnreferencedKnownFrameworkReference Include="@(_ApplicableKnownFrameworkReference)"
        Exclude="@(_JoinedFrameworkReference)" />
      <_JoinedFrameworkReference Include="@(_UnreferencedKnownFrameworkReference)" />
    </ItemGroup>
  </Target>

  <!--
    Select the appropriate runtime pack for each framework reference based on RuntimePackLabels.
    -->
  <Target Name="_SelectRuntimePacksByLabels"
          DependsOnTargets="_JoinFrameworkReferencesWithKnownData">
    <ItemGroup>
      <!-- For each joined framework reference, find matching runtime packs -->
      <!-- Cross-join: For each framework reference, create items for all runtime packs with matching name -->
      <_CandidateRuntimePack Include="@(_ApplicableKnownRuntimePack)"
        Condition="'%(_ApplicableKnownRuntimePack.Identity)' == '%(_JoinedFrameworkReference.RuntimeFrameworkName)'"
        KeepMetadata="RuntimePackNamePatterns;RuntimePackRuntimeIdentifiers;RuntimePackExcludedRuntimeIdentifiers;LatestRuntimeFrameworkVersion;RuntimePackLabels;IsTrimmable;RuntimePackAlwaysCopyLocal">
        <FrameworkReferenceName>%(_JoinedFrameworkReference.Identity)</FrameworkReferenceName>
        <RequiredRuntimePackLabels>%(_JoinedFrameworkReference.RuntimePackLabels)</RequiredRuntimePackLabels>
      </_CandidateRuntimePack>
    </ItemGroup>

    <!-- Filter to runtime packs where labels match exactly (or both are empty) -->
    <ItemGroup>
      <_MatchedRuntimePack Include="@(_CandidateRuntimePack)"
        Condition="'%(_CandidateRuntimePack.RuntimePackLabels)' == '%(_CandidateRuntimePack.RequiredRuntimePackLabels)' OR
                   ('%(_CandidateRuntimePack.RuntimePackLabels)' == '' AND '%(_CandidateRuntimePack.RequiredRuntimePackLabels)' == '')" />
    </ItemGroup>
  </Target>

  <!--
    Create TargetingPack items for compilation.
    -->
  <Target Name="_CreateTargetingPackItems"
          DependsOnTargets="_SelectRuntimePacksByLabels">
    <ItemGroup>
      <_TargetingPack Include="@(_JoinedFrameworkReference)">
        <NuGetPackageId>%(_JoinedFrameworkReference.TargetingPackName)</NuGetPackageId>
        <NuGetPackageVersion>%(_JoinedFrameworkReference.TargetingPackVersion)</NuGetPackageVersion>
        <TargetingPackFormat>%(_JoinedFrameworkReference.TargetingPackFormat)</TargetingPackFormat>
        <TargetFramework>%(_JoinedFrameworkReference.TargetFramework)</TargetFramework>
        <RuntimeFrameworkName>%(_JoinedFrameworkReference.RuntimeFrameworkName)</RuntimeFrameworkName>
        <Profile>%(_JoinedFrameworkReference.Profile)</Profile>
        <!-- Check if pack exists locally in any pack root -->
        <PackageDirectory Condition="Exists('$(NetCoreTargetingPackRoot)\%(_JoinedFrameworkReference.TargetingPackName)\%(_JoinedFrameworkReference.TargetingPackVersion)')">$(NetCoreTargetingPackRoot)\%(_JoinedFrameworkReference.TargetingPackName)\%(_JoinedFrameworkReference.TargetingPackVersion)</PackageDirectory>
      </_TargetingPack>
      <_TargetingPack>
        <Path>%(_TargetingPack.PackageDirectory)</Path>
      </_TargetingPack>
      <TargetingPack Include="@(_TargetingPack)" />
    </ItemGroup>

    <!-- Add targeting packs to download list if not found locally and downloads enabled -->
    <ItemGroup Condition="'$(EnableTargetingPackDownload)' == 'true'">
      <_PackageToDownload Include="@(TargetingPack->'%(TargetingPackName)')"
        Condition="'%(TargetingPack.PackageDirectory)' == '' AND
                   ('%(TargetingPack.WasReferencedDirectly)' == 'true' OR '$(DisableTransitiveFrameworkReferenceDownloads)' != 'true')">
        <Version>%(TargetingPack.NuGetPackageVersion)</Version>
      </_PackageToDownload>
    </ItemGroup>

    <!-- Build PackageConflictPreferredPackages list -->
    <ItemGroup>
      <_PreferredPackage Include="%(TargetingPack.NuGetPackageId)" />
      <_PreferredPackage Include="@(_MatchedRuntimePack->'%(RuntimePackNamePatterns)')" />
    </ItemGroup>

    <PropertyGroup>
      <_PackageConflictPreferredPackages>@(_PreferredPackage, ';')</_PackageConflictPreferredPackages>
    </PropertyGroup>

    <ItemGroup>
      <TargetingPack>
        <PackageConflictPreferredPackages>$(_PackageConflictPreferredPackages)</PackageConflictPreferredPackages>
      </TargetingPack>
    </ItemGroup>
  </Target>

  <!--
    Resolve runtime packs for the primary RuntimeIdentifier.
    -->
  <Target Name="_ResolveRuntimePacksForPrimaryRID"
          DependsOnTargets="_CreateTargetingPackItems"
          Condition="'$(_DeploymentRequiresRuntimeComponents)' == 'true' AND '$(_EffectiveRuntimeIdentifier)' != ''">

    <!-- For each matched runtime pack, find best matching RID -->
    <!-- Output MatchingRid as Item (not Property) so batching accumulates results -->
    <PickBestRid RuntimeGraphPath="$(RuntimeIdentifierGraphPath)"
                 TargetRid="$(_EffectiveRuntimeIdentifier)"
                 SupportedRids="%(_MatchedRuntimePack.RuntimePackRuntimeIdentifiers)"
                 Condition="'@(_MatchedRuntimePack)' != ''">
      <Output TaskParameter="MatchingRid" ItemName="_PrimaryMatchedRid" />
    </PickBestRid>

    <!-- Create RuntimePack items by substituting **RID** in pattern with matched RID -->
    <!-- Cross-join pattern: Each _MatchedRuntimePack × each _PrimaryMatchedRid creates runtime pack items -->
    <ItemGroup>
      <_RuntimePackWithRid Include="@(_MatchedRuntimePack->'%(RuntimePackNamePatterns)')">
        <MatchedRid>%(_PrimaryMatchedRid.Identity)</MatchedRid>
        <FrameworkName>%(_MatchedRuntimePack.FrameworkReferenceName)</FrameworkName>
        <LatestVersion>%(_MatchedRuntimePack.LatestRuntimeFrameworkVersion)</LatestVersion>
        <IsTrimmable>%(_MatchedRuntimePack.IsTrimmable)</IsTrimmable>
        <RuntimePackAlwaysCopyLocal>%(_MatchedRuntimePack.RuntimePackAlwaysCopyLocal)</RuntimePackAlwaysCopyLocal>
      </_RuntimePackWithRid>

      <!-- Substitute **RID** placeholder -->
      <RuntimePack Include="@(_RuntimePackWithRid->'%(Identity)'.Replace('**RID**', '%(MatchedRid)'))">
        <NuGetPackageId>%(RuntimePack.Identity)</NuGetPackageId>
        <NuGetPackageVersion>%(_RuntimePackWithRid.LatestVersion)</NuGetPackageVersion>
        <FrameworkName>%(_RuntimePackWithRid.FrameworkName)</FrameworkName>
        <RuntimeIdentifier>%(_RuntimePackWithRid.MatchedRid)</RuntimeIdentifier>
        <IsTrimmable>%(_RuntimePackWithRid.IsTrimmable)</IsTrimmable>
        <RuntimePackAlwaysCopyLocal>%(_RuntimePackWithRid.RuntimePackAlwaysCopyLocal)</RuntimePackAlwaysCopyLocal>
      </RuntimePack>
    </ItemGroup>

    <!-- Add to download list if not found locally -->
    <ItemGroup Condition="'$(EnableRuntimePackDownload)' == 'true'">
      <_PackageToDownload Include="@(RuntimePack)"
        Condition="!Exists('$(NetCoreTargetingPackRoot)\%(RuntimePack.NuGetPackageId)\%(RuntimePack.NuGetPackageVersion)')">
        <Version>%(RuntimePack.NuGetPackageVersion)</Version>
      </_PackageToDownload>
    </ItemGroup>
  </Target>

  <!--
    Resolve runtime packs for additional RuntimeIdentifiers (for multi-RID publish scenarios).
    These are downloaded but not added to RuntimePack output.
    -->
  <Target Name="_ResolveRuntimePacksForAdditionalRIDs"
          DependsOnTargets="_ResolveRuntimePacksForPrimaryRID"
          Condition="'$(EnableRuntimePackDownload)' == 'true' AND '$(RuntimeIdentifiers)' != ''">

    <!-- Split RuntimeIdentifiers into items -->
    <ItemGroup>
      <_AdditionalRuntimeIdentifier Include="$(RuntimeIdentifiers)" />
      <!-- Remove primary RID if it's already processed -->
      <_AdditionalRuntimeIdentifier Remove="$(_EffectiveRuntimeIdentifier)" />
      <_AdditionalRuntimeIdentifier Remove="any" />
    </ItemGroup>

    <!-- Batch PickBestRid for each additional RID - outputs accumulate as Items -->
    <PickBestRid RuntimeGraphPath="$(RuntimeIdentifierGraphPath)"
                 TargetRid="%(_AdditionalRuntimeIdentifier.Identity)"
                 SupportedRids="%(_MatchedRuntimePack.RuntimePackRuntimeIdentifiers)"
                 Condition="'@(_AdditionalRuntimeIdentifier)' != '' AND '@(_MatchedRuntimePack)' != ''">
      <Output TaskParameter="MatchingRid" ItemName="_AdditionalMatchedRid" />
    </PickBestRid>

    <!-- Deduplicate matched RIDs -->
    <RemoveDuplicates Inputs="@(_AdditionalMatchedRid)" Condition="'@(_AdditionalMatchedRid)' != ''">
      <Output TaskParameter="Filtered" ItemName="_UniqueAdditionalMatchedRid" />
    </RemoveDuplicates>

    <!-- Create download items for additional RIDs -->
    <!-- Cross-join: Each runtime pack pattern × each unique additional RID -->
    <ItemGroup Condition="'@(_UniqueAdditionalMatchedRid)' != ''">
      <_AdditionalRuntimePackWithRid Include="@(_MatchedRuntimePack->'%(RuntimePackNamePatterns)')">
        <MatchedRid>%(_UniqueAdditionalMatchedRid.Identity)</MatchedRid>
        <LatestVersion>%(_MatchedRuntimePack.LatestRuntimeFrameworkVersion)</LatestVersion>
      </_AdditionalRuntimePackWithRid>

      <!-- Substitute **RID** and add to download list -->
      <_PackageToDownload Include="@(_AdditionalRuntimePackWithRid->'%(Identity)'.Replace('**RID**', '%(MatchedRid)'))">
        <Version>%(_AdditionalRuntimePackWithRid.LatestVersion)</Version>
      </_PackageToDownload>
    </ItemGroup>
  </Target>

  <!--
    Resolve Crossgen2 packs for ReadyToRun compilation.
    -->
  <Target Name="_ResolveCrossgen2Packs"
          DependsOnTargets="_FilterApplicableFrameworkReferences"
          Condition="'$(PublishReadyToRun)' == 'true' AND '$(PublishReadyToRunUseCrossgen2)' == 'true'">

    <!-- Filter Crossgen2 packs by TFM (parse TargetFramework) -->
    <ItemGroup>
      <_KnownCrossgen2PackMatchingTFI Include="@(KnownCrossgen2Pack)"
        Condition="$([MSBuild]::GetTargetFrameworkIdentifier('%(KnownCrossgen2Pack.TargetFramework)')) == '$(TargetFrameworkIdentifier)'" />

      <_ApplicableCrossgen2Pack Include="@(_KnownCrossgen2PackMatchingTFI)"
        Condition="$([MSBuild]::VersionEquals($([MSBuild]::GetTargetFrameworkVersion('%(_KnownCrossgen2PackMatchingTFI.TargetFramework)', 2)), '$(_TargetFrameworkVersionWithoutV)'))" />
    </ItemGroup>

    <!-- Find best host RID for the SDK -->
    <PickBestRid RuntimeGraphPath="$(RuntimeIdentifierGraphPath)"
                 TargetRid="$(NETCoreSdkRuntimeIdentifier)"
                 SupportedRids="%(_ApplicableCrossgen2Pack.Crossgen2RuntimeIdentifiers)"
                 Condition="'@(_ApplicableCrossgen2Pack)' != ''">
      <Output TaskParameter="MatchingRid" ItemName="_Crossgen2HostRid" />
    </PickBestRid>

    <!-- Create Crossgen2Pack item -->
    <ItemGroup Condition="'@(_Crossgen2HostRid)' != ''">
      <Crossgen2Pack Include="@(_ApplicableCrossgen2Pack->'%(Crossgen2PackNamePattern)'.Replace('**RID**', '%(_Crossgen2HostRid.Identity)'))">
        <NuGetPackageId>%(Crossgen2Pack.Identity)</NuGetPackageId>
        <NuGetPackageVersion>%(_ApplicableCrossgen2Pack.Crossgen2PackVersion)</NuGetPackageVersion>
        <RuntimeIdentifier>%(_Crossgen2HostRid.Identity)</RuntimeIdentifier>
      </Crossgen2Pack>
    </ItemGroup>

    <!-- Add to download list if needed -->
    <ItemGroup Condition="'$(EnableRuntimePackDownload)' == 'true' AND '@(Crossgen2Pack)' != ''">
      <_PackageToDownload Include="@(Crossgen2Pack)"
        Condition="!Exists('$(NetCoreTargetingPackRoot)\%(Crossgen2Pack.NuGetPackageId)\%(Crossgen2Pack.NuGetPackageVersion)')">
        <Version>%(Crossgen2Pack.NuGetPackageVersion)</Version>
      </_PackageToDownload>
    </ItemGroup>
  </Target>

  <!--
    Resolve ILCompiler packs for Native AOT compilation (both host and target).
    -->
  <Target Name="_ResolveILCompilerPacks"
          DependsOnTargets="_FilterApplicableFrameworkReferences"
          Condition="'$(PublishAot)' == 'true'">

    <!-- Filter ILCompiler packs by TFM (parse TargetFramework) -->
    <ItemGroup>
      <_KnownILCompilerPackMatchingTFI Include="@(KnownILCompilerPack)"
        Condition="$([MSBuild]::GetTargetFrameworkIdentifier('%(KnownILCompilerPack.TargetFramework)')) == '$(TargetFrameworkIdentifier)'" />

      <_ApplicableILCompilerPack Include="@(_KnownILCompilerPackMatchingTFI)"
        Condition="$([MSBuild]::VersionEquals($([MSBuild]::GetTargetFrameworkVersion('%(_KnownILCompilerPackMatchingTFI.TargetFramework)', 2)), '$(_TargetFrameworkVersionWithoutV)'))" />
    </ItemGroup>

    <!-- Find best host RID for the SDK -->
    <PickBestRid RuntimeGraphPath="$(RuntimeIdentifierGraphPath)"
                 TargetRid="$(NETCoreSdkRuntimeIdentifier)"
                 SupportedRids="%(_ApplicableILCompilerPack.ILCompilerRuntimeIdentifiers)"
                 Condition="'@(_ApplicableILCompilerPack)' != ''">
      <Output TaskParameter="MatchingRid" ItemName="_ILCompilerHostRid" />
    </PickBestRid>

    <!-- Create host ILCompiler pack -->
    <ItemGroup Condition="'@(_ILCompilerHostRid)' != ''">
      <HostILCompilerPack Include="@(_ApplicableILCompilerPack->'%(ILCompilerPackNamePattern)'.Replace('**RID**', '%(_ILCompilerHostRid.Identity)'))">
        <NuGetPackageId>%(HostILCompilerPack.Identity)</NuGetPackageId>
        <NuGetPackageVersion>%(_ApplicableILCompilerPack.ILCompilerPackVersion)</NuGetPackageVersion>
        <RuntimeIdentifier>%(_ILCompilerHostRid.Identity)</RuntimeIdentifier>
      </HostILCompilerPack>
    </ItemGroup>

    <!-- Find best target RID(s) for cross-compilation -->
    <ItemGroup>
      <_ILCompilerTargetRidToResolve Include="$(_EffectiveRuntimeIdentifier)" Condition="'$(_EffectiveRuntimeIdentifier)' != ''" />
      <_ILCompilerTargetRidToResolve Include="$(RuntimeIdentifiers)" />
      <_ILCompilerTargetRidToResolve Remove="any" />
    </ItemGroup>

    <!-- Batch PickBestRid for each target RID -->
    <PickBestRid RuntimeGraphPath="$(RuntimeIdentifierGraphPath)"
                 TargetRid="%(_ILCompilerTargetRidToResolve.Identity)"
                 SupportedRids="%(_ApplicableILCompilerPack.ILCompilerRuntimeIdentifiers)"
                 Condition="'@(_ILCompilerTargetRidToResolve)' != '' AND '@(_ApplicableILCompilerPack)' != ''">
      <Output TaskParameter="MatchingRid" ItemName="_ILCompilerTargetRid" />
    </PickBestRid>

    <!-- Deduplicate target RIDs -->
    <RemoveDuplicates Inputs="@(_ILCompilerTargetRid)" Condition="'@(_ILCompilerTargetRid)' != ''">
      <Output TaskParameter="Filtered" ItemName="_UniqueILCompilerTargetRid" />
    </RemoveDuplicates>

    <!-- Filter out target RIDs that match host RID -->
    <ItemGroup>
      <_DistinctILCompilerTargetRid Include="@(_UniqueILCompilerTargetRid)"
        Condition="'%(_UniqueILCompilerTargetRid.Identity)' != '%(_ILCompilerHostRid.Identity)'" />
    </ItemGroup>

    <!-- Create target ILCompiler packs for cross-compilation scenarios -->
    <ItemGroup Condition="'@(_DistinctILCompilerTargetRid)' != ''">
      <TargetILCompilerPack Include="@(_ApplicableILCompilerPack->'%(ILCompilerPackNamePattern)'.Replace('**RID**', '%(_DistinctILCompilerTargetRid.Identity)'))">
        <NuGetPackageId>%(TargetILCompilerPack.Identity)</NuGetPackageId>
        <NuGetPackageVersion>%(_ApplicableILCompilerPack.ILCompilerPackVersion)</NuGetPackageVersion>
        <RuntimeIdentifier>%(_DistinctILCompilerTargetRid.Identity)</RuntimeIdentifier>
      </TargetILCompilerPack>
    </ItemGroup>

    <!-- Add to download list if needed -->
    <ItemGroup Condition="'$(EnableRuntimePackDownload)' == 'true'">
      <_PackageToDownload Include="@(HostILCompilerPack);@(TargetILCompilerPack)"
        Condition="!Exists('$(NetCoreTargetingPackRoot)\%(NuGetPackageId)\%(NuGetPackageVersion)')">
        <Version>%(NuGetPackageVersion)</Version>
      </_PackageToDownload>
    </ItemGroup>
  </Target>

  <!--
    Resolve ILLink pack for trimming support.
    -->
  <Target Name="_ResolveILLinkPack"
          DependsOnTargets="_FilterApplicableFrameworkReferences"
          Condition="'$(_RequiresILLinkPack)' == 'true'">

    <!-- Filter ILLink packs by TFM (parse TargetFramework) -->
    <ItemGroup>
      <_KnownILLinkPackMatchingTFI Include="@(KnownILLinkPack)"
        Condition="$([MSBuild]::GetTargetFrameworkIdentifier('%(KnownILLinkPack.TargetFramework)')) == '$(TargetFrameworkIdentifier)'" />

      <_ApplicableILLinkPack Include="@(_KnownILLinkPackMatchingTFI)"
        Condition="$([MSBuild]::VersionEquals($([MSBuild]::GetTargetFrameworkVersion('%(_KnownILLinkPackMatchingTFI.TargetFramework)', 2)), '$(_TargetFrameworkVersionWithoutV)'))" />
    </ItemGroup>

    <!-- Add ILLink pack as implicit package reference -->
    <ItemGroup Condition="'@(_ApplicableILLinkPack)' != '' AND '$(EnableRuntimePackDownload)' == 'true'">
      <_ImplicitPackageReference Include="@(_ApplicableILLinkPack)">
        <Version>%(ILLinkPackVersion)</Version>
      </_ImplicitPackageReference>
    </ItemGroup>
  </Target>

  <!--
    Resolve WebAssembly SDK pack.
    -->
  <Target Name="_ResolveWebAssemblySdkPack"
          DependsOnTargets="_FilterApplicableFrameworkReferences"
          Condition="'$(UsingMicrosoftNETSdkWebAssembly)' == 'true'">

    <!-- Filter WebAssembly SDK packs by TFM (parse TargetFramework) -->
    <ItemGroup>
      <_KnownWebAssemblySdkPackMatchingTFI Include="@(KnownWebAssemblySdkPack)"
        Condition="$([MSBuild]::GetTargetFrameworkIdentifier('%(KnownWebAssemblySdkPack.TargetFramework)')) == '$(TargetFrameworkIdentifier)'" />

      <_ApplicableWebAssemblySdkPack Include="@(_KnownWebAssemblySdkPackMatchingTFI)"
        Condition="$([MSBuild]::VersionEquals($([MSBuild]::GetTargetFrameworkVersion('%(_KnownWebAssemblySdkPackMatchingTFI.TargetFramework)', 2)), '$(_TargetFrameworkVersionWithoutV)'))" />
    </ItemGroup>

    <!-- Add as package download -->
    <ItemGroup Condition="'@(_ApplicableWebAssemblySdkPack)' != '' AND '$(EnableRuntimePackDownload)' == 'true'">
      <_PackageToDownload Include="@(_ApplicableWebAssemblySdkPack)">
        <Version>%(WebAssemblySdkPackVersion)</Version>
      </_PackageToDownload>
    </ItemGroup>
  </Target>

  <!--
    Resolve ASP.NET Core pack for .NET 10+ projects requiring web assets.
    -->
  <Target Name="_ResolveAspNetCorePack"
          DependsOnTargets="_FilterApplicableFrameworkReferences"
          Condition="'$(RequiresAspNetWebAssets)' == 'true' AND $([MSBuild]::VersionGreaterThanOrEquals('$(_TargetFrameworkVersionWithoutV)', '10.0'))">

    <!-- Filter ASP.NET Core packs by TFM (parse TargetFramework) -->
    <ItemGroup>
      <_KnownAspNetCorePackMatchingTFI Include="@(KnownAspNetCorePack)"
        Condition="$([MSBuild]::GetTargetFrameworkIdentifier('%(KnownAspNetCorePack.TargetFramework)')) == '$(TargetFrameworkIdentifier)'" />

      <_ApplicableAspNetCorePack Include="@(_KnownAspNetCorePackMatchingTFI)"
        Condition="$([MSBuild]::VersionEquals($([MSBuild]::GetTargetFrameworkVersion('%(_KnownAspNetCorePackMatchingTFI.TargetFramework)', 2)), '$(_TargetFrameworkVersionWithoutV)'))" />
    </ItemGroup>

    <!-- Add as package download -->
    <ItemGroup Condition="'@(_ApplicableAspNetCorePack)' != '' AND '$(EnableRuntimePackDownload)' == 'true'">
      <_PackageToDownload Include="@(_ApplicableAspNetCorePack)">
        <Version>%(_ApplicableAspNetCorePack.AspNetCorePackVersion)</Version>
      </_PackageToDownload>
    </ItemGroup>
  </Target>

  <!--
    Create RuntimeFramework items for runtimeconfig.json.
    -->
  <Target Name="_CreateRuntimeFrameworkItems"
          DependsOnTargets="_SelectRuntimePacksByLabels">
    <ItemGroup>
      <!-- Only create RuntimeFramework items for frameworks that aren't always copy-local -->
      <RuntimeFramework Include="@(_JoinedFrameworkReference)"
        Condition="'%(_JoinedFrameworkReference.RuntimePackAlwaysCopyLocal)' != 'true' AND
                   '%(_JoinedFrameworkReference.RuntimeFrameworkName)' != ''">
        <Version>%(_JoinedFrameworkReference.RuntimeFrameworkVersion)</Version>
        <FrameworkName>%(_JoinedFrameworkReference.Identity)</FrameworkName>
        <Profile>%(_JoinedFrameworkReference.Profile)</Profile>
      </RuntimeFramework>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    ProcessFrameworkReferences

    Matches FrameworkReference items with KnownFrameworkReference items to determine the corresponding
    targeting pack and if necessary the runtime pack.  If the packs aren't available in the NetCoreTargetingPackRoot
    folder, then generate PackageDownload items in order to download the packs during restore.

    Also resolves app host packs in a similar fashion, and checks for duplicate FrameworkReference items.

    Set UseRefactoredFrameworkReferenceResolution=false to use the original monolithic task implementation.
    ============================================================
    -->

  <Target Name="_ProcessFrameworkReferencesComputeProperties">
    <CheckForDuplicateFrameworkReferences
        FrameworkReferences="@(FrameworkReference)"
        MoreInformationLink="https://aka.ms/sdkimplicitrefs">
      <Output TaskParameter="ItemsToRemove" ItemName="_FrameworkReferenceToRemove" />
      <Output TaskParameter="ItemsToAdd" ItemName="_FrameworkReferenceToAdd" />
    </CheckForDuplicateFrameworkReferences>

    <ItemGroup>
      <FrameworkReference Remove="@(_FrameworkReferenceToRemove)" />
      <FrameworkReference Include="@(_FrameworkReferenceToAdd)" />
    </ItemGroup>

    <PropertyGroup>
      <EnableTargetingPackDownload Condition="'$(EnableTargetingPackDownload)' == ''">true</EnableTargetingPackDownload>
      <EnableRuntimePackDownload Condition="'$(EnableRuntimePackDownload)' == ''">true</EnableRuntimePackDownload>
      <RequiresAspNetWebAssets Condition="'$(RequiresAspNetWebAssets)' == ''">false</RequiresAspNetWebAssets>
    </PropertyGroup>

    <PropertyGroup>
      <_NuGetRestoreSupported Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')">false</_NuGetRestoreSupported>
    </PropertyGroup>

    <ItemGroup>
      <_PackAsToolShimRuntimeIdentifiers Condition="@(_PackAsToolShimRuntimeIdentifiers) ==''" Include="$(PackAsToolShimRuntimeIdentifiers)"/>
    </ItemGroup>
  </Target>

  <!--
    Refactored implementation that calls sub-targets.
    -->
  <Target Name="_ProcessFrameworkReferencesRefactored"
          Condition="'$(UseRefactoredFrameworkReferenceResolution)' != 'false'"
          DependsOnTargets="_ValidateWindowsOnlyFrameworks;
                           _CreateTargetingPackItems;
                           _ResolveRuntimePacksForAdditionalRIDs;
                           _ResolveCrossgen2Packs;
                           _ResolveILCompilerPacks;
                           _ResolveILLinkPack;
                           _ResolveWebAssemblySdkPack;
                           _ResolveAspNetCorePack;
                           _CreateRuntimeFrameworkItems">
    <!-- All work done in dependencies -->
  </Target>

  <!--
    Original monolithic task implementation (fallback).
    -->
  <Target Name="_ProcessFrameworkReferencesOriginal" Condition="'$(UseRefactoredFrameworkReferenceResolution)' == 'false'" >
    <ProcessFrameworkReferences FrameworkReferences="@(FrameworkReference)"
                                KnownFrameworkReferences="@(KnownFrameworkReference)"
                                KnownRuntimePacks="@(KnownRuntimePack)"
                                TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
                                TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)"
                                TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                                TargetPlatformVersion="$(TargetPlatformVersion)"
                                TargetingPackRoot="$(NetCoreTargetingPackRoot)"
                                RuntimeGraphPath="$(RuntimeIdentifierGraphPath)"
                                SelfContained="$(SelfContained)"
                                ReadyToRunEnabled="$(PublishReadyToRun)"
                                ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)"
                                PublishAot="$(PublishAot)"
                                RequiresILLinkPack="$(_RequiresILLinkPack)"
                                IsAotCompatible="$(IsAotCompatible)"
                                SilenceIsAotCompatibleUnsupportedWarning="$(_SilenceIsAotCompatibleUnsupportedWarning)"
                                MinNonEolTargetFrameworkForAot="$(_MinNonEolTargetFrameworkForAot)"
                                EnableAotAnalyzer="$(EnableAotAnalyzer)"
                                FirstTargetFrameworkVersionToSupportAotAnalyzer="$(_FirstTargetFrameworkVersionToSupportAotAnalyzer)"
                                PublishTrimmed="$(PublishTrimmed)"
                                IsTrimmable="$(IsTrimmable)"
                                FirstTargetFrameworkVersionToSupportTrimAnalyzer="$(_FirstTargetFrameworkVersionToSupportTrimAnalyzer)"
                                SilenceIsTrimmableUnsupportedWarning="$(_SilenceIsTrimmableUnsupportedWarning)"
                                MinNonEolTargetFrameworkForTrimming="$(_MinNonEolTargetFrameworkForTrimming)"
                                EnableTrimAnalyzer="$(EnableTrimAnalyzer)"
                                EnableSingleFileAnalyzer="$(EnableSingleFileAnalyzer)"
                                FirstTargetFrameworkVersionToSupportSingleFileAnalyzer="$(_FirstTargetFrameworkVersionToSupportSingleFileAnalyzer)"
                                SilenceEnableSingleFileAnalyzerUnsupportedWarning="$(_SilenceEnableSingleFileAnalyzerUnsupportedWarning)"
                                MinNonEolTargetFrameworkForSingleFile="$(_MinNonEolTargetFrameworkForSingleFile)"
                                AotUseKnownRuntimePackForTarget="$(PublishAotUsingRuntimePack)"
                                RuntimeIdentifier="$(RuntimeIdentifier)"
                                RuntimeIdentifiers="$(RuntimeIdentifiers)"
                                RuntimeFrameworkVersion="$(RuntimeFrameworkVersion)"
                                TargetLatestRuntimePatch="$(TargetLatestRuntimePatch)"
                                TargetLatestRuntimePatchIsDefault="$(_TargetLatestRuntimePatchIsDefault)"
                                EnableTargetingPackDownload="$(EnableTargetingPackDownload)"
                                EnableRuntimePackDownload="$(EnableRuntimePackDownload)"
                                EnableWindowsTargeting="$(EnableWindowsTargeting)"
                                DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)"
                                KnownCrossgen2Packs="@(KnownCrossgen2Pack)"
                                KnownILCompilerPacks="@(KnownILCompilerPack)"
                                KnownILLinkPacks="@(KnownILLinkPack)"
                                KnownWebAssemblySdkPacks="@(KnownWebAssemblySdkPack)"
                                KnownAspNetCorePacks="@(KnownAspNetCorePack)"
                                UsingMicrosoftNETSdkWebAssembly="$(UsingMicrosoftNETSdkWebAssembly)"
                                RequiresAspNetWebAssets="$(RequiresAspNetWebAssets)"
                                NETCoreSdkRuntimeIdentifier="$(NETCoreSdkRuntimeIdentifier)"
                                NETCoreSdkPortableRuntimeIdentifier="$(NETCoreSdkPortableRuntimeIdentifier)"
                                NetCoreRoot="$(NetCoreRoot)"
                                NETCoreSdkVersion="$(NETCoreSdkVersion)">

      <Output TaskParameter="PackagesToDownload" ItemName="_PackageToDownload" />
      <Output TaskParameter="RuntimeFrameworks" ItemName="RuntimeFramework" />
      <Output TaskParameter="TargetingPacks" ItemName="TargetingPack" />
      <Output TaskParameter="RuntimePacks" ItemName="RuntimePack" />
      <Output TaskParameter="Crossgen2Packs" ItemName="Crossgen2Pack" />
      <Output TaskParameter="HostILCompilerPacks" ItemName="HostILCompilerPack" />
      <Output TaskParameter="TargetILCompilerPacks" ItemName="TargetILCompilerPack" />
      <Output TaskParameter="UnavailableRuntimePacks" ItemName="UnavailableRuntimePack" />
      <Output TaskParameter="ImplicitPackageReferences" ItemName="_ImplicitPackageReference" />
      <Output TaskParameter="KnownRuntimeIdentifierPlatforms" ItemName="_KnownRuntimeIdentifierPlatformsForTargetFramework" />

    </ProcessFrameworkReferences>
  </Target>

  <Target Name="_ResolveAppHosts">
    <PropertyGroup Condition="'$(AppHostRuntimeIdentifier)' == '' And
                              ('$(UseAppHost)' == 'true' Or '$(EnableComHosting)' == 'true' Or '$(UseIJWHost)' == 'true')">
      <AppHostRuntimeIdentifier>$(RuntimeIdentifier)</AppHostRuntimeIdentifier>
      <AppHostRuntimeIdentifier Condition="'$(AppHostRuntimeIdentifier)' == ''">$(DefaultAppHostRuntimeIdentifier)</AppHostRuntimeIdentifier>
    </PropertyGroup>

    <ResolveAppHosts TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
                     TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)"
                     TargetingPackRoot="$(NetCoreTargetingPackRoot)"
                     AppHostRuntimeIdentifier="$(AppHostRuntimeIdentifier)"
                     OtherRuntimeIdentifiers="$(RuntimeIdentifiers)"
                     RuntimeFrameworkVersion="$(RuntimeFrameworkVersion)"
                     PackAsToolShimRuntimeIdentifiers="@(_PackAsToolShimRuntimeIdentifiers)"
                     DotNetAppHostExecutableNameWithoutExtension="$(_DotNetAppHostExecutableNameWithoutExtension)"
                     DotNetSingleFileHostExecutableNameWithoutExtension="$(_DotNetSingleFileHostExecutableNameWithoutExtension)"
                     DotNetComHostLibraryNameWithoutExtension="$(_DotNetComHostLibraryNameWithoutExtension)"
                     DotNetIjwHostLibraryNameWithoutExtension="$(_DotNetIjwHostLibraryNameWithoutExtension)"
                     RuntimeGraphPath="$(RuntimeIdentifierGraphPath)"
                     KnownAppHostPacks="@(KnownAppHostPack)"
                     NuGetRestoreSupported="$(_NuGetRestoreSupported)"
                     EnableAppHostPackDownload="$(EnableAppHostPackDownload)"
                     NetCoreTargetingPackRoot="$(NetCoreTargetingPackRoot)">

      <Output TaskParameter="PackagesToDownload" ItemName="_PackageToDownload" />
      <Output TaskParameter="AppHost" ItemName="AppHostPack" />
      <Output TaskParameter="SingleFileHost" ItemName="SingleFileHostPack" />
      <Output TaskParameter="ComHost" ItemName="ComHostPack" />
      <Output TaskParameter="IjwHost" ItemName="IjwHostPack" />
      <Output TaskParameter="PackAsToolShimAppHostPacks" ItemName="PackAsToolShimAppHostPack" />
    </ResolveAppHosts>
  </Target>

  <Target Name="ProcessFrameworkReferences"
          BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences;CollectPackageDownloads"
          DependsOnTargets="AddWindowsSdkKnownFrameworkReferences;_ProcessFrameworkReferencesComputeProperties;_ProcessFrameworkReferencesRefactored;_ProcessFrameworkReferencesOriginal;_ResolveAppHosts;"
          Condition="'@(FrameworkReference)' != '' Or '$(_RequiresILLinkPack)' == 'true'">

    <PropertyGroup Condition="'$(UsePackageDownload)' == ''">
      <UsePackageDownload Condition="'$(MSBuildRuntimeType)' == 'Core'">true</UsePackageDownload>
      <UsePackageDownload Condition="'$(PackageDownloadSupported)' == 'true'">true</UsePackageDownload>
      <UsePackageDownload Condition="'$(UsePackageDownload)' == ''">false</UsePackageDownload>
    </PropertyGroup>

    <ItemGroup Condition="'$(UsePackageDownload)' == 'true'">
      <PackageDownload Include="@(_PackageToDownload)">
        <Version>[%(_PackageToDownload.Version)]</Version>
      </PackageDownload>
    </ItemGroup>

    <ItemGroup Condition="'$(UsePackageDownload)' != 'true'">
      <PackageReference Include="@(_PackageToDownload)"
                        IsImplicitlyDefined="true"
                        PrivateAssets="all"
                        ExcludeAssets="all" />
    </ItemGroup>

    <!-- Add implicit package references that don't already exist in PackageReference. -->
    <ItemGroup>
      <_ImplicitPackageReference Remove="@(PackageReference)" />
      <PackageReference Include="@(_ImplicitPackageReference)"
                        IsImplicitlyDefined="true"
                        PrivateAssets="all" />
    </ItemGroup>
  </Target>

  <!--
    ============================================================
                                        AddTransitiveFrameworkReferences

    Adds FrameworkReference items for shared frameworks which weren't directly referenced,
    but were referenced transitively via a project or package reference.  NuGet writes these
    to the assets file, and the ResolvePackageAssets target adds them to the TransitiveFrameworkReference
    item.  Here, we add them to FrameworkReference if they aren't already referenced.
    We add a transitive attribute to the FrameworkReferences so NuGet can filter them out from CollectFrameworkReferences.
    ============================================================
    -->
  <Target Name="AddTransitiveFrameworkReferences" AfterTargets="ResolvePackageAssets"
          Condition="'@(TransitiveFrameworkReference)' != ''" >

    <ItemGroup>
      <FrameworkReference Include="@(TransitiveFrameworkReference)" Exclude="@(FrameworkReference)"
                          IsTransitiveFrameworkReference="true" />
    </ItemGroup>

  </Target>

  <UsingTask TaskName="ResolveFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />

  <!--
    ============================================================
                                        ResolveFrameworkReferences

    Resolves paths to various FrameworkReference-related items (targeting packs, runtime packs,
    app host packs).  Some of these may already have had the path set if they were in the
    NetCoreTargetingPackRoot folder.  Others which were downloaded as NuGet packages will
    need to have the path set here.
    ============================================================
    -->
  <Target Name="ResolveFrameworkReferences" DependsOnTargets="ProcessFrameworkReferences;ResolvePackageAssets"
          Condition="'@(FrameworkReference)' != ''"
          Returns="@(ResolvedFrameworkReference)">

    <GetPackageDirectory
      Items="@(TargetingPack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedTargetingPack" />

    </GetPackageDirectory>

    <ItemGroup>
      <ResolvedTargetingPack Condition="'%(ResolvedTargetingPack.Path)' == '' and '%(ResolvedTargetingPack.PackageDirectory)' != ''">
        <Path>%(ResolvedTargetingPack.PackageDirectory)</Path>
      </ResolvedTargetingPack>
    </ItemGroup>

    <GetPackageDirectory
      Items="@(AppHostPack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedAppHostPack" />

    </GetPackageDirectory>

    <GetPackageDirectory
      Items="@(SingleFileHostPack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedSingleFileHostPack" />

    </GetPackageDirectory>

    <GetPackageDirectory
      Items="@(Crossgen2Pack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedCrossgen2Pack" />

    </GetPackageDirectory>

    <GetPackageDirectory
      Items="@(HostILCompilerPack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedILCompilerPack" />
    </GetPackageDirectory>

    <GetPackageDirectory
      Items="@(TargetILCompilerPack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedTargetILCompilerPack" />
    </GetPackageDirectory>

    <GetPackageDirectory
      Items="@(PackAsToolShimAppHostPack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="_ApphostsForShimRuntimeIdentifiersGetPackageDirectory" />

    </GetPackageDirectory>

    <GetPackageDirectory
      Items="@(ComHostPack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedComHostPack" />

    </GetPackageDirectory>

    <GetPackageDirectory
     Items="@(IjwHostPack)"
     PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedIjwHostPack" />
    </GetPackageDirectory>

    <ItemGroup>
      <_ApphostsForShimRuntimeIdentifiers Include="%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.PackageDirectory)\%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.PathInPackage)" >
        <RuntimeIdentifier>%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.RuntimeIdentifier)</RuntimeIdentifier>
      </_ApphostsForShimRuntimeIdentifiers>
    </ItemGroup>

    <ItemGroup>
      <ResolvedAppHostPack Condition="'%(ResolvedAppHostPack.Path)' == '' and '%(ResolvedAppHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedAppHostPack.PackageDirectory)\%(ResolvedAppHostPack.PathInPackage)</Path>
      </ResolvedAppHostPack>
    </ItemGroup>

    <PropertyGroup Condition="'@(ResolvedAppHostPack)' != '' And '$(AppHostSourcePath)' == ''">
      <AppHostSourcePath>@(ResolvedAppHostPack->'%(Path)')</AppHostSourcePath>
    </PropertyGroup>

    <ItemGroup>
      <ResolvedSingleFileHostPack Condition="'%(ResolvedSingleFileHostPack.Path)' == '' and '%(ResolvedSingleFileHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedSingleFileHostPack.PackageDirectory)\%(ResolvedSingleFileHostPack.PathInPackage)</Path>
      </ResolvedSingleFileHostPack>
    </ItemGroup>

    <PropertyGroup Condition="'@(ResolvedSingleFileHostPack)' != '' And '$(SingleFileHostSourcePath)' == ''">
      <SingleFileHostSourcePath>@(ResolvedSingleFileHostPack->'%(Path)')</SingleFileHostSourcePath>
    </PropertyGroup>

    <ItemGroup>
      <ResolvedComHostPack Condition="'%(ResolvedComHostPack.Path)' == '' and '%(ResolvedComHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedComHostPack.PackageDirectory)\%(ResolvedComHostPack.PathInPackage)</Path>
      </ResolvedComHostPack>
    </ItemGroup>

    <PropertyGroup Condition="'@(ResolvedComHostPack)' != '' And '$(ComHostSourcePath)' == ''">
      <ComHostSourcePath>@(ResolvedComHostPack->'%(Path)')</ComHostSourcePath>
    </PropertyGroup>

    <ItemGroup>
      <ResolvedIjwHostPack Condition="'%(ResolvedIjwHostPack.Path)' == '' and '%(ResolvedIjwHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedIjwHostPack.PackageDirectory)\%(ResolvedIjwHostPack.PathInPackage)</Path>
      </ResolvedIjwHostPack>
    </ItemGroup>

    <PropertyGroup Condition="'@(ResolvedIjwHostPack)' != '' And '$(IjwHostSourcePath)' == ''">
      <IjwHostSourcePath>@(ResolvedIjwHostPack->'%(Path)')</IjwHostSourcePath>
    </PropertyGroup>

    <GetPackageDirectory
      Items="@(RuntimePack)"
      PackageFolders="@(AssetsFilePackageFolder)">

      <Output TaskParameter="Output" ItemName="ResolvedRuntimePack" />

    </GetPackageDirectory>

    <ResolveFrameworkReferences
      FrameworkReferences="@(FrameworkReference)"
      ResolvedTargetingPacks="@(ResolvedTargetingPack)"
      ResolvedRuntimePacks="@(ResolvedRuntimePack)">

      <Output TaskParameter="ResolvedFrameworkReferences" ItemName="ResolvedFrameworkReference" />

    </ResolveFrameworkReferences>

  </Target>

  <UsingTask TaskName="GetPackageDirectory" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveTargetingPackAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />

  <!--
    ============================================================
                                        ResolveTargetingPackAssets

    Resolve assets (primarily references) from targeting packs.
    ============================================================
    -->
  <Target Name="ResolveTargetingPackAssets" DependsOnTargets="ResolveFrameworkReferences"
          Condition="'@(FrameworkReference)' != ''">

    <!-- For design-time builds, don't generate an error if a targeting pack isn't available (ie because it hasn't been restored yet) -->
    <PropertyGroup Condition="'$(GenerateErrorForMissingTargetingPacks)' == ''">
      <GenerateErrorForMissingTargetingPacks>true</GenerateErrorForMissingTargetingPacks>
      <GenerateErrorForMissingTargetingPacks Condition="'$(DesignTimeBuild)' == 'true'">false</GenerateErrorForMissingTargetingPacks>
    </PropertyGroup>

    <ResolveTargetingPackAssets FrameworkReferences="@(FrameworkReference)"
                                ProjectLanguage="$(Language)"
                                ResolvedTargetingPacks="@(ResolvedTargetingPack)"
                                RuntimeFrameworks="@(RuntimeFramework)"
                                GenerateErrorForMissingTargetingPacks="$(GenerateErrorForMissingTargetingPacks)"
                                NuGetRestoreSupported="$(_NuGetRestoreSupported)"
                                DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)"
                                NetCoreTargetingPackRoot="$(NetCoreTargetingPackRoot)">
      <Output TaskParameter="ReferencesToAdd" ItemName="Reference" />
      <Output TaskParameter="AnalyzersToAdd" ItemName="Analyzer" />
      <Output TaskParameter="PlatformManifests" ItemName="PlatformManifestsFromTargetingPacks" />
      <Output TaskParameter="PackageConflictPreferredPackages" PropertyName="PackageConflictPreferredPackages" />
      <Output TaskParameter="PackageConflictOverrides" ItemName="PackageConflictOverrides" />
      <Output TaskParameter="UsedRuntimeFrameworks" ItemName="_UsedRuntimeFramework" />

    </ResolveTargetingPackAssets>

    <PropertyGroup>
      <!-- Unescape this semicolon-delimited ordered list so that it's passed as a list to targets
           that consume it. -->
      <PackageConflictPreferredPackages>$([MSBuild]::Unescape($(PackageConflictPreferredPackages)))</PackageConflictPreferredPackages>
    </PropertyGroup>

    <ItemGroup Condition="'$(RuntimeIdentifier)' == '' or '$(SelfContained)' != 'true'">
      <PackageConflictPlatformManifests Include="@(PlatformManifestsFromTargetingPacks)" />
    </ItemGroup>

    <ItemGroup>
      <RuntimeFramework Remove="@(RuntimeFramework)" />
      <RuntimeFramework Include="@(_UsedRuntimeFramework)" />
    </ItemGroup>
  </Target>

  <!-- Default "off by default analyzer" settings for trimmed apps. -->
  <PropertyGroup Condition="'$(PublishTrimmed)' == 'true' Or '$(PublishAot)' == 'true'">
    <!-- Enable the built-in source generators. -->
    <EnableRequestDelegateGenerator Condition="'$(EnableRequestDelegateGenerator)' == ''">true</EnableRequestDelegateGenerator>
    <EnableConfigurationBindingGenerator Condition="'$(EnableConfigurationBindingGenerator)' == ''">true</EnableConfigurationBindingGenerator>
  </PropertyGroup>

  <PropertyGroup>
    <!-- Set the namespaces emitted by the RequestDelegateGenerator for interception when applicable. -->
    <InterceptorsPreviewNamespaces Condition="'$(EnableRequestDelegateGenerator)' == 'true'">$(InterceptorsPreviewNamespaces);Microsoft.AspNetCore.Http.Generated</InterceptorsPreviewNamespaces>
    <!-- Set the namespaces emitted by the ConfigurationBindingGenerator for interception when applicable. -->
    <InterceptorsPreviewNamespaces Condition="'$(EnableConfigurationBindingGenerator)' == 'true'">$(InterceptorsPreviewNamespaces);Microsoft.Extensions.Configuration.Binder.SourceGeneration</InterceptorsPreviewNamespaces>
    <!-- Set the namespaces emitted by the ValidationsGenerator for interception when applicable (.NET 10 and above). -->
    <InterceptorsPreviewNamespaces Condition="'$(_TargetFrameworkVersionWithoutV)' != '' and $([MSBuild]::VersionGreaterThanOrEquals('$(_TargetFrameworkVersionWithoutV)', '10.0'))">$(InterceptorsPreviewNamespaces);Microsoft.Extensions.Validation.Generated</InterceptorsPreviewNamespaces>
  </PropertyGroup>

  <Target Name="ResolveOffByDefaultAnalyzers" AfterTargets="ResolveTargetingPackAssets"
          Condition="'@(FrameworkReference)' != ''">

    <ItemGroup>
      <OffByDefaultAnalyzer Include="Microsoft.AspNetCore.Http.RequestDelegateGenerator.dll"
                            IsEnabled="$(EnableRequestDelegateGenerator)"/>
      <OffByDefaultAnalyzer Include="Microsoft.Extensions.Configuration.Binder.SourceGeneration.dll"
                            IsEnabled="$(EnableConfigurationBindingGenerator)"/>
    </ItemGroup>

    <ItemGroup>
      <Analyzer Remove="@(OffByDefaultAnalyzer)"
                Condition="'%(OffByDefaultAnalyzer.IsEnabled)' != 'true'"
                MatchOnMetadata="FileName" />
    </ItemGroup>
  </Target>

  <UsingTask TaskName="ResolveRuntimePackAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />

  <!--
    ============================================================
                                        IncludeTargetingPackReference

    Add package reference for required targeting pack if necessary
    ============================================================
    -->
  <Target Name="IncludeTargetingPackReference" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences;CheckForImplicitPackageReferenceOverrides"
          Condition="'$(TargetFrameworkMoniker)' != '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(AutomaticallyUseReferenceAssemblyPackages)' == 'true'">
    <GetReferenceAssemblyPaths
        TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
        RootPath="$(TargetFrameworkRootPath)"
        TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)"
        BypassFrameworkInstallChecks="true"
        SuppressNotFoundError="true">
      <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths"/>
    </GetReferenceAssemblyPaths>

    <ItemGroup>
      <_ExistingReferenceAssembliesPackageReference Include="@(PackageReference)" Condition="'%(PackageReference.Identity)' == 'Microsoft.NETFramework.ReferenceAssemblies'"/>

      <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="$(MicrosoftNETFrameworkReferenceAssembliesLatestPackageVersion)" IsImplicitlyDefined="true" PrivateAssets="All"
                        Condition="('$(_FullFrameworkReferenceAssemblyPaths)' == '' or $(_FullFrameworkReferenceAssemblyPaths.Contains('microsoft.netframework.referenceassemblies'))) and '@(_ExistingReferenceAssembliesPackageReference)' == ''"/>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
                                        ResolveRuntimePackAssets

    Resolve assets from runtime packs.
    ============================================================
    -->
  <Target Name="ResolveRuntimePackAssets" DependsOnTargets="ResolveFrameworkReferences"
          Condition="'@(RuntimePack)' != ''">

    <ResolveRuntimePackAssets FrameworkReferences="@(FrameworkReference)"
                              RuntimeFrameworks="@(RuntimeFramework)"
                              ResolvedRuntimePacks="@(ResolvedRuntimePack)"
                              UnavailableRuntimePacks="@(UnavailableRuntimePack)"
                              SatelliteResourceLanguages="$(SatelliteResourceLanguages)"
                              DesignTimeBuild="$(DesignTimeBuild)"
                              DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)">
      <Output TaskParameter="RuntimePackAssets" ItemName="RuntimePackAsset" />
    </ResolveRuntimePackAssets>

    <ItemGroup>
      <ReferenceCopyLocalPaths Include="@(RuntimePackAsset)"
                               Condition="'$(CopyLocalLockFileAssemblies)' == 'true' and ('$(SelfContained)' == 'true' or '%(RuntimePackAsset.RuntimePackAlwaysCopyLocal)' == 'true') and '%(RuntimePackAsset.AssetType)' != 'pgodata'" />
    </ItemGroup>


  </Target>

  <!--
    Adds metadata so the SDK will generate the UserSecretsIdAttribute.

    This is associated with ASP.NET Core, but may be used in projects that don't use the Web SDK (especially test projects).
    So it is in the base .NET SDK.  (It used to be in the Microsoft.AspNetCore.App package, but now that that's a targeting
    pack we don't support importing build logic from it directly).

    If GeneratedUserSecretsAttributeFile is set, that means Microsoft.Extensions.Configuration.UserSecrets 2.1
    or earlier was referenced as a package. This didn't use the AssemblyAttribute item group, so we cannot
    avoid duplicate AssemblyAttribute items without skipping this target altogether..
  -->
  <Target Name="_GetUserSecretsAssemblyAttribute"
          BeforeTargets="GetAssemblyAttributes"
          Condition=" '$(UserSecretsId)' != '' AND '$(GenerateUserSecretsAttribute)' != 'false' AND '$(GeneratedUserSecretsAttributeFile)' == '' ">

    <!--
      If the Microsoft.Extensions.Configuration.UserSecrets package 2.2 or higher is referenced directly,
      it will also add an AssemblyAttribute item. Since this attribute only allows one per assembly, do not
      duplicate the item.

      Also don't add the attribute if there is neither a Microsoft.AspNetCore.App FrameworkReference nor a
      Microsoft.Extensions.Configuration.UserSecrets PackageReference, in order to preserve 2.x SDK behavior
      where projects would successfully build if they define the UserSecretsId property but don't reference
      the corresponding API.

    -->
     <ItemGroup Condition=" @(AssemblyAttribute->WithMetadataValue('Identity', 'Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute')->Count()) == 0 And
                            (@(FrameworkReference->WithMetadataValue('Identity', 'Microsoft.AspNetCore.App')->Count()) != 0 Or
                            @(PackageReference->WithMetadataValue('Identity', 'Microsoft.Extensions.Configuration.UserSecrets')->Count()) != 0)">
      <AssemblyAttribute Include="Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute">
        <_Parameter1>$(UserSecretsId.Trim())</_Parameter1>
      </AssemblyAttribute>
    </ItemGroup>
  </Target>

</Project>
