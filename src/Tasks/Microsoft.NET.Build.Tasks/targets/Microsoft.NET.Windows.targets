<!--
***********************************************************************************************
Microsoft.NET.Windows.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!--C++/CLI does not support nuget restore which is required for Windows SDK Ref. Also these are C# projections.-->
  <PropertyGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true'
                             and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'
                             and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0'))
                             and '$(TargetPlatformIdentifier)' == 'Windows'
                             and '$(TargetPlatformVersion)' != ''
                             and $([MSBuild]::VersionGreaterThanOrEquals($(TargetPlatformVersion), '10.0'))
                             and '$(Language)' != 'C++'
                             and '$(IncludeWindowsSDKRefFrameworkReferences)' == ''">
    <IncludeWindowsSDKRefFrameworkReferences>true</IncludeWindowsSDKRefFrameworkReferences>
  </PropertyGroup>

  <!-- If UseWindowsSDKPreview is true, then allow any target platform version, not just the ones defined by the SDK -->
  <PropertyGroup Condition="'$(UseWindowsSDKPreview)' == 'true'">
    <TargetPlatformVersionSupported>true</TargetPlatformVersionSupported>
  </PropertyGroup>

  <!-- Set 7.0 as the TargetPlatformVersion for windows. -->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'windows' and '$(TargetPlatformVersion)' == ''" >
    <TargetPlatformVersion>7.0</TargetPlatformVersion>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'Windows'">
    <!-- When targeting Windows, sync the SupportedOSPlatformVersion and TargetPlatformMinVersion.  If either one isn't set, set it to the
         other value. -->
    <SupportedOSPlatformVersion Condition="'$(SupportedOSPlatformVersion)' == ''">$(TargetPlatformMinVersion)</SupportedOSPlatformVersion>
    <TargetPlatformMinVersion Condition="'$(TargetPlatformMinVersion)' == ''">$(SupportedOSPlatformVersion)</TargetPlatformMinVersion>

    <!-- If neither were set, then use the TargetPlatformVersion value for both -->
    <SupportedOSPlatformVersion Condition="'$(SupportedOSPlatformVersion)' == ''">$(TargetPlatformVersion)</SupportedOSPlatformVersion>
    <TargetPlatformMinVersion Condition="'$(TargetPlatformMinVersion)' == ''">$(TargetPlatformVersion)</TargetPlatformMinVersion>
  </PropertyGroup>

  <!-- Used by analyzers in the Microsoft.Windows.SDK.NET.Ref package. -->
  <PropertyGroup Condition="'$(IncludeWindowsSDKRefFrameworkReferences)' == 'true'">
    <CsWinRTAotOptimizerEnabled Condition="'$(CsWinRTAotOptimizerEnabled)' == '' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0'))">true</CsWinRTAotOptimizerEnabled>
    <CsWinRTAotExportsEnabled Condition="'$(CsWinRTAotExportsEnabled)' == '' and '$(CsWinRTAotOptimizerEnabled)' == 'true' and '$(PublishAot)' == 'true'">true</CsWinRTAotExportsEnabled>
    <CsWinRTCcwLookupTableGeneratorEnabled Condition="'$(CsWinRTCcwLookupTableGeneratorEnabled)' == '' and '$(CsWinRTGenerateProjection)' != 'true'">true</CsWinRTCcwLookupTableGeneratorEnabled>
    <CsWinRTAotWarningLevel Condition="'$(CsWinRTAotWarningLevel)' == '' and '$(CsWinRTGenerateProjection)' != 'true' and ('$(PublishAot)' == 'true' or '$(IsAotCompatible)' == 'true')">1</CsWinRTAotWarningLevel>
  </PropertyGroup>

  <ItemGroup Condition="'$(IncludeWindowsSDKRefFrameworkReferences)' == 'true'">
    <CompilerVisibleProperty Include="CsWinRTAotOptimizerEnabled" />
    <CompilerVisibleProperty Include="CsWinRTAotExportsEnabled" />
    <CompilerVisibleProperty Include="CsWinRTRcwFactoryFallbackGeneratorForceOptIn" />
    <CompilerVisibleProperty Include="CsWinRTRcwFactoryFallbackGeneratorForceOptOut" />
    <CompilerVisibleProperty Include="CsWinRTCcwLookupTableGeneratorEnabled" />
    <CompilerVisibleProperty Include="CsWinRTMergeReferencedActivationFactories" />
    <CompilerVisibleProperty Include="CsWinRTAotWarningLevel" />
  </ItemGroup>

  <!-- Also add the Windows.UI.Xaml.* projections from the Windows SDK if 'UseUwp' is set in the project.
       Note: we only add this reference if the TFM is .NET 8 or above, as the Windows SDK projections
       that are used on .NET 6 and below do not have the Windows.UI.Xaml profile, so this wouldn't work. -->
  <ItemGroup Condition=" '$(IncludeWindowsSDKRefFrameworkReferences)' == 'true' ">
    <FrameworkReference Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0')) and '$(TargetPlatformIdentifier)' == 'Windows' and '$(UseUwp)' == 'true' " Include="Microsoft.Windows.SDK.NET.Ref.Xaml" />
  </ItemGroup>

  <!-- If WindowsSdkPackageVersion is specified and it is an older version before profile support was added, 
       add the non profile framework reference. -->
  <ItemGroup Condition=" '$(IncludeWindowsSDKRefFrameworkReferences)' == 'true'
                        and '$(WindowsSdkPackageVersion)' != ''
                        and '$(UseUwp)' != 'true'
                        and $([System.Version]::Parse('$(WindowsSdkPackageVersion.Split('-')[0])').Build) &lt;= 26100
                        and $([System.Version]::Parse('$(WindowsSdkPackageVersion.Split('-')[0])').Revision) &lt;= 34">
    <FrameworkReference Include="Microsoft.Windows.SDK.NET.Ref" IsImplicitlyDefined="true" Pack="false" PrivateAssets="All" />
  </ItemGroup>

  <!-- Default 'CsWinRTUseWindowsUIXamlProjections' to 'false', unless 'UseUwp' is set.
       This is to ensure that using the full Windows SDK projections will work correctly.
       We still allow users to override this, which can help in mixed WinAppSDK scenarios. -->
  <PropertyGroup>
    <CsWinRTUseWindowsUIXamlProjections Condition=" '$(CsWinRTUseWindowsUIXamlProjections)' == '' and '$(UseUwp)' == 'true' ">true</CsWinRTUseWindowsUIXamlProjections>
    <CsWinRTUseWindowsUIXamlProjections Condition=" '$(CsWinRTUseWindowsUIXamlProjections)' == '' ">false</CsWinRTUseWindowsUIXamlProjections>
  </PropertyGroup>

  <ItemGroup>

    <!-- Mark 'CsWinRTUseWindowsUIXamlProjections' as compiler visible, so the analyzers bundled in the Windows SDK projections can see it -->
    <CompilerVisibleProperty Include="CsWinRTUseWindowsUIXamlProjections" />
  </ItemGroup>

  <!-- Configure the Windows.UI.Xaml.* projections feature switch for CsWinRT from here. This is
       needed because there's no .targets from CsWinRT that's used when CsWinRT itself is not being
       directly referenced in the project. For instance, in a normal application (not authoring).
       Note: we only do this on 'net8.0-windows' or greater, as it's not supported otherwise.  -->
  <ItemGroup>
    <RuntimeHostConfigurationOption Include="CSWINRT_USE_WINDOWS_UI_XAML_PROJECTIONS"
                                    Value="$(CsWinRTUseWindowsUIXamlProjections)"
                                    Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0')) and '$(TargetPlatformIdentifier)' == 'Windows'"
                                    Trim="true" />
  </ItemGroup>

  <Target Name="_ErrorOnUnresolvedWindowsSDKAssemblyConflict"
          AfterTargets="ResolveAssemblyReferences"
          Condition=" '@(ResolveAssemblyReferenceUnresolvedAssemblyConflicts)' != '' ">
    <ItemGroup>
      <_WindowsSDKUnresolvedRef Include="@(ResolveAssemblyReferenceUnresolvedAssemblyConflicts)" Condition="'%(Identity)' == 'Microsoft.Windows.SDK.NET' " />
    </ItemGroup>

    <NETSdkError ResourceName="WindowsSDKVersionConflicts"
                 Condition="@(_WindowsSDKUnresolvedRef) != ''"/>
  </Target>

  <Target Name="RemoveManagedWinRTComponentWinMDReferences"
          AfterTargets="ResolveProjectReferences">
    
    <ItemGroup>
      <!-- Before we remove them from _ResolvedProjectReferencePaths, grab the implementation .dll's path -->
      <ManagedWinRTComponentImplementations 
        Include="@(_ResolvedProjectReferencePaths->'%(ManagedImplementation)')" 
        Condition="('%(_ResolvedProjectReferencePaths.Extension)' == '.winmd') And ('%(_ResolvedProjectReferencePaths.Implementation)' == 'WinRT.Host.dll')"
      />
    </ItemGroup>

    <!-- Managed WinRT components include both the WinMD and the .NET DLL in the result from GetTargetPath.  Managed projects need to only reference the .NET DLL, not the WinMD.
         The WinMD in this case can be identified because the Implementation metadata value is WinRT.Host.dll.  So here we remove any such WinMD references. -->
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(_ResolvedProjectReferencePaths)"
                                      Condition="('%(_ResolvedProjectReferencePaths.Extension)' == '.winmd') And ('%(_ResolvedProjectReferencePaths.Implementation)' == 'WinRT.Host.dll')"
                                      />
    </ItemGroup>
    
  </Target>

  <Target Name="AddWinRTComponentImplementationReference" AfterTargets="ResolveProjectReferences" DependsOnTargets="RemoveManagedWinRTComponentWinMDReferences" Condition="'@(ManagedWinRTComponentImplementations)' != ''">
    
    <ItemGroup>
      <Reference Include="@(ManagedWinRTComponentImplementations)"/>
    </ItemGroup>

  </Target>

  <!-- Target to emit an error when 'UseUwp' is not set, but the 'Microsoft.Windows.SDK.NET.Ref.Xaml' item is transitively referenced -->
  <Target Name="_CheckForTransitiveWindowsSDKFullDependencies"
          AfterTargets="ResolvePackageAssets"
          Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp'
                      and '$(TargetPlatformIdentifier)' == 'Windows'
                      and '@(TransitiveFrameworkReference)' != ''
                      and '$(UseUwp)' != 'true' ">
    <ItemGroup>
      <_WindowsSDKXamlTransitiveFrameworkReference Include="@(TransitiveFrameworkReference)"
                                                   Condition="'%(Identity)' == 'Microsoft.Windows.SDK.NET.Ref.Xaml'" />
    </ItemGroup>
    <NetSdkError Condition="'@(_WindowsSDKXamlTransitiveFrameworkReference)' != ''"
                 ResourceName="WindowsSDKXamlMissingUseUwpProperty" />
  </Target>

  <!-- Target to emit an error when 'UseUwp' is set, but the TFM is not 'net8.0-windows' or greater -->
  <Target Name="_CheckForInvalidTfmForWindowsSDKXamlDependencies"
          AfterTargets="ResolvePackageAssets"
          Condition=" !('$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0')) and '$(TargetPlatformIdentifier)' == 'Windows')
                      and '$(UseUwp)' == 'true' ">
    <NetSdkError ResourceName="WindowsSDKXamlInvalidTfm" />
  </Target>

  <!-- Setup common properties for '_RunCsWinRTGenerator' below -->
  <PropertyGroup>

    <!--
      Running 'cswinrtgen' is required for CsWinRT 3.0, and it is currently in preview.
      So the switch for it is currently opt-in. It can be changed to opt-out in the future.
      We only enable this automatically if the project is explicitly targeting CsWinRT 3.0.
    -->
    <CsWinRTGenerateInteropAssembly Condition="'$(CsWinRTGenerateInteropAssembly)' == '' and '$(_TargetPlatformVersionUsesCsWinRT3)' == 'true'">true</CsWinRTGenerateInteropAssembly>
    <CsWinRTGenerateInteropAssembly Condition="'$(CsWinRTGenerateInteropAssembly)' == ''">false</CsWinRTGenerateInteropAssembly>

    <!--
      Default property values for 'cswinrtgen'. Not setting 'CsWinRTToolsDirectory' and
      'CsWinRTToolsArchitecture' because the task can handle their default values on its
      own, and it will use that to automatically set the right directory and architecture.
    -->
    <CsWinRTGeneratorInteropAssemblyDirectory Condition="'$(CsWinRTGeneratorInteropAssemblyDirectory)' == ''">$(IntermediateOutputPath)</CsWinRTGeneratorInteropAssemblyDirectory>
    <CsWinRTGeneratorValidateWinRTRuntimeAssemblyVersion Condition="'$(CsWinRTGeneratorValidateWinRTRuntimeAssemblyVersion)' == ''">true</CsWinRTGeneratorValidateWinRTRuntimeAssemblyVersion>
    <CsWinRTGeneratorValidateWinRTRuntimeDllVersion2References Condition="'$(CsWinRTGeneratorValidateWinRTRuntimeDllVersion2References)' == ''">true</CsWinRTGeneratorValidateWinRTRuntimeDllVersion2References>
    <CsWinRTGeneratorEnableIncrementalGeneration Condition="'$(CsWinRTGeneratorEnableIncrementalGeneration)' == ''">true</CsWinRTGeneratorEnableIncrementalGeneration>
    <CsWinRTGeneratorTreatWarningsAsErrors Condition="'$(CsWinRTGeneratorTreatWarningsAsErrors)' == ''">false</CsWinRTGeneratorTreatWarningsAsErrors>
    <CsWinRTGeneratorMaxDegreesOfParallelism Condition="'$(CsWinRTGeneratorMaxDegreesOfParallelism)' == ''">-1</CsWinRTGeneratorMaxDegreesOfParallelism>
    <CsWinRTGeneratorStandardOutputImportance Condition="'$(CsWinRTGeneratorStandardOutputImportance)' == ''">High</CsWinRTGeneratorStandardOutputImportance>
    <CsWinRTGeneratorStandardErrorImportance Condition="'$(CsWinRTGeneratorStandardErrorImportance)' == ''">High</CsWinRTGeneratorStandardErrorImportance>
    <CsWinRTGeneratorLogStandardErrorAsError Condition="'$(CsWinRTGeneratorLogStandardErrorAsError)' == ''">true</CsWinRTGeneratorLogStandardErrorAsError>

    <!-- Derived properties for 'cswinrtgen' tooling -->
    <_CsWinRTGeneratorInteropAssemblyName>WinRT.Interop</_CsWinRTGeneratorInteropAssemblyName>
    <_CsWinRTGeneratorInteropAssemblyFileName>$(_CsWinRTGeneratorInteropAssemblyName).dll</_CsWinRTGeneratorInteropAssemblyFileName>
    <_CsWinRTGeneratorInteropAssemblyPath>$([MSBuild]::NormalizePath('$(CsWinRTGeneratorInteropAssemblyDirectory)', '$(_CsWinRTGeneratorInteropAssemblyFileName)'))</_CsWinRTGeneratorInteropAssemblyPath>

    <!--
      Set the path of the file with the hash of all input properties for 'cswinrtgen'.
      This is needed to make the target incremental with respect to property changes.
    -->
    <_RunCsWinRTGeneratorPropertyInputsCachePath Condition="'$(_RunCsWinRTGeneratorPropertyInputsCachePath)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).cswinrtgen.cache</_RunCsWinRTGeneratorPropertyInputsCachePath>
    <_RunCsWinRTGeneratorPropertyInputsCachePath>$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(_RunCsWinRTGeneratorPropertyInputsCachePath)'))</_RunCsWinRTGeneratorPropertyInputsCachePath>
  </PropertyGroup>

  <!--
    ============================================================
                        _ComputeRunCsWinRTGeneratorCache

    Computes the cache file for '_RunCsWinRTGenerator' with the
    hash of all input properties, to support incremental builds.
    ============================================================
  -->
  <Target Name="_ComputeRunCsWinRTGeneratorCache" DependsOnTargets="ResolveAssemblyReferences">

    <!--
      If the user hasn't specified the 'CsWinRTToolsDirectory' property, we need to resolve the correct
      tools path to use to find the 'cswinrtgen' binary that matches the 'WinRT.Runtime.dll' assembly in
      use. To do so, we can leverage the assembly resolution logic that the .NET SDK is already doing.
      We know that the right 'cswinrtgen' binary will always be in the '\tools' directory of whatever
      package contains the 'WinRT.Runtime.dll' assembly (i.e. either 'Microsoft.Windows.SDK.NET.Ref' or
      'Microsoft.Windows.CsWinRT'). So we can get the resolved assembly and compute the tools directory
      path relative to it. We can use this value whenever 'CsWinRTToolsDirectory' isn't set.
    -->
    <ItemGroup>
      <_WinRTRuntimeDllReferencePath
        Include="@(ReferencePath)"
        Condition="'%(Filename)%(Extension)' == 'WinRT.Runtime.dll'" />
    </ItemGroup>
    
    <!-- Compute the implicit '\tools' path, and use that if 'CsWinRTToolsDirectory' isn't set -->
    <PropertyGroup>
      <_WinRTRuntimeDllDirectory>$([System.IO.Path]::GetDirectoryName('%(_WinRTRuntimeDllReferencePath.FullPath)'))</_WinRTRuntimeDllDirectory>
      <_CsWinRTOrTargetingPackLibDirectory>$([System.IO.Path]::GetDirectoryName('$(_WinRTRuntimeDllDirectory)'))</_CsWinRTOrTargetingPackLibDirectory>
      <_CsWinRTOrTargetingPackRootDirectory>$([System.IO.Path]::GetDirectoryName('$(_CsWinRTOrTargetingPackLibDirectory)'))</_CsWinRTOrTargetingPackRootDirectory>
      <_CsWinRTOrTargetingPackToolsDirectory>$([System.IO.Path]::Combine('$(_CsWinRTOrTargetingPackRootDirectory)', 'tools'))</_CsWinRTOrTargetingPackToolsDirectory>

      <CsWinRTEffectiveToolsDirectory>$(CsWinRTToolsDirectory)</CsWinRTEffectiveToolsDirectory>
      <CsWinRTEffectiveToolsDirectory Condition="'$(CsWinRTEffectiveToolsDirectory)' == ''">$(_CsWinRTOrTargetingPackToolsDirectory)</CsWinRTEffectiveToolsDirectory>
    </PropertyGroup>

    <ItemGroup>
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTEffectiveToolsDirectory)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTToolsArchitecture)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorInteropAssemblyDirectory)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorDebugReproDirectory)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTUseWindowsUIXamlProjections)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorValidateWinRTRuntimeAssemblyVersion)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorValidateWinRTRuntimeDllVersion2References)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorEnableIncrementalGeneration)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorTreatWarningsAsErrors)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorMaxDegreesOfParallelism)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="@(CsWinRTGeneratorAdditionalArgument)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorStandardOutputImportance)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorStandardErrorImportance)" />
      <_RunCsWinRTGeneratorInputsCacheToHash Include="$(CsWinRTGeneratorLogStandardErrorAsError)" />
    </ItemGroup>

    <Hash ItemsToHash="@(_RunCsWinRTGeneratorInputsCacheToHash)">
      <Output TaskParameter="HashResult" PropertyName="_RunCsWinRTGeneratorInputsCacheHash" />
    </Hash>

    <WriteLinesToFile
      Lines="$(_RunCsWinRTGeneratorInputsCacheHash)"
      File="$(_RunCsWinRTGeneratorPropertyInputsCachePath)"
      Overwrite="true"
      WriteOnlyWhenDifferent="true" />
  </Target>

  <!--
    ============================================================
                        _RunCsWinRTGenerator

    Runs 'cswinrtgen' to produce the 'WinRT.Interop.dll' assembly.
    ============================================================
  -->
  <UsingTask Condition="'$(CsWinRTGeneratorTasksOverriden)' != 'true'" TaskName="RunCsWinRTGenerator" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <Target
    Name="_RunCsWinRTGenerator"
    DependsOnTargets="CoreCompile;$(GetTargetPathDependsOn);$(GetTargetPathWithTargetPlatformMonikerDependsOn);_ComputeRunCsWinRTGeneratorCache"
    BeforeTargets="GetTargetPath;GetTargetPathWithTargetPlatformMoniker;GenerateBuildDependencyFile;GeneratePublishDependencyFile;GetCopyToOutputDirectoryItems;GetCopyToPublishDirectoryItems"
    Inputs="@(ReferencePath);@(IntermediateAssembly);$(_RunCsWinRTGeneratorPropertyInputsCachePath)"
    Outputs="$(_CsWinRTGeneratorInteropAssemblyPath)"
    Condition="'$(CsWinRTGenerateInteropAssembly)' == 'true'">

    <!-- Invoke 'cswinrtgen' -->
    <RunCsWinRTGenerator
      ReferenceAssemblyPaths="@(ReferencePath)"
      OutputAssemblyPath="@(IntermediateAssembly)"
      InteropAssemblyDirectory="$(CsWinRTGeneratorInteropAssemblyDirectory)"
      DebugReproDirectory="$(CsWinRTGeneratorDebugReproDirectory)"
      CsWinRTToolsDirectory="$(CsWinRTEffectiveToolsDirectory)"
      CsWinRTToolsArchitecture="$(CsWinRTToolsArchitecture)"
      UseWindowsUIXamlProjections="$(CsWinRTUseWindowsUIXamlProjections)"
      ValidateWinRTRuntimeAssemblyVersion="$(CsWinRTGeneratorValidateWinRTRuntimeAssemblyVersion)"
      ValidateWinRTRuntimeDllVersion2References="$(CsWinRTGeneratorValidateWinRTRuntimeDllVersion2References)"
      EnableIncrementalGeneration="$(CsWinRTGeneratorEnableIncrementalGeneration)"
      TreatWarningsAsErrors="$(CsWinRTGeneratorTreatWarningsAsErrors)"
      MaxDegreesOfParallelism="$(CsWinRTGeneratorMaxDegreesOfParallelism)"
      AdditionalArguments="@(CsWinRTGeneratorAdditionalArgument)"
      StandardOutputImportance="$(CsWinRTGeneratorStandardOutputImportance)"
      StandardErrorImportance="$(CsWinRTGeneratorStandardErrorImportance)"
      LogStandardErrorAsError="$(CsWinRTGeneratorLogStandardErrorAsError)" />

    <!-- Set the metadata for the interop .dll item -->
    <ItemGroup>
      <CsWinRTGeneratorInteropAssemblyPath Include="$(_CsWinRTGeneratorInteropAssemblyPath)">
        <AssemblyName>$(_CsWinRTGeneratorInteropAssemblyName)</AssemblyName>
        <TargetFrameworkIdentifier>.NETCoreApp</TargetFrameworkIdentifier>
        <ReferenceOutputAssembly>true</ReferenceOutputAssembly>
        <IncludeRuntimeDependency>true</IncludeRuntimeDependency>
        <Private>true</Private>
        <MSBuildSourceTargetName>_RunCsWinRTGenerator</MSBuildSourceTargetName>
        <Platforms>AnyCPU</Platforms>
      </CsWinRTGeneratorInteropAssemblyPath>
    </ItemGroup>

    <!-- Add the interop .dll to the required output groups -->
    <ItemGroup>

      <!-- 'ReferencePath' handles adding the interop .dll to '.deps.json', which is needed for '[UnsafeAccessor]' to work -->
      <ReferencePath Include="@(CsWinRTGeneratorInteropAssemblyPath)" />

      <!-- '_SourceItemsToCopyToOutputDirectory' handles copying the interop .dll to the build output folder -->
      <_SourceItemsToCopyToOutputDirectory
        Include="@(CsWinRTGeneratorInteropAssemblyPath)"
        TargetPath="$(_CsWinRTGeneratorInteropAssemblyFileName)" />

      <!-- '_SourceItemsToCopyToPublishDirectory' handles copying the interop .dll to the publish output folder -->
      <_SourceItemsToCopyToPublishDirectory
        Include="@(CsWinRTGeneratorInteropAssemblyPath)"
        TargetPath="$(_CsWinRTGeneratorInteropAssemblyFileName)" />
    </ItemGroup>

    <!-- Append to 'FileWrites' so the interop .dll will be removed on clean -->
    <ItemGroup>
      <FileWrites Include="@(CsWinRTGeneratorInteropAssemblyPath)"/>
    </ItemGroup>
  </Target>
</Project>
