<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AtLeastOneTargetFrameworkMustBeSpecified" xml:space="preserve">
    <value>É necessário especificar pelo menos uma estrutura de destino possível.</value>
  </data>
  <data name="NoCompatibleTargetFramework" xml:space="preserve">
    <value>O projeto '{0}' não tem nenhuma estrutura de destino compatível com '{1}'.</value>
  </data>
  <data name="InvalidFrameworkName" xml:space="preserve">
    <value>Nome de estrutura inválido: '{0}'.</value>
  </data>
  <data name="AssetsFileNotFound" xml:space="preserve">
    <value>Arquivo de ativos '{0}' não encontrado. Execute uma restauração de pacote NuGet para gerar esse arquivo.</value>
  </data>
  <data name="AssetsFileMissingTarget" xml:space="preserve">
    <value>O arquivo de ativos '{0}' não tem um destino para '{1}'. Certifique-se de ter restaurado esse projeto para TargetFramework='{2}' e RuntimeIdentifier='{3}'.</value>
  </data>
  <data name="AssetsFilePathNotRooted" xml:space="preserve">
    <value>O caminho de arquivo de ativos '{0}' não tem raiz. Apenas caminhos completos têm suporte.</value>
  </data>
  <data name="CannotFindProjectInfo" xml:space="preserve">
    <value>Não é possível localizar informações de projeto para '{0}'. Isso pode indicar uma referência de projeto ausente.</value>
  </data>
  <data name="ContentFileDoesNotContainExpectedParentPackageInformation" xml:space="preserve">
    <value>O arquivo de conteúdo '{0}' não contém as informações de pacote pai esperadas.</value>
  </data>
  <data name="MissingItemMetadata" xml:space="preserve">
    <value>Metadados '{0}' ausentes no item '{1}' '{2}'.</value>
  </data>
  <data name="UnrecognizedPreprocessorToken" xml:space="preserve">
    <value>Token de pré-processador não reconhecido '{0}' no '{1}'.</value>
  </data>
  <data name="ContentPreproccessorParameterRequired" xml:space="preserve">
    <value>A tarefa '{0}' deve receber um valor para o parâmetro '{1}' para consumir o conteúdo pré-processado.</value>
  </data>
  <data name="ProjectAssetsConsumedWithoutMSBuildProjectPath" xml:space="preserve">
    <value>Os ativos são consumidos de um projeto '{0}', mas não foi encontrado nenhum caminho de projeto do MSBuild correspondente em '{1}'.</value>
  </data>
  <data name="UnexpectedFileType" xml:space="preserve">
    <value>Tipo de arquivo inesperado para '{0}'. O tipo é '{1}' e '{2}'.</value>
  </data>
  <data name="CannotInferTargetFrameworkIdentiferAndVersion" xml:space="preserve">
    <value>Não é possível inferir TargetFrameworkIdentifier e/ou TargetFrameworkVersion de TargetFramework='{0}'. Eles devem ser especificados explicitamente.</value>
  </data>
  <data name="ContentItemDoesNotProvideOutputPath" xml:space="preserve">
    <value>O item de conteúdo para '{0}' define '{1}', mas não fornece '{2}' ou '{3}'.</value>
  </data>
  <data name="DuplicatePreprocessorToken" xml:space="preserve">
    <value>O token de pré-processador '{0}' recebeu mais de um valor. Escolhendo '{1}' como o valor.</value>
  </data>
  <data name="ErrorsOccurredWhenEmittingSatelliteAssembly" xml:space="preserve">
    <value>Ocorreram erros ao emitir o assembly satélite '{0}'.</value>
  </data>
  <data name="UnableToFindResolvedPath" xml:space="preserve">
    <value>Não foi possível localizar o caminho resolvido para '{0}'.</value>
  </data>
  <data name="UnexpectedDependencyWithNoVersionNumber" xml:space="preserve">
    <value>Dependência inesperada '{0}' sem número de versão.</value>
  </data>
  <data name="AssetPreprocessorMustBeConfigured" xml:space="preserve">
    <value>O pré-processador de ativos deve ser configurado antes de os ativos serem processados.</value>
  </data>
  <data name="InvalidNuGetVersionString" xml:space="preserve">
    <value>Cadeia de caracteres de versão do NuGet inválida: '{0}'.</value>
  </data>
  <data name="DOTNET1011" xml:space="preserve">
    <value>Estrutura não instalada: {0} em {1}</value>
  </data>
  <data name="DOTNET1012" xml:space="preserve">
    <value>O diretório de assemblies de referência não foi especificado. É possível definir o local usando a variável de ambiente DOTNET_REFERENCE_ASSEMBLIES_PATH.</value>
  </data>
  <data name="DOTNET1013" xml:space="preserve">
    <value>As seguintes dependências estão marcadas com o tipo 'platform'; no entanto, apenas uma dependência pode ter esse tipo: {0}</value>
  </data>
  <data name="DOTNET1014" xml:space="preserve">
    <value>Falha ao ler arquivo de bloqueio</value>
  </data>
  <data name="DOTNET1017" xml:space="preserve">
    <value>O arquivo de projeto não existe: '{0}'.</value>
  </data>
  <data name="NU1001" xml:space="preserve">
    <value>A dependência '{0}' não pôde ser resolvida.</value>
  </data>
  <data name="NU1002" xml:space="preserve">
    <value>A dependência '{0}' do projeto '{1}' não dá suporte à estrutura '{2}'.</value>
  </data>
  <data name="NU1006" xml:space="preserve">
    <value>{0}. Execute 'dotnet restore' para gerar um novo arquivo de ativo.</value>
  </data>
  <data name="NU1007" xml:space="preserve">
    <value>A dependência especificada era '{0}', mas terminou com '{1}'.</value>
  </data>
  <data name="NU1008" xml:space="preserve">
    <value>{0} é uma estrutura sem suporte.</value>
  </data>
  <data name="NU1009" xml:space="preserve">
    <value>O arquivo de ativo esperado não existe. Execute 'dotnet restore' para gerar um novo arquivo de ativo.</value>
  </data>
  <data name="NU1010" xml:space="preserve">
    <value>O tipo de dependência foi alterado</value>
  </data>
  <data name="NU1011" xml:space="preserve">
    <value>Não há suporte para o destino de dependência '{0}'.</value>
  </data>
  <data name="NU1012" xml:space="preserve">
    <value>Conflito de dependência. '{0}' esperava '{1}', mas recebeu '{2\}'</value>
  </data>
  <data name="DuplicateItemsError" xml:space="preserve">
    <value>Os itens '{0}' duplicados foram incluídos. O .NET SDK inclui '{0}' itens do seu diretório de projeto por padrão. Você poderá remover esses itens do seu arquivo de projeto ou configurar a propriedade '{1}' para '{2}', se desejar os incluir explicitamente no arquivo de projeto. Os itens duplicados são: {3}</value>
  </data>
  <data name="PackageReferenceOverrideWarning" xml:space="preserve">
    <value>Um PackageReference para '{0}' foi incluído no seu projeto. Esse pacote é referenciado implicitamente pelo .NET SDK e normalmente você não precisa referenciá-lo no seu projeto. Para obter mais informações, consulte {1}</value>
  </data>
</root>