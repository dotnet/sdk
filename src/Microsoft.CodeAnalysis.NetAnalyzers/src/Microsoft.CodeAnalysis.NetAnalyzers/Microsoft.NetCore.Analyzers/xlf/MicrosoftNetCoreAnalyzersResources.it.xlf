<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="it" original="../MicrosoftNetCoreAnalyzersResources.resx">
    <body>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">Aggiungere l'attributo 'NonSerialized' a questo campo.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddPublicParameterlessConstructor">
        <source>Add a public constructor that takes zero parameters</source>
        <target state="new">Add a public constructor that takes zero parameters</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">Aggiungere l'attributo Serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherMode">
        <source>Review cipher mode usage with cryptography experts</source>
        <target state="translated">Verificare l'utilizzo della modalità crittografia con esperti di crittografia</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These cipher modes might be vulnerable to attacks. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">Queste modalità di crittografia potrebbero essere vulnerabili ad attacchi. Provare a usare le modalità consigliate (CBC, CTS).</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>Review the usage of cipher mode '{0}' with cryptography experts. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">Verificare l'utilizzo della modalità crittografia '{0}' con esperti di crittografia. Provare a usare le modalità consigliate (CBC, CTS).</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">Il parametro del valore letterale stringa di un attributo non viene analizzato correttamente per un URL, un GUID o una versione.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'</source>
        <target state="translated">Nel costruttore di '{0}' modificare il valore dell'argomento '{1}', che è attualmente "{2}", in un valore correttamente analizzabile come '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'</source>
        <target state="translated">Nel costruttore di '{0}' modificare il valore dell'argomento '{1}', che è attualmente una stringa vuota (""), in un valore correttamente analizzabile come '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">I valori letterali stringa dell'attributo devono essere analizzati correttamente</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersDescription">
        <source>Marshalling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshalling operation.</source>
        <target state="translated">Il marshalling di 'StringBuilder' crea sempre una copia del buffer nativo, di conseguenza vengono generate più allocazioni per una singola operazione di marshalling.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersMessage">
        <source>Avoid 'StringBuilder' parameters for P/Invokes. Consider using a character buffer instead.</source>
        <target state="translated">Evitare i parametri 'StringBuilder' per i metodi P/Invoke. In alternativa, provare a usare un buffer di caratteri.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersTitle">
        <source>Avoid 'StringBuilder' parameters for P/Invokes</source>
        <target state="translated">Evitare i parametri 'StringBuilder' per i metodi P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">La libreria di classi .NET Framework fornisce i metodi per recuperare gli attributi personalizzati. Per impostazione predefinita, questi metodi eseguono ricerche nella gerarchia di ereditarietà degli attributi. L'uso di attributi sealed consente di evitare ricerche nella gerarchia di ereditarietà e può migliorare le prestazioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Evitare attributi unsealed</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Evitare attributi unsealed</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">Evitare allocazioni di matrice di lunghezza zero non necessarie.  In alternativa, usare {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations</source>
        <target state="translated">Evitare allocazioni di matrice di lunghezza zero</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili senza un elemento SerializationBinder per limitare il tipo di oggetti nel grafico di oggetti deserializzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</source>
        <target state="translated">Assicurarsi che BinaryFormatter.Binder sia impostato prima di chiamare BinaryFormatter.Deserialize</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili senza un elemento SerializationBinder per limitare il tipo di oggetti nel grafico di oggetti deserializzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetTitle">
        <source>Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</source>
        <target state="translated">Non chiamare BinaryFormatter.Deserialize senza aver prima impostato BinaryFormatter.Binder</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect BinaryFormatter deserialization without a SerializationBinder set, then disable rule CA2300, and enable rules CA2301 and CA2302.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili. Se invece è necessario rilevare la deserializzazione di BinaryFormatter senza un elemento SerializationBinder impostato, disabilitare la regola CA2300 e abilitare le regole CA2301 e CA2302.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer BinaryFormatter</source>
        <target state="translated">Non usare il deserializzatore non sicuro BinaryFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).</source>
        <target state="translated">Un metodo che è un'implementazione di Dispose non chiama GC.SuppressFinalize, un metodo che non è un'implementazione di Dispose chiama GC.SuppressFinalize oppure un metodo chiama GC.SuppressFinalize e passa un elemento diverso da this (Me in Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">Cambiare {0} in modo da chiamare {1}. In questo modo si eviterà che i tipi derivati che introducono un finalizzatore debbano eseguire una nuova implementazione di 'IDisposable' per chiamarlo.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">Cambiare {0} in modo da chiamare {1}. In questo modo si impedirà la finalizzazione non necessaria dell'oggetto dopo che è stato eliminato e risulta esterno all'ambito.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">{0} chiama {1} su un elemento diverso da se stesso. Modificare il sito di chiamata in modo da passare 'this' ('Me' in Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">{0} chiama {1}, un metodo chiamato in genere all'interno di un'implementazione di 'IDisposable.Dispose'. Per altre informazioni, fare riferimento al criterio IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">I metodi Dispose devono chiamare SuppressFinalize</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="translated">Affidabilità</target>
        <note />
      </trans-unit>
      <trans-unit id="CommaSeparator">
        <source>, </source>
        <target state="translated">, </target>
        <note>Separator used for separating list of platform names: {API} is only supported on: {‘windows’, ‘browser’, ‘linux’}</note>
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">Quando si deserializza input non attendibile, la deserializzazione di un oggetto {0} non è sicura. '{1}' è {0} o deriva da esso</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type found in deserializable object graph</source>
        <target state="translated">Nel grafico di oggetti deserializzabile è stato trovato il tipo DataSet o DataTable non sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}. Ensure that the auto-generated type is never deserialized with untrusted data.</source>
        <target state="translated">Quando si deserializza input non attendibile con un serializzatore basato su IFormatter, la deserializzazione di un oggetto {0} non è sicura. '{1}' è {0} o deriva da esso. Assicurarsi che il tipo generato automaticamente non venga mai deserializzato con dati non attendibili.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in auto-generated serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">L'oggetto DataSet o DataTable non sicuro nel tipo serializzabile generato automaticamente può essere vulnerabile ad attacchi di tipo esecuzione di codice remoto</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">Quando si deserializza input non attendibile, la deserializzazione di un oggetto {0} non è sicura. '{1}' è {0} o deriva da esso</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks</source>
        <target state="translated">L'oggetto DataSet o DataTable non sicuro nel grafico di oggetti deserializzato può essere vulnerabile ad attacchi di tipo esecuzione di codice remoto</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}.</source>
        <target state="translated">Quando si deserializza input non attendibile con un serializzatore basato su IFormatter, la deserializzazione di un oggetto {0} non è sicura. '{1}' è {0} o deriva da esso.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">L'oggetto DataSet o DataTable non sicuro nel tipo serializzabile può essere vulnerabile ad attacchi di tipo esecuzione di codice remoto</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">Quando si deserializza input non attendibile, la deserializzazione di un oggetto {0} non è sicura. '{1}' è {0} o deriva da esso</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type</source>
        <target state="translated">Oggetto DataSet o DataTable non sicuro nel tipo serializzabile</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">Quando si deserializza input non attendibile, la deserializzazione di un oggetto {0} non è sicura. '{1}' è {0} o deriva da esso</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type in web deserializable object graph</source>
        <target state="translated">Tipo DataSet o DataTable non sicuro nel grafico di oggetti deserializzabile Web</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data. Make sure that auto-generated class containing the '{0}' call is not deserialized with untrusted data.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili. Assicurarsi che la classe generata automaticamente che contiene la chiamata '{0}' non venga deserializzata con dati non attendibili.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedTitle">
        <source>Ensure auto-generated class containing DataSet.ReadXml() is not used with untrusted data</source>
        <target state="translated">Assicurarsi che la classe generata automaticamente che contiene il metodo DataSet.ReadXml() non venga usata con dati non attendibili</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlTitle">
        <source>Do not use DataSet.ReadXml() with untrusted data</source>
        <target state="translated">Non usare DataSet.ReadXml() con dati non attendibili</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlTitle">
        <source>Do not use DataTable.ReadXml() with untrusted data</source>
        <target state="translated">Non usare DataTable.ReadXml() con dati non attendibili</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheck">
        <source>HttpClients should enable certificate revocation list checks</source>
        <target state="translated">HttpClients deve abilitare i controlli dell'elenco di revoche di certificati</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheckMessage">
        <source>HttpClient is created without enabling CheckCertificateRevocationList</source>
        <target state="translated">HttpClient viene creato senza abilitare CheckCertificateRevocationList</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="translated">Non aggiungere certificati all'archivio radice</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="translated">L'aggiunta di certificati a certificati radice attendibili del sistema operativo aumenta il rischio di autenticazione non corretta di un certificato illegittimo</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIV">
        <source>Do not use CreateEncryptor with non-default IV</source>
        <target state="translated">Non usare CreateEncryptor con il vettore di inizializzazione non predefinito</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIVMessage">
        <source>Symmetric encryption uses non-default initialization vector, which could be potentially repeatable</source>
        <target state="translated">La crittografia simmetrica usa un vettore di inizializzazione non predefinito, che potrebbe essere potenzialmente ripetibile</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">Usa cookie protetti in ASP.NET Core</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">Impostare CookieOptions.Secure = true durante l'impostazione di un cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCount">
        <source>Do Not Use Weak Key Derivation Function With Insufficient Iteration Count</source>
        <target state="translated">Non usare la funzione di derivazione di chiave vulnerabile con un numero di iterazioni insufficiente</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCountMessage">
        <source>Use at least {0} iterations when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">Usare almeno {0} iterazioni durante la derivazione di una chiave crittografica da una password. Per impostazione predefinita, il valore di IterationCount per Rfc2898DeriveByte è solo 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsDescription">
        <source>Older protocol versions of Transport Layer Security (TLS) are less secure than TLS 1.2 and TLS 1.3, and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk.</source>
        <target state="translated">Le versioni precedenti del protocollo Transport Layer Security (TLS) sono meno sicure rispetto a TLS 1.2 e TLS 1.3 e presentano maggiori probabilità di includere nuove vulnerabilità. Evitare le versioni precedenti del protocollo per ridurre al minimo i rischi.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsMessage">
        <source>Transport Layer Security protocol version '{0}' is deprecated.  Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">La versione '{0}' del protocollo Transport Layer Security è deprecata. Usare 'None' per consentire al sistema operativo di scegliere una versione.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsTitle">
        <source>Do not use deprecated SslProtocols values</source>
        <target state="translated">Non usare valori SslProtocols deprecati</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">Un tipo che implementa System.IDisposable dichiara i campi di tipi che implementano anch'essi IDisposable. Il metodo Dispose del campo non viene chiamato dal metodo Dispose del tipo dichiarante. Per correggere una violazione di questa regola, chiamare Dispose su campi di tipi che implementano IDisposable se si è responsabile dell'allocazione e del rilascio delle risorse non gestite utilizzate dal campo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>'{0}' contains field '{1}' that is of IDisposable type '{2}', but it is never disposed. Change the Dispose method on '{0}' to call Close or Dispose on this field.</source>
        <target state="translated">'{0}' contiene il campo '{1}' che è di tipo IDisposable '{2}', ma non viene mai eliminato. Modificare il metodo Dispose su '{0}' in modo che chiami Close o Dispose su questo campo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">I campi eliminabili devono essere eliminati</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">Un tipo che implementa System.IDisposable e include campi che suggeriscono l'uso di risorse non gestite non implementa un finalizzatore, come descritto da Object.Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">I tipi eliminabili devono dichiarare il finalizzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">I tipi eliminabili devono dichiarare il finalizzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.</source>
        <target state="translated">Un tipo che implementa System.IDisposable eredita da un tipo che implementa anch'esso IDisposable. Il metodo Dispose del tipo che eredita non chiama il metodo Dispose del tipo padre. Per correggere una violazione di questa regola, chiamare base.Dispose nel metodo Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Ensure that method '{0}' calls '{1}' in all possible control flow paths</source>
        <target state="translated">Assicurarsi che il metodo '{0}' chiami '{1}' in tutti i percorsi del flusso di controllo possibili</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose methods should call base class dispose</source>
        <target state="translated">I metodi Dispose devono chiamare Dispose della classe di base</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</source>
        <target state="translated">Se un oggetto eliminabile non viene eliminato in modo esplicito prima che tutti i riferimenti a esso siano esterni all'ambito, verrà eliminato in un momento indeterminato quando il relativo finalizzatore verrà eseguito dal Garbage Collector. Poiché un evento eccezionale potrebbe impedire l'esecuzione del finalizzatore dell'oggetto, è preferibile che l'oggetto venga eliminato in modo esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">Usare il criterio dispose consigliato per garantire che l'oggetto creato da '{0}' venga eliminato in tutti i percorsi. Se possibile, eseguire il wrapping della creazione in un'istruzione 'using' o una dichiarazione 'using'. In caso contrario, usare un criterio try-finally, con una variabile locale dedicata dichiarata prima dell'area try e una chiamata Dispose non condizionale al valore non Null nell'area 'finally', ad esempio 'x?.Dispose()'. Se l'oggetto viene eliminato in modo esplicito nell'area try oppure la proprietà di dispose viene trasferita a un altro oggetto o metodo, assegnare 'null' alla variabile locale subito dopo una tale operazione per evitare di raddoppiare dispose in 'finally'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all exception paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">Usare il criterio dispose consigliato per garantire che l'oggetto creato da '{0}' venga eliminato in tutti i percorsi delle eccezioni. Se possibile, eseguire il wrapping della creazione in un'istruzione 'using' o una dichiarazione 'using'. In caso contrario, usare un criterio try-finally, con una variabile locale dedicata dichiarata prima dell'area try e una chiamata Dispose non condizionale al valore non Null nell'area 'finally', ad esempio 'x?.Dispose()'. Se l'oggetto viene eliminato in modo esplicito nell'area try oppure la proprietà di dispose viene trasferita a un altro oggetto o metodo, assegnare 'null' alla variabile locale subito dopo una tale operazione per evitare di raddoppiare dispose in 'finally'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedMessage">
        <source>Call System.IDisposable.Dispose on object created by '{0}' before all references to it are out of scope</source>
        <target state="translated">Chiamare System.IDisposable.Dispose sull'oggetto creato da '{0}' prima che tutti i relativi riferimenti siano esterni all'ambito</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage">
        <source>Object created by '{0}' is not disposed along all exception paths. Call System.IDisposable.Dispose on the object before all references to it are out of scope.</source>
        <target state="translated">L'oggetto creato da '{0}' non è stato eliminato in tutti i percorsi delle eccezioni. Chiamare System.IDisposable.Dispose sull'oggetto prima che tutti i relativi riferimenti siano esterni.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose objects before losing scope</source>
        <target state="translated">Elimina gli oggetti prima che siano esterni all'ambito</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPath">
        <source>Do Not Add Archive Item's Path To The Target File System Path</source>
        <target state="translated">Non aggiungere il percorso dell'elemento di archivio al percorso del file system di destinazione</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription">
        <source>When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</source>
        <target state="translated">Quando si estraggono file da un archivio e si usa il percorso dell'elemento di archiviazione, verificare che il percorso sia sicuro. Il percorso di archivio può essere relativo e può comportare l'accesso al file system al di fuori del percorso di destinazione previsto del file system, determinando modifiche di configurazione dannose e l'esecuzione di codice remoto tramite la tecnica lay-and-wait.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage">
        <source>When creating path for '{0} in method {1}' from relative archive item path to extract file and the source is an untrusted zip archive, make sure to sanitize relative archive item path '{2} in method {3}'</source>
        <target state="translated">Quando si crea il percorso per '{0} nel metodo {1}' dal percorso relativo dell'elemento di archivio per estrarre il file e l'origine è un archivio ZIP non attendibile, assicurarsi di purificare il percorso relativo dell'elemento di archivio '{2} nel metodo {3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">Non aggiungere lo schema in base all'URL</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Questo overload del metodo XmlSchemaCollection.Add abilita internamente l'elaborazione della DTD sull'istanza usata del lettore XML e usa UrlResolver per risolvere le entità XML esterne. Il risultato implica la diffusione di informazioni. Il contenuto di file system o condivisioni di rete per il computer che elabora il codice XML può essere esposto a utenti malintenzionati. Un utente malintenzionato può inoltre usarlo come vettore DoS.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">Questo overload del metodo Add è potenzialmente insicuro perché può risolvere riferimenti esterni pericolosi</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserialization">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">Non chiamare metodi pericolosi durante la deserializzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">La deserializzazione non sicura è una vulnerabilità che si riscontra quando vengono usati dati non attendibili per violare la logica di un'applicazione, causare un attacco Denial of Service (DoS) o persino eseguire codice arbitrario durante la deserializzazione. Gli utenti malintenzionati sfruttano spesso queste funzionalità di deserializzazione quando l'applicazione deserializza dati non attendibili controllati da loro, in particolare richiamando metodi pericolosi nel processo di deserializzazione. Attacchi riusciti di deserializzazione non sicura possono consentire a un utente malintenzionato di portare a termine attacchi di tipo DoS, bypass di autenticazione ed esecuzione di codice da remoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class {0}, method {1} can call dangerous method {2}. The potential method invocations are: {3}.</source>
        <target state="translated">Durante la deserializzazione di un'istanza della classe {0} il metodo {1} può chiamare il metodo pericoloso {2}. Le potenziali chiamate al metodo sono: {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>When a constructor calls a virtual method, the constructor for the instance that invokes the method may not have executed.</source>
        <target state="translated">Quando un costruttore chiama un metodo virtuale, è possibile che il costruttore per l'istanza che richiama il metodo non sia stato eseguito.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsMessage">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Non chiamare metodi sottoponibili a override nei costruttori</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsTitle">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Non chiamare metodi sottoponibili a override nei costruttori</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueMessage">
        <source>Do not call {0} on an {1} value</source>
        <target state="translated">Non chiamare {0} su un valore {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueTitle">
        <source>Do not call ToImmutableCollection on an ImmutableCollection value</source>
        <target state="translated">Non chiamare ToImmutableCollection su un valore ImmutableCollection</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersDescription">
        <source>Do not author general catch handlers in code that receives corrupted state exceptions.</source>
        <target state="translated">Non creare gestori catch generali in codice che riceve le eccezioni di stato danneggiato.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersMessage">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">Non rilevare eccezioni di stato danneggiato in gestori generali.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersTitle">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">Non rilevare eccezioni di stato danneggiato in gestori generali.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsDescription">
        <source>TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.  Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</source>
        <target state="translated">TaskCompletionSource include costruttori che accettano enumerazioni TaskCreationOptions che controllano l'attività sottostante e costruttori che accettano lo stato dell'oggetto archiviato nell'attività. Se si passa accidentalmente un'enumerazione TaskContinuationOptions invece di TaskCreationOptions, la chiamata considererà le opzioni come stato.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsFix">
        <source>Replace TaskContinuationOptions with TaskCreationOptions.</source>
        <target state="translated">Sostituire TaskContinuationOptions con TaskCreationOptions.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsMessage">
        <source>Argument contains TaskContinuationsOptions enum instead of TaskCreationOptions enum</source>
        <target state="translated">L'argomento contiene l'enumerazione TaskContinuationsOptions invece dell'enumerazione TaskCreationOptions</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsTitle">
        <source>Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</source>
        <target state="translated">L'argomento passato al costruttore TaskCompletionSource deve essere l'enumerazione TaskCreationOptions invece dell'enumerazione TaskContinuationOptions</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerDescription">
        <source>Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear.</source>
        <target state="translated">Non creare attività a meno che non si usi uno degli overload che accetta un elemento TaskScheduler. L'impostazione predefinita prevede la pianificazione su TaskScheduler.Current, che comporta deadlock. Usare TaskScheduler.Default per eseguire la pianificazione sul pool di thread oppure passare TaskScheduler.Current in modo esplicito per chiarire le proprie intenzioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerMessage">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">Non creare attività senza passare un elemento TaskScheduler</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerTitle">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">Non creare attività senza passare un elemento TaskScheduler</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerDescription">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;.</source>
        <target state="translated">L'aggiunta di un finalizzatore a un tipo derivato da MemoryManager&lt;T&gt; consente di liberare memoria mentre viene ancora usata da un elemento Span&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerMessage">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;</source>
        <target state="translated">L'aggiunta di un finalizzatore a un tipo derivato da MemoryManager&lt;T&gt; consente di liberare memoria mentre viene ancora usata da un elemento Span&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerTitle">
        <source>Do not define finalizers for types derived from MemoryManager&lt;T&gt;</source>
        <target state="translated">Non definire finalizzatori per tipi derivati da MemoryManager&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">Non disabilitare la convalida del certificato</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">Un certificato può agevolare l'autenticazione dell'identità del server. I client dovrebbero convalidare il certificato del server per assicurarsi che le richieste vengano inviate al server previsto. Se ServerCertificateValidationCallback restituisce sempre 'true', qualsiasi certificato supererà la convalida.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">ServerCertificateValidationCallback è impostato su una funzione che accetta qualsiasi certificato del server, restituendo sempre true. Assicurarsi che i certificati del server siano convalidati per verificare l'identità del server che riceve le richieste.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHttpClientCRLCheckDescription">
        <source>Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid.</source>
        <target state="translated">Se si usa HttpClient senza fornire un gestore specifico della piattaforma (WinHttpHandler, CurlHandler o HttpClientHandler) in cui la proprietà CheckCertificateRevocationList è impostata su true, i certificati revocati verranno accettati come validi da HttpClient.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">Non disabilitare il controllo delle intestazioni HTTP</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">Il controllo delle intestazioni HTTP consente di abilitare la codifica dei caratteri di ritorno a capo e nuova riga, \r e \n, presenti nelle intestazioni di risposta. Questa codifica consente di evitare attacchi di tipo injection che possono sfruttare un'applicazione che include nell'eco dati attendibili contenuti nell'intestazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">Non disabilitare il controllo delle intestazioni HTTP</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">Non disabilitare la convalida delle richieste</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">La convalida delle richieste è una funzionalità di ASP.NET che esamina le richieste HTTP e determina se includono contenuto potenzialmente pericoloso. Questo controllo costituisce un'ulteriore misura di protezione da markup o codice presente nella stringa di query dell'URL, nei cookie o nei valori del modulo pubblicato che potrebbero essere stati aggiunti per scopi dannosi. Si tratta quindi di un controllo auspicabile che deve essere lasciato abilitato per una difesa più efficace.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">La convalida delle richieste è disabilitata per {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">Non disabilitare l'uso della crittografia avanzata in Schannel</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommended to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">A partire da .NET Framework 4.6, è consigliabile che le classi System.Net.ServicePointManager e System.Net.Security.SslStream usino nuovi protocolli. I protocolli precedenti presentano punti debolezza e non sono supportati. Se si imposta Switch.System.Net.DontEnableSchUseStrongCrypto su true, verrà usato il precedente controllo della crittografia vulnerabile e sarà possibile rifiutare esplicitamente la migrazione dei protocolli.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">{0} disabilita TLS 1.2 e abilita SSLv3</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsMessage">
        <source>Do not set Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols to true.  Setting this switch limits Windows Communication Framework (WCF) to using Transport Layer Security (TLS) 1.0, which is insecure and obsolete.</source>
        <target state="translated">Non impostare Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols su true. Se si imposta questa opzione, si limita Windows Communication Framework (WCF) a usare Transport Layer Security (TLS) 1.0, che è insicuro e obsoleto.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsTitle">
        <source>Do not disable ServicePointManagerSecurityProtocols</source>
        <target state="translated">Non disabilitare ServicePointManagerSecurityProtocols</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificate">
        <source>Do not hard-code certificate</source>
        <target state="translated">Non impostare il certificato come hardcoded</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateDescription">
        <source>Hard-coded certificates in source code are vulnerable to being exploited.</source>
        <target state="translated">I certificati hardcoded nel codice sorgente sono vulnerabili agli exploit.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded certificate from '{2}' in method '{3}'</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di sicurezza in cui '{0}' nel metodo '{1}' può essere contaminato dal certificato hardcoded di '{2}' nel metodo '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKey">
        <source>Do not hard-code encryption key</source>
        <target state="translated">Non impostare la chiave di crittografia come hardcoded</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyDescription">
        <source>SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hard-coded value.</source>
        <target state="translated">La proprietà .Key di SymmetricAlgorithm o il parametro rgbKey di un metodo non deve essere mai essere un valore hardcoded.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded key from '{2}' in method '{3}'</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di sicurezza in cui '{0}' nel metodo '{1}' può essere contaminato dalla chiave hardcoded di '{2}' nel metodo '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="translated">Per impostazione predefinita, l'archivio certificati di Autorità di certificazione radice disponibile nell'elenco locale è configurato con un set di CA pubbliche che soddisfa i requisiti del programma Microsoft Root Certificate. Dal momento che tutte le CA radice attendibili possono rilasciare certificati per qualsiasi dominio, un utente malintenzionato può selezionare come destinazione di attacco una CA debole o coercibile installata dall'utente. Una CA vulnerabile, dannosa o coercibile compromette la sicurezza dell'intero sistema, senza contare che questi attacchi possono passare inosservati abbastanza facilmente.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">Un oggetto presenta un'identità debole quando è possibile accedervi direttamente attraverso i confini del dominio dell'applicazione. Un thread che prova ad acquisire un blocco su un oggetto con identità debole può essere bloccato da un secondo thread in un altro dominio dell'applicazione che include un blocco sullo stesso oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Non bloccare oggetti con identità debole</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Non bloccare oggetti con identità debole</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersDescription">
        <source>A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.</source>
        <target state="translated">Un metodo passa un valore letterale stringa come parametro a un costruttore o a un metodo nella libreria di classi .NET Framework e questa stringa deve essere localizzabile. Per correggere una violazione di questa regola, sostituire la stringa letterale con una stringa recuperata attraverso un'istanza della classe ResourceManager.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersMessage">
        <source>Method '{0}' passes a literal string as parameter '{1}' of a call to '{2}'. Retrieve the following string(s) from a resource table instead: "{3}".</source>
        <target state="translated">Il metodo '{0}' passa una stringa letterale come parametro '{1}' di una chiamata a '{2}'. Recuperare le seguenti stringhe da una tabella delle risorse: "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersTitle">
        <source>Do not pass literals as localized parameters</source>
        <target state="translated">Non passare valori letterali come parametri localizzati</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">Il codice utente non dovrebbe mai generare un'eccezione di un tipo non sufficiente specifico o riservato dal runtime. Il rilevamento e il debug dell'errore originale diventano quindi più difficili. Se potrebbe essere generata questa istanza di eccezione, usare un tipo di eccezione diverso.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime</source>
        <target state="translated">Il tipo di eccezione {0} è riservato dal runtime</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific</source>
        <target state="translated">Il tipo di eccezione {0} non è sufficientemente specifico</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">Non generare tipi di eccezione riservati</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">Non serializzare i tipi con campi puntatore</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">I puntatori non sono "indipendenti dai tipi", ovvero non è possibile garantire la correttezza della memoria a cui puntano. La serializzazione di tipi con campi puntatore è quindi pericolosa perché può consentire a un utente malintenzionato di controllare il puntatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type</source>
        <target state="translated">Campo puntatore {0} sul tipo serializzabile</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">Non usare la firma di accesso condiviso dell'account</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">Le firme di accesso condiviso (SAS) sono una parte essenziale del modello di sicurezza per qualsiasi applicazione che usa Archiviazione di Azure e consentono di concedere autorizzazioni limitate e sicure all'account di archiviazione ai client che non hanno la chiave dell'account. Tutte le operazioni disponibili tramite una firma di accesso condiviso del servizio sono disponibili anche tramite una firma di accesso condiviso dell'account, che prevede molte meno limitazioni. Si consiglia quindi di prestare particolare attenzione quando si usa la firma di accesso condiviso del servizio per delegare l'accesso.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">Usare la firma di accesso condiviso del service anziché quella dell'account per criteri più specifici di accesso a livello di contenitore e di controllo di accesso</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">Non usare algoritmi di crittografia violati</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">È stato individuato un attacco in grado di violare questo algoritmo dal punto di vista del calcolo. Gli utenti malintenzionati potrebbero violare le garanzie crittografiche che l'algoritmo dovrebbe offrire. A seconda del tipo e dell'applicazione di questo algoritmo di crittografia, questo potrebbe consentire agli utenti malintenzionati di leggere messaggi crittografati, manomettere messaggi crittografati, falsare firme digitali, manomettere contenuto con hash o compromettere in altro modo eventuali sistemi di crittografia basati su questo algoritmo. Sostituire la crittografia usata con l'algoritmo AES (sono accettabili AES-256, AES-192 e AES-128) con una lunghezza di chiave maggiore o uguale a 128 bit. Sostituire gli hash usati con una funzione hash della famiglia SHA-2, ad esempio SHA512, SHA384 o SHA256. Sostituire le firme digitali usate con RSA con una lunghezza di chiave maggiore o uguale a 2048 bit oppure con ECDSA con una lunghezza di chiave maggiore o uguale a 256 bit.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">{0} usa un algoritmo di crittografia violato {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedDescription">
        <source>For non-empty collections, CountAsync() and LongCountAsync() enumerate the entire sequence, while AnyAsync() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">Nel caso di raccolte non vuote CountAsync() e LongCountAsync() enumerano l'intera sequenza, mentre AnyAsync() si arresta in corrispondenza del primo elemento o del primo elemento che soddisfa una condizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedMessage">
        <source>{0}() is used where AnyAsync() could be used instead to improve performance</source>
        <target state="translated">Si usa {0}() in un punto in cui sarebbe possibile usare AnyAsync() per migliorare le prestazioni</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedTitle">
        <source>Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used</source>
        <target state="translated">Non usare CountAsync() o LongCountAsync() se è possibile usare AnyAsync()</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedDescription">
        <source>For non-empty collections, Count() and LongCount() enumerate the entire sequence, while Any() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">Nel caso di raccolte non vuote Count() e LongCount() enumerano l'intera sequenza, mentre Any() si arresta in corrispondenza del primo elemento o del primo elemento che soddisfa una condizione.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedMessage">
        <source>{0}() is used where Any() could be used instead to improve performance</source>
        <target state="translated">Si usa {0}() in un punto in cui sarebbe possibile usare Any() per migliorare le prestazioni</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedTitle">
        <source>Do not use Count() or LongCount() when Any() can be used</source>
        <target state="translated">Non usare Count() o LongCount() se è possibile usare Any()</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCreateEncryptorWithNonDefaultIVDescription">
        <source>Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</source>
        <target state="translated">La crittografia simmetrica deve usare sempre un vettore di inizializzazione non ripetibile per impedire attacchi con dizionario.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">Non usare protocolli di sicurezza deprecati</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">L'uso di un protocollo di sicurezza deprecato rispetto a quello predefinito di sistema è rischioso.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">Uso hardcoded del protocollo di sicurezza deprecato {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="translated">Non usare l'algoritmo di firma digitale (DSA)</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="translated">L'algoritmo DSA è troppo debole per essere usato.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">L'algoritmo di crittografia asimmetrica {0} è debole. Passare a un algoritmo RSA con dimensione di chiave minima pari a 2048 oppure a un algoritmo ECDH o ECDSA.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">Questa raccolta è direttamente indicizzabile. L'uso di LINQ in questo punto causa un carico della CPU e allocazioni non necessarie.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly.</source>
        <target state="translated">Non usare metodi Enumerable su raccolte indicizzabili. In alternativa, usare direttamente la raccolta.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections</source>
        <target state="translated">Non usare metodi Enumerable su raccolte indicizzabili</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomness">
        <source>Do not use insecure randomness</source>
        <target state="translated">Non usare la casualità non sicura</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessDescription">
        <source>Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated. Use a cryptographically strong random number generator if an unpredictable value is required, or ensure that weak pseudo-random numbers aren't used in a security-sensitive manner.</source>
        <target state="translated">L'uso di un generatore di numeri pseudo-casuali vulnerabile dal punto di vista della crittografia può consentire a un utente malintenzionato di prevedere il valore sensibile alla sicurezza che verrà generato. Se è richiesto un valore non prevedibile, usare un generatore di numeri casuali sicuro dal punto di vista della crittografia oppure assicurarsi che i numeri pseudo-casuali vulnerabili non vengano usati in modo sensibile per la sicurezza.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessMessage">
        <source>{0} is an insecure random number generator. Use cryptographically secure random number generators when randomness is required for security.</source>
        <target state="translated">{0} è un generatore di numeri casuali non sicuro. Usare generatori di numeri casuali sicuri dal punto di vista della crittografia quando per motivi di sicurezza è richiesta la casualità.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5">
        <source>Do not use insecure cryptographic algorithm MD5.</source>
        <target state="translated">Non usare l'algoritmo di crittografia non sicuro MD5.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5Description">
        <source>This type implements MD5, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the MD5 and HMACMD5 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">Questo tipo implementa MD5, una funzione hash crittograficamente non sicura. Da un punto di vista computazionale, le collisioni di hash sono possibili per gli algoritmi MD5 e HMACMD5. Sostituire questo algoritmo con uno hash della famiglia SHA-2 (SHA512, SHA384, SHA256).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">Non usare la funzione di derivazione di chiave obsoleta</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">La derivazione di chiave basata su password deve usare PBKDF2 con SHA-2. Evitare di usare PasswordDeriveBytes perché genera una chiave PBKDF1. Evitare di usare Rfc2898DeriveBytes.CryptDeriveKey perché non usa il salting o il conteggio delle iterazioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">Chiamata alla funzione di derivazione di chiave obsoleta {0}.{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersDescription">
        <source>String parameters passed by value with the 'OutAttribute' can destabilize the runtime if the string is an interned string.</source>
        <target state="translated">I parametri di stringa passati per valore con 'OutAttribute' possono destabilizzare il runtime se la stringa è centralizzata.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersMessage">
        <source>Do not use the 'OutAttribute' for string parameter '{0}' which is passed by value. If marshalling of modified data back to the caller is required, use the 'out' keyword to pass the string by reference instead.</source>
        <target state="translated">Non usare 'OutAttribute' per il parametro di stringa '{0}' che viene passato per valore. Se è richiesto il marshalling dei dati modificati al chiamante, usare la parola chiave 'out' per passare la stringa per riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersTitle">
        <source>Do not use 'OutAttribute' on string parameters for P/Invokes</source>
        <target state="translated">Non usare 'OutAttribute' su parametri di stringa per metodi P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesComparerMessage">
        <source>Do not pass an argument with value type '{0}' to the 'Equals' method on 'ReferenceEqualityComparer'. Due to value boxing, this call to 'Equals' will always return 'false'.</source>
        <target state="translated">Non passare un argomento con tipo valore '{0}' al metodo 'Equals' in 'ReferenceEqualityComparer'. A causa della conversione boxing dei valori, questa chiamata a 'Equals' restituirà sempre 'false'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesDescription">
        <source>Value type typed arguments are uniquely boxed for each call to this method, therefore the result is always false.</source>
        <target state="translated">Gli argomenti tipizzati del tipo valore sono sottoposti a boxing in modo univoco per ogni chiamata a questo metodo, di conseguenza il risultato è sempre false.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesMethodMessage">
        <source>Do not pass an argument with value type '{0}' to 'ReferenceEquals'. Due to value boxing, this call to 'ReferenceEquals' will always return 'false'.</source>
        <target state="translated">Non passare un argomento con tipo valore '{0}' a 'ReferenceEquals'. A causa della conversione boxing dei valori, questa chiamata a 'ReferenceEquals' restituirà sempre 'false'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesTitle">
        <source>Do not use ReferenceEquals with value types</source>
        <target state="translated">Non usare ReferenceEquals con tipi valore</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1">
        <source>Do not use insecure cryptographic algorithm SHA1.</source>
        <target state="translated">Non usare l'algoritmo di crittografia non sicuro SHA1.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1Description">
        <source>This type implements SHA1, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the SHA-1 and SHA-0 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">Questo tipo implementa SHA1, una funzione hash crittograficamente non sicura. Da un punto di vista computazionale, le collisioni di hash sono possibili per gli algoritmi SHA-1 e SHA-0. Sostituire questo algoritmo con uno hash della famiglia SHA-2 (SHA512, SHA384, SHA256).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsDescription">
        <source>Stack space allocated by a stackalloc is only released at the end of the current method's invocation.  Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</source>
        <target state="translated">Lo spazio dello stack allocato da stackalloc viene rilasciato solo alla fine della chiamata del metodo corrente. Se viene usato in un ciclo, possono verificarsi condizioni di crescita illimitata dello stack e eventuale overflow dello stack.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsMessage">
        <source>Potential stack overflow. Move the stackalloc out of the loop.</source>
        <target state="translated">Potenziale overflow dello stack. Spostare stackalloc all'esterno del ciclo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsTitle">
        <source>Do not use stackalloc in loops</source>
        <target state="translated">Non usare stackalloc nei cicli</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">Un'attività periodica più frequente tiene la CPU occupata e interferisce con i timer di inattività per il risparmio di energia che disattivano lo schermo e i dischi rigidi.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Non usare timer che impediscono le modifiche allo stato di potenza</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Non usare timer che impediscono le modifiche allo stato di potenza</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPath">
        <source>Do not use unsafe DllImportSearchPath value</source>
        <target state="translated">Non usare il valore DllImportSearchPath non sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathDescription">
        <source>There could be a malicious DLL in the default DLL search directories. Or, depending on where your application is run from, there could be a malicious DLL in the application's directory. Use a DllImportSearchPath value that specifies an explicit search path instead. The DllImportSearchPath flags that this rule looks for can be configured in .editorconfig.</source>
        <target state="translated">Nelle directory di ricerca DLL predefinite potrebbe essere presente una DLL dannosa oppure, a seconda della posizione di esecuzione dell'applicazione, nella directory dell'applicazione potrebbe essere presente una DLL dannosa. Usare un valore DllImportSearchPath che specifica un percorso di ricerca esplicito. I flag DllImportSearchPath cercati da questa regola possono essere configurati nel file con estensione editorconfig.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathMessage">
        <source>Use of unsafe DllImportSearchPath value {0}</source>
        <target state="translated">Uso del valore {0} non sicuro di DllImportSearchPath</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskDescription">
        <source>Using 'WaitAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="new">Using 'WaitAll' with a single task may result in performance loss, await or return the task instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskFix">
        <source>Replace 'WaitAll' with single 'Wait'</source>
        <target state="new">Replace 'WaitAll' with single 'Wait'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskTitle">
        <source>Do not use 'WaitAll' with a single task</source>
        <target state="new">Do not use 'WaitAll' with a single task</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">Non usare algoritmi di crittografia vulnerabili</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">Gli algoritmi di crittografia degradano col passare del tempo quando gli attacchi si fanno più sofisticati consentendo a utenti malintenzionati di accedere a un maggior numero di dati di calcolo. A seconda del tipo e dell'applicazione di questo algoritmo di crittografia, nonché della riduzione dell'efficacia crittografica, questo potrebbe consentire agli utenti malintenzionati di leggere messaggi crittografati, manomettere messaggi crittografati, falsare firme digitali, manomettere contenuto con hash o compromettere in altro modo eventuali sistemi di crittografia basati su questo algoritmo. Sostituire la crittografia usata con l'algoritmo AES (sono accettabili AES-256, AES-192 e AES-128) con una lunghezza di chiave maggiore o uguale a 128 bit. Sostituire gli hash usati con una funzione hash della famiglia SHA-2, ad esempio SHA-2 512, SHA-2 384, or SHA-2 256.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">{0} usa un algoritmo di crittografia vulnerabile {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Ensure Key Derivation Function algorithm is sufficiently strong</source>
        <target state="translated">Verifica che l'algoritmo della funzione di derivazione di chiave sia sufficientemente complesso</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="translated">Alcune implementazioni della classe Rfc2898DeriveBytes consentono di specificare un algoritmo hash in un parametro del costruttore o di sovrascriverlo nella proprietà HashAlgorithm. Se si specifica un algoritmo hash, è necessario specificare almeno quello SHA-256.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} might be using a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password.</source>
        <target state="translated">{0} potrebbe usare un algoritmo hash vulnerabile. Usare SHA256, SHA384 o SHA512 per creare una chiave avanzata da una password.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFInsufficientIterationCountDescription">
        <source>When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).</source>
        <target state="translated">Durante la derivazione di chiavi crittografiche dagli input forniti dall'utente, come la password, usare un numero di iterazioni sufficiente (almeno 100.000).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskDescription">
        <source>Using 'WhenAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="new">Using 'WhenAll' with a single task may result in performance loss, await or return the task instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskFix">
        <source>Replace 'WhenAll' call with argument</source>
        <target state="new">Replace 'WhenAll' call with argument</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskTitle">
        <source>Do not use 'WhenAll' with a single task</source>
        <target state="new">Do not use 'WhenAll' with a single task</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">Non usare XslTransform</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">Non usare XslTransform. Non limita i riferimenti esterni potenzialmente pericolosi.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedDescription">
        <source>Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic.</source>
        <target state="new">Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedMessage">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="new">Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedTitle">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="new">Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerDescription">
        <source>Finalization must be propagated through the inheritance hierarchy. To guarantee this, types must call their base class Finalize method in their own Finalize method.</source>
        <target state="translated">La finalizzazione deve essere propagata tramite la gerarchia di ereditarietà. A tale scopo, i tipi devono chiamare il metodo Finalize della classe di base nel proprio metodo Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerMessage">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">I finalizzatori devono chiamare il finalizzatore della classe di base</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerTitle">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">I finalizzatori devono chiamare il finalizzatore della classe di base</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsDescription">
        <source>Forward the 'CancellationToken' parameter to methods to ensure the operation cancellation notifications gets properly propagated, or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token.</source>
        <target state="translated">Inoltrare il parametro 'CancellationToken' ai metodi per assicurare la corretta propagazione delle notifiche di annullamento dell'operazione oppure passare 'CancellationToken.None' in modo esplicito per indicare che il token non viene propagato intenzionalmente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsMessage">
        <source>Forward the '{0}' parameter to the '{1}' method or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token</source>
        <target state="translated">Inoltrare il parametro '{0}' al metodo '{1}' oppure passare 'CancellationToken.None' in modo esplicito per indicare che il token non viene propagato intenzionalmente</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsTitle">
        <source>Forward the 'CancellationToken' parameter to methods</source>
        <target state="translated">Inoltrare il parametro 'CancellationToken' ai metodi</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="translated">Evitare di impostare SecurityProtocolType {0} come hardcoded e usare SecurityProtocolType.SystemDefault per consentire al sistema operativo di scegliere il migliore protocollo Transport Layer Security da usare.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="translated">Evitare di impostare il valore SecurityProtocolType come hardcoded</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsDescription">
        <source>Current Transport Layer Security protocol versions may become deprecated if vulnerabilities are found. Avoid hardcoding SslProtocols values to keep your application secure. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">Le versioni correnti del protocollo Transport Layer Security potrebbero diventare deprecate se vengono trovate vulnerabilità. Per garantire la protezione dell'applicazione, evitare di impostare i valori SslProtocols come hardcoded. Usare 'None' per consentire al sistema operativo di scegliere una versione.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsMessage">
        <source>Avoid hardcoding SslProtocols '{0}' to ensure your application remains secure in the future. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">Evitare di impostare i valori '{0}' di SslProtocols come hardcoded per garantire che l'applicazione rimanga protetta in futuro. Usare 'None' per consentire al sistema operativo di scegliere una versione.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsTitle">
        <source>Avoid hardcoded SslProtocols values</source>
        <target state="translated">Evitare di impostare i valori di SslProtocols come hardcoded</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyDescription">
        <source>To fix a violation of this rule, make the GetObjectData method visible and overridable, and make sure that all instance fields are included in the serialization process or explicitly marked by using the NonSerializedAttribute attribute.</source>
        <target state="translated">Per correggere una violazione di questa regola, impostare il metodo GetObjectData come visibile e sottoponibile a override e assicurarsi che tutti i campi di istanza siano inclusi nel processo di serializzazione o contrassegnati in modo esplicito usando l'attributo NonSerializedAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageDefault">
        <source>Add an implementation of GetObjectData to type {0}</source>
        <target state="translated">Aggiungere un'implementazione di GetObjectData al tipo {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeOverridable">
        <source>Make {0}.GetObjectData virtual and overridable</source>
        <target state="translated">Rendere {0}.GetObjectData virtuale e sottoponibile a override</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeVisible">
        <source>Increase the accessibility of {0}.GetObjectData so that it is visible to derived types</source>
        <target state="translated">Aumentare l'accessibilità di {0}.GetObjectData in modo che sia visibile ai tipi derivati</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyTitle">
        <source>Implement ISerializable correctly</source>
        <target state="translated">Implementare ISerializable in modo corretto</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementInterfacesOnDynamicCastableImplementation">
        <source>Implement inherited interfaces</source>
        <target state="new">Implement inherited interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsCodeActionTitle">
        <source>Implement Serialization constructor</source>
        <target state="translated">Implementare il costruttore di serializzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsDescription">
        <source>To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it protected.</source>
        <target state="translated">Per correggere una violazione di questa regola, implementare il costruttore di serializzazione. Per una classe sealed impostare il costruttore come private; in caso contrario impostarlo come protected.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageCreateMagicConstructor">
        <source>Add a constructor to {0} with the following signature: 'protected {0}(SerializationInfo info, StreamingContext context)'.</source>
        <target state="translated">Aggiungere un costruttore a {0} con la seguente firma: 'protected {0}(SerializationInfo info, StreamingContext context)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeSealedMagicConstructorPrivate">
        <source>Declare the serialization constructor of {0}, a sealed type, as private.</source>
        <target state="translated">Dichiarare il costruttore di serializzazione di {0}, tipo sealed, come privato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeUnsealedMagicConstructorFamily">
        <source>Declare the serialization constructor of {0}, an unsealed type, as protected.</source>
        <target state="translated">Dichiarare come protected il costruttore di serializzazione di {0}, un tipo unsealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsTitle">
        <source>Implement serialization constructors</source>
        <target state="translated">Implementare costruttori di serializzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyDescription">
        <source>A method that handles a serialization event does not have the correct signature, return type, or visibility.</source>
        <target state="translated">Un metodo che gestisce un evento di serializzazione non include valori corretti per visibilità, tipo restituito o firma.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageGeneric">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it is no longer generic</source>
        <target state="translated">Dal momento che {0} è contrassegnato con OnSerializing, OnSerialized, OnDeserializing o OnDeserialized, modificare la firma in modo che non sia più generica</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageParameters">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it takes a single parameter of type 'System.Runtime.Serialization.StreamingContext'</source>
        <target state="translated">Dal momento che {0} è contrassegnato con OnSerializing, OnSerialized, OnDeserializing o OnDeserialized, modificare la firma in modo che accetti un solo parametro di tipo 'System.Runtime.Serialization.StreamingContext'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageReturnType">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its return type from {1} to void (Sub in Visual Basic)</source>
        <target state="translated">Dal momento che {0} è contrassegnato con OnSerializing, OnSerialized, OnDeserializing o OnDeserialized, modificare il tipo restituito da {1} in void (Sub in Visual Basic)</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageStatic">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change it from static (Shared in Visual Basic) to an instance method</source>
        <target state="translated">Dal momento che {0} è contrassegnato con OnSerializing, OnSerialized, OnDeserializing o OnDeserialized, modificarlo da statico (Shared in Visual Basic) in un metodo di istanza</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageVisibility">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its accessibility to private</source>
        <target state="translated">Dal momento che {0} è contrassegnato con OnSerializing, OnSerialized, OnDeserializing o OnDeserialized, modificarne l'accessibilità in private</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyTitle">
        <source>Implement serialization methods correctly</source>
        <target state="translated">Implementare correttamente i metodi di serializzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Un tipo riferimento dichiara un costruttore statico esplicito. Per correggere una violazione di questa regola, inizializzare tutti i dati static quando vengono dichiarati e rimuovere il costruttore statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">Inizializzare inline i campi statici di tipo riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">Inizializzare tutti i campi statici in '{0}' quando questi campi sono dichiarati e rimuovere il costruttore statico esplicito</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Un tipo valore dichiara un costruttore statico esplicito. Per correggere una violazione di questa regola, inizializzare tutti i dati static quando vengono dichiarati e rimuovere il costruttore statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">Inizializzare inline i campi statici di tipo valore</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyChangeToTwoArgumentCodeFixTitle">
        <source>Change to call the two argument constructor, pass null for the message.</source>
        <target state="translated">Modificare per chiamare il costruttore a due argomenti; passare Null per il messaggio.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">Viene effettuata una chiamata al costruttore predefinito (senza parametri) di un tipo di eccezione che corrisponde a o deriva da ArgumentException oppure viene passato un argomento stringa non corretto a un costruttore con parametri di un tipo di eccezione che corrisponde a o deriva da ArgumentException.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyFlipArgumentOrderCodeFixTitle">
        <source>Swap the arguments order</source>
        <target state="translated">Scambiare l'ordine degli argomenti</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">Il metodo {0} passa il nome di parametro '{1}' come argomento di {2} a un costruttore {3}. Sostituire questo argomento con un messaggio descrittivo e passare il nome di parametro nella posizione corretta.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">Il metodo {0} passa '{1}' come argomento di {2} a un costruttore {3}. Sostituire l'argomento con uno dei nomi di parametro del metodo. Il nome del parametro specificato deve rispettare l'uso di maiuscole/minuscole così come dichiarato nel metodo.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter</source>
        <target state="translated">Chiamare il costruttore {0} che contiene un messaggio e/o il parametro paramName</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate argument exceptions correctly</source>
        <target state="translated">Creare istanze di eccezioni di argomento in modo corretto</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationDescription">
        <source>Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise.</source>
        <target state="new">Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationMessage">
        <source>Type '{0}' has the 'DynamicInterfaceCastableImplementationAttribute' applied to it but does not provide an implementation of all interface members defined in inherited interfaces</source>
        <target state="new">Type '{0}' has the 'DynamicInterfaceCastableImplementationAttribute' applied to it but does not provide an implementation of all interface members defined in inherited interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationTitle">
        <source>All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface</source>
        <target state="new">All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Ensure that the JavaScriptSerializer is initialized without a JavaScriptTypeResolver specified, or initialized with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili con un elemento JavaScriptSerializer inizializzato con un elemento SimpleTypeResolver. Assicurarsi che l'elemento JavaScriptSerializer venga inizializzato senza specificare un elemento JavaScriptTypeResolver oppure che venga inizializzato con un elemento JavaScriptTypeResolver che limita i tipi di oggetti nel grafico di oggetti deserializzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverTitle">
        <source>Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</source>
        <target state="translated">Assicurarsi che JavaScriptSerializer non sia inizializzato con SimpleTypeResolver prima della deserializzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Initialize JavaScriptSerializer without a JavaScriptTypeResolver specified, or initialize with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili con un elemento JavaScriptSerializer inizializzato con un elemento SimpleTypeResolver. Inizializzare JavaScriptSerializer senza specificare un elemento JavaScriptTypeResolver oppure inizializzarlo con un elemento JavaScriptTypeResolver che limita i tipi di oggetti nel grafico di oggetti deserializzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverTitle">
        <source>Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</source>
        <target state="translated">Non deserializzare con JavaScriptSerializer usando un elemento SimpleTypeResolver</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">Quando si deserializza input non attendibile, non è sicuro consentire la deserializzazione di tipi arbitrari. Quando si deserializza con JsonSerializer, usare TypeNameHandling.None oppure, per valori diversi da None, limitare i tipi deserializzati con un elemento SerializationBinder.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerTitle">
        <source>Do not deserialize with JsonSerializer using an insecure configuration</source>
        <target state="translated">Non deserializzare con JsonSerializer usando una configurazione non sicura</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">Quando si deserializza input non attendibile, non è sicuro consentire la deserializzazione di tipi arbitrari. Quando si usa JsonSerializerSettings, usare TypeNameHandling.None oppure, per valori diversi da None, limitare i tipi deserializzati con un elemento SerializationBinder.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsTitle">
        <source>Do not use insecure JsonSerializerSettings</source>
        <target state="translated">Non usare l'elemento JsonSerializerSettings non sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">Quando si deserializza input non attendibile, non è sicuro consentire la deserializzazione di tipi arbitrari. Quando si deserializza con JsonSerializer, usare TypeNameHandling.None oppure, per valori diversi da None, limitare i tipi deserializzati con un elemento SerializationBinder.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerTitle">
        <source>Ensure that JsonSerializer has a secure configuration when deserializing</source>
        <target state="translated">Assicurarsi che la configurazione di JsonSerializer sia sicura durante la deserializzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, ensure TypeNameHandling.None is specified, or for values other than None, ensure a SerializationBinder is specified to restrict deserialized types.</source>
        <target state="translated">Quando si deserializza input non attendibile, non è sicuro consentire la deserializzazione di tipi arbitrari. Quando si usa JsonSerializerSettings, assicurarsi che TypeNameHandling.None sia specificato oppure, per valori diversi da None, assicurarsi che sia specificato un elemento SerializationBinder per limitare i tipi deserializzati.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsTitle">
        <source>Ensure that JsonSerializerSettings are secure</source>
        <target state="translated">Assicurarsi che l'elemento JsonSerializerSettings sia sicuro</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingDescription">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.  If you need to instead detect Json.NET deserialization when a SerializationBinder isn't specified, then disable rule CA2326, and enable rules CA2327, CA2328, CA2329, and CA2330.</source>
        <target state="translated">La deserializzazione di JSON quando si usa un valore TypeNameHandling diverso da None può essere insicura. Se è necessario rilevare invece la deserializzazione di JSON.NET quando non è specificato alcun oggetto SerializationBinder, disabilitare la regola CA2326 e abilitare le regole CA2327, CA2328, CA2329 e CA2330.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingMessage">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.</source>
        <target state="translated">La deserializzazione di JSON quando si usa un valore TypeNameHandling diverso da None può essere insicura.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingTitle">
        <source>Do not use TypeNameHandling values other than None</source>
        <target state="translated">Non usare valori di TypeNameHandling diversi da None</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili.</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer LosFormatter</source>
        <target state="translated">Non usare il deserializzatore non sicuro LosFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeParameterlessConstructorPublic">
        <source>Make the constructor that takes zero parameters 'public'</source>
        <target state="new">Make the constructor that takes zero parameters 'public'</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">Un campo di istanza di un tipo non serializzabile viene dichiarato in un tipo serializzabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">Il campo {0} è un membro di tipo {1}, che è serializzabile, ma è di tipo {2}, che non è serializzabile</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">Contrassegnare tutti i campi non serializzabili</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageDescription">
        <source>The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set.</source>
        <target state="translated">L'attributo NeutralResourcesLanguage indica a ResourceManager la lingua usata per visualizzare le risorse delle impostazioni cultura per un assembly non associate ad alcun paese. Questo approccio migliora le prestazioni delle ricerche per la prima risorsa caricata e può ridurre il working set.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageMessage">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">Contrassegnare gli assembly con NeutralResourcesLanguageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageTitle">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">Contrassegnare gli assembly con NeutralResourcesLanguageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">Per il tipo di dati booleano sono disponibili più rappresentazioni nel codice non gestito.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Aggiungere MarshalAsAttribute al parametro {0} di P/Invoke {1}. Se il valore del parametro non gestito corrispondente è di tipo 'BOOL' Win32 a 4 byte, usare [MarshalAs(UnmanagedType.Bool)]. Per un valore di tipo 'bool' C++ a 1 byte, usare MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Aggiungere MarshalAsAttribute al tipo restituito di P/Invoke {0}. Se il valore del tipo restituito non gestito corrispondente è di tipo 'BOOL' Win32 a 4 byte, usare MarshalAs(UnmanagedType.Bool). Per un valore di tipo 'bool' C++ a 1 byte, usare MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">Contrassegnare gli argomenti di PInvoke booleani con MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">Per essere riconosciuti come serializzabili in Common Language Runtime, i tipi devono essere contrassegnati usando l'attributo SerializableAttribute anche quando usano una routine di serializzazione personalizzata tramite l'implementazione dell'interfaccia ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">Aggiungere [Serializable] a {0} perché questo tipo implementa ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">Contrassegnare i tipi ISerializable con serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheck">
        <source>Ensure HttpClient certificate revocation list check is not disabled</source>
        <target state="translated">Assicurarsi che il controllo dell'elenco di revoche di certificati di HttpClient non sia disabilitato</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheckMessage">
        <source>HttpClient may be created without enabling CheckCertificateRevocationList</source>
        <target state="translated">HttpClient può essere creato senza abilitare CheckCertificateRevocationList</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="translated">Verificare che i certificati non vengano aggiunti all'archivio radice</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="translated">L'aggiunta di certificati a certificati radice attendibili del sistema operativo non è sicura. Verificare che l'archivio di destinazione non sia un archivio radice.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIV">
        <source>Use CreateEncryptor with the default IV </source>
        <target state="translated">Usa CreateEncryptor con il vettore di inizializzazione predefinito </target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIVMessage">
        <source>The non-default initialization vector, which can be potentially repeatable, is used in the encryption. Ensure use the default one.</source>
        <target state="translated">Nella crittografia viene usato il vettore di inizializzazione non predefinito, che può essere potenzialmente ripetibile. Assicurarsi di usare quello predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">Assicura l'uso di cookie protetti in ASP.NET Core</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">Assicurarsi che CookieOptions.Secure = true durante l'impostazione di un cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCount">
        <source>Ensure Sufficient Iteration Count When Using Weak Key Derivation Function</source>
        <target state="translated">Assicurare un numero di iterazioni sufficiente quando si usa la funzione di derivazione di chiave vulnerabile</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCountMessage">
        <source>Ensure that the iteration count is at least {0} when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">Assicurarsi che il numero delle iterazioni sia almeno {0} durante la derivazione di una chiave crittografica da una password. Per impostazione predefinita, il valore di IterationCount per Rfc2898DeriveByte è solo 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeSealedDescription">
        <source>Since a type that implements 'IDynamicInterfaceCastable' will conventionally not specify that it implements a 'DynamicInterfaceCastableImplementationAttribute'-attributed type, only the public interface type, virtual interface method lookup will fail even if the method has an implementation. As a result, all members on 'DynamicInterfaceCastableImplementation'-attributed types should be 'sealed'.</source>
        <target state="new">Since a type that implements 'IDynamicInterfaceCastable' will conventionally not specify that it implements a 'DynamicInterfaceCastableImplementationAttribute'-attributed type, only the public interface type, virtual interface method lookup will fail even if the method has an implementation. As a result, all members on 'DynamicInterfaceCastableImplementation'-attributed types should be 'sealed'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeSealedMessage">
        <source>The '{0}' member on the '{1}' type should be marked 'sealed' as '{1}' has the 'DynamicInterfaceImplementationAttribute' applied</source>
        <target state="new">The '{0}' member on the '{1}' type should be marked 'sealed' as '{1}' has the 'DynamicInterfaceImplementationAttribute' applied</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeSealedTitle">
        <source>Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'sealed'</source>
        <target state="new">Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'sealed'</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttribute">
        <source>Miss HttpVerb attribute for action methods</source>
        <target state="translated">Attributo HttpVerb mancante per i metodi di azione</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeDescription">
        <source>All the methods that create, edit, delete, or otherwise modify data do so in the [HttpPost] overload of the method, which needs to be protected with the anti forgery attribute from request forgery. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</source>
        <target state="translated">Tutti i metodi che consentono di creare, modificare, eliminare o cambiare in altro modo i dati usano l'overload [HttpPost] del metodo, che deve essere protetto dalla falsificazione delle richieste con l'apposito attributo antifalsificazione. L'esecuzione di un'operazione GET deve essere un'operazione sicura che non presenta effetti collaterali e non modifica i dati persistenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeMessage">
        <source>Action method {0} needs to specify the HTTP request kind explicitly</source>
        <target state="translated">Il metodo di azione {0} deve specificare in modo esplicito il tipo della richiesta HTTP</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili senza un elemento SerializationBinder per limitare il tipo di oggetti nel grafico di oggetti deserializzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure NetDataContractSerializer.Binder is set before deserializing</source>
        <target state="translated">Assicurarsi che NetDataContractSerializer.Binder sia impostato prima della deserializzazione</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili senza un elemento SerializationBinder per limitare il tipo di oggetti nel grafico di oggetti deserializzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetTitle">
        <source>Do not deserialize without first setting NetDataContractSerializer.Binder</source>
        <target state="translated">Non deserializzare senza aver prima impostato NetDataContractSerializer.Binder</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect NetDataContractSerializer deserialization without a SerializationBinder set, then disable rule CA2310, and enable rules CA2311 and CA2312.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili. Se invece è necessario rilevare la deserializzazione di NetDataContractSerializer senza un elemento SerializationBinder impostato, disabilitare la regola CA2310 e abilitare le regole CA2311 e CA2312.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedTitle">
        <source>Do not use insecure deserializer NetDataContractSerializer</source>
        <target state="translated">Non usare il deserializzatore non sicuro NetDataContractSerializer</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">Le stringhe devono essere normalizzate in maiuscolo. Un piccolo gruppo di caratteri non è in grado di completare un round trip in caso di conversione in minuscolo. Completare un round trip significa convertire i caratteri da determinate impostazioni locali ad altre che rappresentano i dati dei caratteri in modo diverso e quindi recuperare in modo accurato i caratteri originali da quelli convertiti.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'</source>
        <target state="translated">Nel metodo '{0}' sostituire la chiamata a '{1}' con '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">Normalizzare le stringhe in maiuscolo</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">Il metodo '{0}' non è sicuro quando si deserializzano dati non attendibili.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer ObjectStateFormatter</source>
        <target state="translated">Non usare il deserializzatore non sicuro ObjectStateFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableDescription">
        <source>This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that the size of the parameter is correct when marshaled to unmanaged code on 32-bit and 64-bit operating systems.</source>
        <target state="translated">Questa regola valuta le dimensioni di ogni parametro e il valore restituito di un metodo P/Invoke e verifica che le dimensioni del parametro siano corrette quando viene eseguito il marshalling a codice non gestito in sistemi operativi a 32 e a 64 bit.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageParameter">
        <source>As it is declared in your code, parameter {0} of P/Invoke {1} will be {2} bytes wide on {3} platforms. This is not correct, as the actual native declaration of this API indicates it should be {4} bytes wide on {3} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {5}.</source>
        <target state="translated">Come dichiarato nel codice, il valore del parametro {0} di P/Invoke {1} sarà pari a {2} byte sulle piattaforme {3}. Questo non è corretto perché l'effettiva dichiarazione nativa di questa API indica che deve essere pari a {4} byte sulle piattaforme {3}. Consultare la documentazione di MSDN Platform SDK per informazioni su come determinare il tipo di dati da usare al posto di {5}.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageReturn">
        <source>As it is declared in your code, the return type of P/Invoke {0} will be {1} bytes wide on {2} platforms. This is not correct, as the actual native declaration of this API indicates it should be {3} bytes wide on {2} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {4}.</source>
        <target state="translated">Come dichiarato nel codice, il valore del tipo restituito di P/Invoke {0} sarà pari a {1} byte sulle piattaforme {2}. Questo non è corretto perché l'effettiva dichiarazione nativa di questa API indica che deve essere pari a {3} byte sulle piattaforme {2}. Consultare la documentazione di MSDN Platform SDK per informazioni su come determinare il tipo di dati da usare al posto di {4}.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableTitle">
        <source>PInvoke declarations should be portable</source>
        <target state="translated">Le dichiarazioni PInvoke devono essere portabili</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">Un metodo public o protected in un tipo public contiene l'attributo System.Runtime.InteropServices.DllImportAttribute (implementato anche dalla parola chiave Declare in Visual Basic). Questi metodi non devono essere esposti.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">Il metodo P/Invoke '{0}' non deve essere visibile</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">I metodi P/Invoke non devono essere visibili</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllPlatforms">
        <source>and all other platforms</source>
        <target state="translated">e tutte le altre piattaforme</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and later, and all other platforms</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllVersions">
        <source>'{0}' all versions</source>
        <target state="translated">'{0}' - tutte le versioni</target>
        <note>This call site is reachable on: 'Windows' all versions.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityDescription">
        <source>Using platform dependent API on a component makes the code no longer work across all platforms.</source>
        <target state="translated">Se si usa un'API dipendente dalla piattaforma su un componente, il codice non funziona più in tutte le piattaforme.</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityFromVersionToVersion">
        <source>'{0}' from version {1} to {2}</source>
        <target state="translated">'{0}' dalla versione {1} alla versione {2}</target>
        <note>'SupportedOnWindows1903UnsupportedOn2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is only supported on: {1}.</source>
        <target state="translated">Questo sito di chiamata è raggiungibile da tutte le piattaforme. '{0}' è supportato solo in {1}.</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindowsAndBrowser()' is only supported on: 'windows', 'browser' .</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">Questo sito di chiamata è raggiungibile da {2}. '{0}' è supportato solo in {1}.</target>
        <note>This call site is reachable on: 'windows' all versions.'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsUnreachableMessage">
        <source>This call site is unreachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">Questo sito di chiamata non è raggiungibile da {2}. '{0}' è supportato solo in {1}.</target>
        <note>This call site is unreachable on: 'browser'. 'SupportedOnWindowsAndBrowser()' is only supported on: 'browser', 'windows'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is supported on: {1}.</source>
        <target state="translated">Questo sito di chiamata è raggiungibile da tutte le piattaforme. '{0}' è supportato in {1}.</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindows1903UnsupportedFrom2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is supported on: {1}.</source>
        <target state="translated">Questo sito di chiamata è raggiungibile da {2}. '{0}' è supportato in {1}.</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and before. 'UnsupportedOnWindowsSupportedOn1903()' is supported on: 'windows' 10.0.1903 and later.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityTitle">
        <source>Validate platform compatibility</source>
        <target state="translated">Convalida compatibilità della piattaforma</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is unsupported on: {1}.</source>
        <target state="translated">Questo sito di chiamata è raggiungibile da tutte le piattaforme. '{0}' non è supportato in {1}.</target>
        <note>This call site is reachable on all platforms. 'UnsupportedOnWindows()' is unsupported on: 'windows'</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is unsupported on: {1}.</source>
        <target state="translated">Questo sito di chiamata è raggiungibile da {2}. '{0}' non è supportato in {1}.</target>
        <note>This call site is reachable on: 'windows', 'browser'. 'UnsupportedOnBrowser()' is unsupported on: 'browser'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndBefore">
        <source>'{0}' {1} and before</source>
        <target state="translated">'{0}' {1} e versioni precedenti</target>
        <note>'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndLater">
        <source>'{0}' {1} and later</source>
        <target state="translated">'{0}' {1} e versioni successive</target>
        <note>'SupportedOnWindows10()' is only supported on: 'windows' 10.0 and later.</note>
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphDescription">
        <source>Review code that processes untrusted deserialized data for handling of unexpected reference cycles. An unexpected reference cycle should not cause the code to enter an infinite loop. Otherwise, an unexpected reference cycle can allow an attacker to DOS or exhaust the memory of the process when deserializing untrusted data.</source>
        <target state="translated">Rivedere il codice che elabora dati deserializzati non attendibili per la gestione di cicli di riferimento imprevisti. Un ciclo di riferimento imprevisto non deve causare un ciclo infinito del codice. Un ciclo di riferimento imprevisto può invece consentire attacchi di tipo DoS da parte di un utente malintenzionato o l'esaurimento della memoria del processo durante la deserializzazione di dati non attendibili.</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">{0} fa parte di un potenziale ciclo di riferimento</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphTitle">
        <source>Potential reference cycle in deserialized object graph</source>
        <target state="translated">Potenziale ciclo di riferimento nel grafico di oggetti deserializzati</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringCodefixTitle">
        <source>Replace 'Substring' with 'AsSpan'</source>
        <target state="new">Replace 'Substring' with 'AsSpan'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringDescription">
        <source>'AsSpan' is more efficient then 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost.</source>
        <target state="new">'AsSpan' is more efficient then 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringMessage">
        <source>Prefer 'AsSpan' over 'Substring' when span-based overloads are available</source>
        <target state="new">Prefer 'AsSpan' over 'Substring' when span-based overloads are available</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringTitle">
        <source>Prefer 'AsSpan' over 'Substring'</source>
        <target state="new">Prefer 'AsSpan' over 'Substring'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyCodeFixTitle">
        <source>Use 'ContainsKey'</source>
        <target state="new">Use 'ContainsKey'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyDescription">
        <source>'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations.</source>
        <target state="new">'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyMessage">
        <source>Prefer 'ContainsKey' over 'Keys.Contains' for dictionary type '{0}'</source>
        <target state="new">Prefer 'ContainsKey' over 'Keys.Contains' for dictionary type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsMethodsTitle">
        <source>Prefer Dictionary.Contains methods</source>
        <target state="new">Prefer Dictionary.Contains methods</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueCodeFixTitle">
        <source>Use 'ContainsValue'</source>
        <target state="new">Use 'ContainsValue'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueDescription">
        <source>Many dictionary implementations lazily initialize the Values collection. To avoid unnecessary allocations, prefer 'ContainsValue' over 'Values.Contains'.</source>
        <target state="new">Many dictionary implementations lazily initialize the Values collection. To avoid unnecessary allocations, prefer 'ContainsValue' over 'Values.Contains'.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueMessage">
        <source>Prefer 'ContainsValue' over 'Values.Contains' for dictionary type '{0}'</source>
        <target state="new">Prefer 'ContainsValue' over 'Values.Contains' for dictionary type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsDescription">
        <source>'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument. Prefer calling the memory based overloads, which are more efficient.</source>
        <target state="translated">'Stream' contiene un overload 'ReadAsync' che accetta 'Memory&lt;Byte&gt;' come primo argomento e un overload 'WriteAsync' che accetta 'ReadOnlyMemory&lt;Byte&gt;' come primo argomento. Per la chiamata preferire gli overload basati su Memory, che sono più efficaci.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountDescription">
        <source>For determining whether the object contains or not any items, prefer using 'IsEmpty' property rather than retrieving the number of items from the 'Count' property and comparing it to 0 or 1.</source>
        <target state="translated">Per determinare se l'oggetto contiene o meno elementi, usare la proprietà 'IsEmpty' invece di recuperare il numero di elementi con la proprietà 'Count' e confrontarlo con 0 o 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountMessage">
        <source>Prefer 'IsEmpty' over 'Count' to determine whether the object is empty</source>
        <target state="translated">Preferire 'IsEmpty' a 'Count' per determinare se l'oggetto è vuoto</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountTitle">
        <source>Prefer IsEmpty over Count</source>
        <target state="translated">Preferire IsEmpty a Count</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsMessage">
        <source>Change the '{0}' method call to use the '{1}' overload</source>
        <target state="translated">Modificare la chiamata al metodo '{0}' per usare l'overload '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsTitle">
        <source>Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</source>
        <target state="translated">Preferire gli overload basati su 'Memory' per 'ReadAsync' e 'WriteAsync'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfCodeFixTitle">
        <source>Replace with 'string.Contains'</source>
        <target state="translated">Sostituisci con 'string.Contains'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfDescription">
        <source>Calls to 'string.IndexOf' where the result is used to check for the presence/absence of a substring can be replaced by 'string.Contains'.</source>
        <target state="translated">Le chiamate a 'string.IndexOf' in cui il risultato viene usato per verificare la presenza/assenza di una sottostringa possono essere sostituite da 'string.Contains'.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfMessage">
        <source>Use 'string.Contains' instead of 'string.IndexOf' to improve readability</source>
        <target state="translated">Per migliorare la leggibilità, usare 'string.Contains' invece di 'string.IndexOf'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfTitle">
        <source>Consider using 'string.Contains' instead of 'string.IndexOf'</source>
        <target state="translated">Provare a usare 'string.Contains' invece di 'string.IndexOf'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsDescription">
        <source>StringBuilder.Append and StringBuilder.Insert provide overloads for multiple types beyond System.String.  When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</source>
        <target state="translated">StringBuilder.Append e StringBuilder.Insert forniscono overload per più tipi oltre System.String. Quando possibile, preferire gli overload fortemente tipizzati invece di usare ToString() e l'overload basato su stringhe.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsMessage">
        <source>Remove the ToString call in order to use a strongly-typed StringBuilder overload</source>
        <target state="translated">Rimuovere la chiamata ToString per usare un overload di StringBuilder fortemente tipizzato</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsRemoveToString">
        <source>Remove the ToString call</source>
        <target state="translated">Rimuovere la chiamata a ToString</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsTitle">
        <source>Prefer strongly-typed Append and Insert method overloads on StringBuilder</source>
        <target state="translated">Preferire gli overload di metodi Append e Insert fortemente tipizzati su StringBuilder</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderDescription">
        <source>'StringBuilder.Append(char)' is more efficient than 'StringBuilder.Append(string)' when the string is a single character. When calling 'Append' with a constant, prefer using a constant char rather than a constant string containing one character.</source>
        <target state="translated">'StringBuilder.Append(char)' è più efficace di 'StringBuilder.Append(string)' quando la stringa è un carattere singolo. Se si chiama 'Append' con una costante, è preferibile usare un tipo di dati char costante invece di uno stringa contenente un solo carattere.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderMessage">
        <source>Use 'StringBuilder.Append(char)' instead of 'StringBuilder.Append(string)' when the input is a constant unit string</source>
        <target state="translated">Usare 'StringBuilder.Append(char)' invece di 'StringBuilder.Append(string)' quando l'input è una stringa costante composta da un solo carattere</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderTitle">
        <source>Consider using 'StringBuilder.Append(char)' when applicable</source>
        <target state="translated">Se applicabile, provare a usare 'StringBuilder.Append(char)'</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagDescription">
        <source>'Enum.HasFlag' method expects the 'enum' argument to be of the same 'enum' type as the instance on which the method is invoked and that this 'enum' is marked with 'System.FlagsAttribute'. If these are different 'enum' types, an unhandled exception will be thrown at runtime. If the 'enum' type is not marked with 'System.FlagsAttribute' the call will always return 'false' at runtime.</source>
        <target state="translated">Con il metodo 'Enum.HasFlag' l'argomento 'enum'deve essere dello stesso tipo 'enum' dell'istanza in cui viene chiamato il metodo e questo 'enum' deve essere contrassegnato con 'System.FlagsAttribute'. Se si tratta di tipi 'enum' diversi, verrà generata un'eccezione non gestita in fase di runtime. Se il tipo 'enum' non è contrassegnato con 'System.FlagsAttribute', la chiamata restituirà sempre 'false' in fase di runtime.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagMessageDifferentType">
        <source>The argument type, '{0}', must be the same as the enum type '{1}'</source>
        <target state="translated">Il tipo di argomento '{0}' deve essere uguale al tipo enumerazione '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagTitle">
        <source>Provide correct 'enum' argument to 'Enum.HasFlag'</source>
        <target state="translated">Specificare l'argomento 'enum' corretto per 'Enum.HasFlag'</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">L'argomento format passato a System.String.Format non contiene un elemento di formato corrispondente a ogni argomento dell'oggetto o viceversa.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Fornire gli argomenti corretti ai metodi di formattazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Fornire gli argomenti corretti ai metodi di formattazione</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsDescription">
        <source>A type has a field that is marked by using the System.Runtime.Serialization.OptionalFieldAttribute attribute, and the type does not provide deserialization event handling methods.</source>
        <target state="translated">Un tipo include un campo contrassegnato usando l'attributo System.Runtime.Serialization.OptionalFieldAttribute e non fornisce metodi di gestione degli eventi di deserializzazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserialized">
        <source>Add a 'private void OnDeserialized(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializedAttribute</source>
        <target state="translated">Aggiungere un metodo 'private void OnDeserialized(StreamingContext)' al tipo {0} e impostarvi l'attributo System.Runtime.Serialization.OnDeserializedAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserializing">
        <source>Add a 'private void OnDeserializing(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializingAttribute</source>
        <target state="translated">Aggiungere un metodo 'private void OnDeserializing(StreamingContext)' al tipo {0} e impostarvi l'attributo System.Runtime.Serialization.OnDeserializingAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsTitle">
        <source>Provide deserialization methods for optional fields</source>
        <target state="translated">Fornire metodi di deserializzazione per i campi facoltativi</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorDescription">
        <source>Providing a public parameterless constructor for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions.</source>
        <target state="new">Providing a public parameterless constructor for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorMessage">
        <source>Provide a public parameterless constructor for the '{0}' type that is derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="new">Provide a public parameterless constructor for the '{0}' type that is derived from 'System.Runtime.InteropServices.SafeHandle'</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorTitle">
        <source>Provide a public parameterless constructor for concrete types derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="new">Provide a public parameterless constructor for concrete types derived from 'System.Runtime.InteropServices.SafeHandle'</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesDescription">
        <source>To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods.</source>
        <target state="new">To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesMessage">
        <source>'{0}' overrides array-based '{1}' but does not override memory-based '{2}'. Consider overriding memory-based '{2}' to improve performance.</source>
        <target state="new">'{0}' overrides array-based '{1}' but does not override memory-based '{2}'. Consider overriding memory-based '{2}' to improve performance.</target>
        <note>0 = type that subclasses Stream directly, 1 = array-based method, 2 = memory-based method</note>
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesTitle">
        <source>Provide memory-based overrides of async methods when subclassing 'Stream'</source>
        <target state="new">Provide memory-based overrides of async methods when subclassing 'Stream'</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantCall">
        <source>Remove redundant call</source>
        <target state="translated">Rimuovi la chiamata ridondante</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplaceStringLiteralWithCharLiteralCodeActionTitle">
        <source>Replace string literal with char literal</source>
        <target state="new">Replace string literal with char literal</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsDescription">
        <source>An exception is rethrown and the exception is explicitly specified in the throw statement. If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</source>
        <target state="translated">Viene generata di nuovo un'eccezione, specificata in modo esplicito nell'istruzione throw. Se viene generata di nuovo un'eccezione specificandola nell'istruzione throw, l'elenco di chiamate del metodo tra il metodo originale che ha generato l'eccezione e il metodo corrente viene perso.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Eseguire il rethrow per conservare i dettagli dello stack</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Eseguire il rethrow per conservare i dettagli dello stack</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesMessage">
        <source>Potential DLL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo DLL injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesTitle">
        <source>Review code for DLL injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo DLL injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesMessage">
        <source>Potential file path injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo file path injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesTitle">
        <source>Review code for file path injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo file path injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesMessage">
        <source>Potential information disclosure vulnerability was found where '{0}' in method '{1}' may contain unintended information from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo diffusione di informazioni in cui '{0}' nel metodo '{1}' può contenere informazioni non intenzionali di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesTitle">
        <source>Review code for information disclosure vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo diffusione di informazioni</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesMessage">
        <source>Potential LDAP injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo LDAP injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesTitle">
        <source>Review code for LDAP injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo LDAP injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesMessage">
        <source>Potential open redirect vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo reindirizzamento aperto in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesTitle">
        <source>Review code for open redirect vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo reindirizzamento aperto</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesMessage">
        <source>Potential process command injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo process command injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesTitle">
        <source>Review code for process command injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo process command injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesMessage">
        <source>Potential regex injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo regex injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesTitle">
        <source>Review code for regex injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo regex injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesMessage">
        <source>Potential SQL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo SQL injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesTitle">
        <source>Review code for SQL injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo SQL injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesMessage">
        <source>Potential XAML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo XAML injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesTitle">
        <source>Review code for XAML injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo XAML injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesMessage">
        <source>Potential XML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo XML injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesTitle">
        <source>Review code for XML injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo XML injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesMessage">
        <source>Potential XPath injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo XPath injection in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesTitle">
        <source>Review code for XPath injection vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo XPath injection</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesMessage">
        <source>Potential cross-site scripting (XSS) vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">È stata trovata una potenziale vulnerabilità di tipo cross-site scripting (XSS) in cui '{0}' nel metodo '{1}' può essere contaminato da dati controllati dall'utente di '{2}' nel metodo '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesTitle">
        <source>Review code for XSS vulnerabilities</source>
        <target state="translated">Esaminare il codice per verificare la presenza di vulnerabilità di tipo XSS</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesDescription">
        <source>SQL queries that directly use user input can be vulnerable to SQL injection attacks. Review this SQL query for potential vulnerabilities, and consider using a parameterized SQL query.</source>
        <target state="translated">Le query SQL che usano direttamente l'input utente possono essere vulnerabili ad attacchi SQL injection. Esaminare la query SQL per individuare potenziali vulnerabilità e provare a usare una query SQL con parametri.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesMessageNoNonLiterals">
        <source>Review if the query string passed to '{0}' in '{1}', accepts any user input</source>
        <target state="translated">Verificare se la stringa di query passata a '{0}' in '{1}' accetta input utente</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesTitle">
        <source>Review SQL queries for security vulnerabilities</source>
        <target state="translated">Controllare l'eventuale vulnerabilità di sicurezza delle query SQL</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodDeclaredOnImplementationType">
        <source>Mark method as sealed</source>
        <target state="new">Mark method as sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookie">
        <source>Set HttpOnly to true for HttpCookie</source>
        <target state="translated">Impostare HttpOnly su true per HttpCookie</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieDescription">
        <source>As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies.</source>
        <target state="translated">Come ulteriore misura di difesa, assicurarsi che i cookie HTTP sensibili alla sicurezza siano contrassegnati come HttpOnly. In questo modo il Web browser non consentirà agli script di accedere ai cookie. Il modo più comune per appropriarsi dei cookie consiste nell'usare script in cui viene inserito codice dannoso.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieMessage">
        <source>HttpCookie.HttpOnly is set to false or not set at all when using an HttpCookie. Ensure security sensitive cookies are marked as HttpOnly to prevent malicious scripts from stealing the cookies</source>
        <target state="translated">HttpCookie.HttpOnly è impostato su false o non è impostato affatto quando si usa un elemento HttpCookie. Assicurarsi che i cookie sensibili alla sicurezza siano contrassegnati come HttpOnly per impedire a script dannosi di appropriarsi dei cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">Impostare ViewStateUserKey per classi derivate da Page</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">La proprietà ViewStateUserKey permette di evitare attacchi all'applicazione grazie all'assegnazione di un identificatore alla variabile dello stato di visualizzazione per singoli utenti per impedire che usino la variabile per generare un attacco. In caso contrario, potrebbero riscontrarsi vulnerabilità di tipo richiesta intersito falsa.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The class {0} derived from System.Web.UI.Page does not set the ViewStateUserKey property in the OnInit method or Page_Init method</source>
        <target state="translated">La classe {0}, derivata da System.Web.UI.Page, non imposta la proprietà ViewStateUserKey nel metodo OnInit o Page_Init</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">Un metodo o un costruttore chiama un membro con un overload che accetta un parametro System.Globalization.CultureInfo e tale metodo o costruttore non chiama l'overload che accetta il parametro CultureInfo. Quando non viene fornito un oggetto CultureInfo o System.IFormatProvider, l'effetto del valore predefinito fornito dal membro di overload potrebbe non essere quello desiderato in tutte le impostazioni locali. Se il risultato verrà visualizzato all'utente, specificare 'CultureInfo.CurrentCulture' come parametro di 'CultureInfo'. In caso contrario, se il risultato verrà archiviato e usato dal software, ad esempio quando viene salvato in modo permanente nel disco o in un database, specificare 'CultureInfo.InvariantCulture'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Il comportamento di '{0}' potrebbe variare a seconda delle impostazioni locali dell'utente corrente. Sostituire questa chiamata in '{1}' con una chiamata a '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">Specificare CultureInfo</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">Un metodo o un costruttore chiama uno o più membri con overload che accettano un parametro System.IFormatProvider e tale metodo o costruttore non chiama l'overload che accetta il parametro IFormatProvider. Quando non viene fornito un oggetto System.Globalization.CultureInfo o IFormatProvider, l'effetto del valore predefinito fornito dal membro di overload potrebbe non essere quello desiderato in tutte le impostazioni locali. Se il risultato verrà basato sull'input fornito o sull'output visualizzato all'utente, specificare 'CultureInfo.CurrentCulture' come parametro di 'IFormatProvider'. In caso contrario, se il risultato verrà archiviato e usato dal software, ad esempio quando viene caricato dal disco/database e quando viene salvato in modo permanente nel disco/database, specificare 'CultureInfo.InvariantCulture'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Il comportamento di '{0}' potrebbe variare a seconda delle impostazioni locali dell'utente corrente. Sostituire questa chiamata in '{1}' con una chiamata a '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Il comportamento di '{0}' potrebbe variare a seconda delle impostazioni locali dell'utente corrente. Sostituire questa chiamata in '{1}' con una chiamata a '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">'{0}' passa '{1}' come parametro di 'IFormatProvider' a '{2}'. Questa proprietà restituisce impostazioni cultura non appropriate per i metodi di formattazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">'{0}' passa '{1}' come parametro di 'IFormatProvider' a '{2}'. Questa proprietà restituisce impostazioni cultura non appropriate per i metodi di formattazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">Specificare IFormatProvider</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">Un membro di platform invoke consente chiamanti parzialmente attendibili, include un parametro di tipo stringa e non esegue il marshalling della stringa. Questo può comportare una potenziale vulnerabilità di sicurezza.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageField">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, ensure ThrowOnUnmappableChar is on.</source>
        <target state="translated">Per ridurre i problemi di sicurezza, eseguire il marshalling del campo {0} come Unicode impostando StructLayout.CharSet in {1} su CharSet.Unicode o eseguendo in modo esplicito il marshalling del campo come UnmanagedType.LPWStr. Se è necessario eseguire il marshalling della stringa come ANSI o dipendente da sistema, usare l'attributo BestFitMapping per disattivare il mapping più appropriato. Per maggiore sicurezza, assicurarsi che ThrowOnUnmappableChar sia attivato.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageFieldImplicitAnsi">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, to turn ThrowOnUnmappableChar on.</source>
        <target state="translated">Per ridurre i problemi di sicurezza, eseguire il marshalling del campo {0} come Unicode impostando StructLayout.CharSet in {1} su CharSet.Unicode o eseguendo in modo esplicito il marshalling del campo come UnmanagedType.LPWStr. Per eseguire il marshalling della stringa come ANSI o dipendente da sistema, specificare in modo esplicito MarshalAs, usare l'attributo BestFitMapping per disattivare il mapping più appropriato. Per maggiore sicurezza, assicurarsi che ThrowOnUnmappableChar sia attivato.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameter">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Per ridurre i problemi di sicurezza, eseguire il marshalling del parametro {0} come Unicode impostando DllImport.CharSet su CharSet.Unicode o eseguendo in modo esplicito il marshalling del parametro come UnmanagedType.LPWStr. Se è necessario eseguire il marshalling della stringa come ANSI o dipendente da sistema, impostare BestFitMapping=false. Per maggiore sicurezza, impostare anche ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameterImplicitAnsi">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, and set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Per ridurre i problemi di sicurezza, eseguire il marshalling del parametro {0} come Unicode impostando DllImport.CharSet su CharSet.Unicode o eseguendo in modo esplicito il marshalling del parametro come UnmanagedType.LPWStr. Se è necessario eseguire il marshalling della stringa come ANSI o dipendente da sistema, specificare in modo esplicito MarshalAs e impostare BestFitMapping=false. Per maggiore sicurezza, impostare anche ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">Specificare il marshalling per gli argomenti stringa P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. It is recommended to use the overload with StringComparison parameter for clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">In un'operazione di confronto di stringhe si usa un overload del metodo che non imposta un parametro StringComparison. Per chiarire meglio la finalità, è consigliabile usare l'overload con il parametro StringComparison. Se il risultato verrà visualizzato all'utente, ad esempio quando si ordina un elenco di elementi per la visualizzazione in una casella di riepilogo, specificare 'StringComparison.CurrentCulture' o 'StringComparison.CurrentCultureIgnoreCase' come parametro di 'StringComparison'. Se si confrontano identificatori che non fanno distinzione tra maiuscole/minuscole, ad esempio percorsi file, variabili di ambiente o chiavi e valori del Registro di sistema, specificare 'StringComparison.OrdinalIgnoreCase'. Se invece si confrontano identificatori che fanno distinzione tra maiuscole e minuscole, specificare 'StringComparison.Ordinal'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Message">
        <source>'{0}' has a method overload that takes a 'StringComparison' parameter. Replace this call in '{1}' with a call to '{2}' for clarity of intent.</source>
        <target state="translated">'{0}' contiene un overload di metodo che accetta un parametro 'StringComparison'. Per chiarire meglio la finalità, sostituire questa chiamata in '{1}' con una chiamata a '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Title">
        <source>Specify StringComparison for clarity</source>
        <target state="translated">Specificare StringComparison per la chiarezza</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter, hence its behavior could vary based on the current user's locale settings. It is strongly recommended to use the overload with StringComparison parameter for correctness and clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">In un'operazione di confronto di stringhe si usa un overload del metodo che non imposta un parametro StringComparison, di conseguenza il relativo comportamento potrebbe variare in base alle impostazioni locali dell'utente corrente. Per garantire la correttezza e chiarire meglio la finalità, è fortemente consigliato l'uso dell'overload con il parametro StringComparison. Se il risultato verrà visualizzato all'utente, ad esempio quando si ordina un elenco di elementi per la visualizzazione in una casella di riepilogo, specificare 'StringComparison.CurrentCulture' o 'StringComparison.CurrentCultureIgnoreCase' come parametro di 'StringComparison'. Se si confrontano identificatori che non fanno distinzione tra maiuscole/minuscole, ad esempio percorsi file, variabili di ambiente o chiavi e valori del Registro di sistema, specificare 'StringComparison.OrdinalIgnoreCase'. Se invece si confrontano identificatori che fanno distinzione tra maiuscole e minuscole, specificare 'StringComparison.Ordinal'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Message">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Il comportamento di '{0}' potrebbe variare a seconda delle impostazioni locali dell'utente corrente. Sostituire questa chiamata in '{1}' con una chiamata a '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Title">
        <source>Specify StringComparison for correctness</source>
        <target state="translated">Specificare StringComparison per la correttezza</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">Il confronto di stringhe è notevolmente più rapido se si usa la proprietà String.Length o il metodo String.IsNullOrEmpty invece di Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check</source>
        <target state="translated">Testare le stringhe vuote con la proprietà 'string.Length' o il metodo 'string.IsNullOrEmpty' invece di usare una verifica di uguaglianza</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">Testare le stringhe vuote con la lunghezza di stringa</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">Questa espressione consente di testare un valore rispetto a Single.Nan o Double.Nan. Per testare il valore, usare Single.IsNan(Single) o Double.IsNan(Double).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">Testare i valori NaN in modo corretto</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">Testare i valori NaN in modo corretto</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">Usare Array.Empty</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is often unwanted when it is implicitly used as a Span or Memory value. Use the AsSpan method to avoid the copy.</source>
        <target state="translated">Con l'indicizzatore basato su Range su valori di matrice viene prodotta una copia della porzione richiesta della matrice. Questa copia è spesso indesiderata quando viene usata in modo implicito come valore di Span o Memory. Per evitare la copia, usare il metodo AsSpan.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerMessage">
        <source>Use '{0}' instead of the '{1}'-based indexer on '{2}' to avoid creating unnecessary data copies</source>
        <target state="translated">Usare '{0}' invece dell'indicizzatore basato su '{1}' su '{2}' per evitare la creazione di copie di dati non necessarie</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAStringCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on a string</source>
        <target state="translated">Usare `{0}` invece di indicizzatori basati su Range su una stringa</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAnArrayCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on an array</source>
        <target state="translated">Usare `{0}` invece di indicizzatori basati su Range su una matrice</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerTitle">
        <source>Use AsSpan or AsMemory instead of Range-based indexers when appropriate</source>
        <target state="translated">Se necessario, usare AsSpan o AsMemory invece di indicizzatori basati su Range</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfStringRangeIndexerDescription">
        <source>The Range-based indexer on string values produces a copy of requested portion of the string. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">Con l'indicizzatore basato su Range su valori di stringa viene prodotta una copia della porzione richiesta della stringa. Questa copia è in genere non necessaria quando viene usata in modo implicito come valore di ReadOnlySpan o ReadOnlyMemory. Per evitare la copia non necessaria, usare il metodo AsSpan.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanReadOnlyInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">Con l'indicizzatore basato su Range su valori di matrice viene prodotta una copia della porzione richiesta della matrice. Questa copia è in genere non necessaria quando viene usata in modo implicito come valore di ReadOnlySpan o ReadOnlyMemory. Per evitare la copia non necessaria, usare il metodo AsSpan.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryToken">
        <source>Use antiforgery tokens in ASP.NET Core MVC controllers</source>
        <target state="translated">Usare token antifalsificazione nei controller MVC ASP.NET Core</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenDescription">
        <source>Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</source>
        <target state="translated">La gestione di una richiesta POST, PUT, PATCH o DELETE senza la convalida di un token antifalsificazione può essere vulnerabile ad attacchi di tipo richiesta intersito falsa. In un attacco di questo tipo vengono inviate richieste dannose da un utente autenticato al controller MVC ASP.NET Core.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenMessage">
        <source>Method {0} handles a {1} request without performing antiforgery token validation. You also need to ensure that your HTML form sends an antiforgery token.</source>
        <target state="translated">Il metodo {0} gestisce una richiesta {1} senza eseguire la convalida del token antifalsificazione. È necessario assicurarsi anche che il modulo HTML invii un token antifalsificazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedCodeFixTitle">
        <source>Replace with 'CancellationToken.ThrowIfCancellationRequested'</source>
        <target state="new">Replace with 'CancellationToken.ThrowIfCancellationRequested'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedDescription">
        <source>'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has.</source>
        <target state="new">'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedMessage">
        <source>Use 'ThrowIfCancellationRequested' instead of checking 'IsCancellationRequested' and throwing 'OperationCanceledException'</source>
        <target state="new">Use 'ThrowIfCancellationRequested' instead of checking 'IsCancellationRequested' and throwing 'OperationCanceledException'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedTitle">
        <source>Use 'ThrowIfCancellationRequested'</source>
        <target state="new">Use 'ThrowIfCancellationRequested'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="translated">Usa criteri di accesso a livello di contenitore</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="translated">Non è specificato alcun identificatore di criterio di accesso, di conseguenza i token sono non revocabili.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS.</source>
        <target state="translated">Se possibile, provare a usare il controllo degli accessi in base al ruolo di Azure, invece della firma di accesso condiviso. Se è necessaria una firma di accesso condiviso, usare un criterio di accesso a livello di contenitore quando si crea la firma.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttribute">
        <source>Use DefaultDllImportSearchPaths attribute for P/Invokes</source>
        <target state="translated">Usare l'attributo DefaultDllImportSearchPaths per i P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeDescription">
        <source>By default, P/Invokes using DllImportAttribute probe a number of directories, including the current working directory for the library to load. This can be a security issue for certain applications, leading to DLL hijacking.</source>
        <target state="translated">Per impostazione predefinita, i P/Invoke che usano DllImportAttribute esaminano un certo numero di directory, tra cui la directory di lavoro corrente per la libreria da caricare. Per alcune applicazioni questo comportamento può costituire un problema di sicurezza che permette di assumere il controllo delle DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeMessage">
        <source>The method {0} didn't use DefaultDllImportSearchPaths attribute for P/Invokes.</source>
        <target state="translated">Il metodo {0} non ha usato l'attributo DefaultDllImportSearchPaths per i P/Invoke.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdDescription">
        <source>'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'.</source>
        <target state="new">'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdFix">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="new">Use 'Environment.CurrentManagedThreadId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdMessage">
        <source>Use 'Environment.CurrentManagedThreadId' instead of 'Thread.CurrentThread.ManagedThreadId'</source>
        <target state="new">Use 'Environment.CurrentManagedThreadId' instead of 'Thread.CurrentThread.ManagedThreadId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdTitle">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="new">Use 'Environment.CurrentManagedThreadId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdDescription">
        <source>'Environment.ProcessId' is simpler and faster than 'Process.GetCurrentProcess().Id'.</source>
        <target state="translated">'Environment.ProcessId' è più semplice e rapido rispetto a 'Process.GetCurrentProcess().Id'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdFix">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">Usare 'Environment.ProcessId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdMessage">
        <source>Use 'Environment.ProcessId' instead of 'Process.GetCurrentProcess().Id'</source>
        <target state="translated">Usare 'Environment.ProcessId' invece di 'Process.GetCurrentProcess().Id'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdTitle">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">Usare 'Environment.ProcessId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathDescription">
        <source>'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'.</source>
        <target state="new">'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathFix">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="new">Use 'Environment.ProcessPath'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathMessage">
        <source>Use 'Environment.ProcessPath' instead of 'Process.GetCurrentProcess().MainModule.FileName'</source>
        <target state="new">Use 'Environment.ProcessPath' instead of 'Process.GetCurrentProcess().MainModule.FileName'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathTitle">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="new">Use 'Environment.ProcessPath'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIndexer">
        <source>Use indexer</source>
        <target state="translated">Usare l'indicizzatore</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">Viene definito un metodo di chiamata del sistema operativo e nella libreria di classi .NET Framework è presente un metodo con funzionalità equivalente.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Usare equivalenti gestiti dell'API Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Usare equivalenti gestiti dell'API Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">In un'operazione di confronto tra stringhe di tipo non linguistico il parametro StringComparison non viene impostato su Ordinal o OrdinalIgnoreCase. L'impostazione esplicita del parametro su StringComparison.Ordinal o StringComparison.OrdinalIgnoreCase consente spesso di rendere il codice più veloce, corretto e affidabile.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparer">
        <source>{0} passes '{1}' as the 'StringComparer' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparer.Ordinal' or 'StringComparer.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} passa '{1}' come parametro 'StringComparer' a {2}. Per eseguire un confronto di tipo non linguistico, specificare 'StringComparer.Ordinal' o 'StringComparer.OrdinalIgnoreCase'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparison">
        <source>{0} passes '{1}' as the 'StringComparison' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparison.Ordinal' or 'StringComparison.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} passa '{1}' come parametro 'StringComparison' a {2}. Per eseguire un confronto di tipo non linguistico, specificare 'StringComparison.Ordinal' o 'StringComparison.OrdinalIgnoreCase'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal string comparison</source>
        <target state="translated">Usa il confronto di stringhe tra ordinali</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableDescription">
        <source>Enumerable.Count() potentially enumerates the sequence while a Length/Count property is a direct access.</source>
        <target state="translated">Enumerable.Count() enumera potenzialmente la sequenza mentre una proprietà Length/Count è un accesso diretto.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableMessage">
        <source>Use the "{0}" property instead of Enumerable.Count()</source>
        <target state="translated">Usare la proprietà "{0}" invece di Enumerable.Count()</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableTitle">
        <source>Use Length/Count property instead of Count() when available</source>
        <target state="translated">Usare la proprietà Length/Count invece di Count() quando disponibile</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="translated">Usa l'algoritmo RSA (Rivest-Shamir-Adleman) con dimensione di chiave sufficiente</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="translated">Gli algoritmi di crittografia sono vulnerabili agli attacchi di forza bruta quando si usa una dimensione di chiave troppo piccola.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">La dimensione di chiave dell'algoritmo di crittografia asimmetrica {0} è minore di 2048. Passare a un algoritmo RSA con dimensione di chiave minima pari a 2048 oppure a un algoritmo ECDH o ECDSA.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="translated">Le applicazioni disponibili tramite HTTPS devono usare cookie protetti.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">Usa SharedAccessProtocol.HttpsOnly</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">HTTPS crittografa il traffico di rete. Usare HttpsOnly, invece di HttpOrHttps, per garantire che il traffico di rete sia sempre crittografato ed evitare la divulgazione di dati sensibili.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly.</source>
        <target state="translated">Se possibile, provare a usare il controllo degli accessi in base al ruolo di Azure, invece della firma di accesso condiviso. Se è necessario usare una firma di accesso condiviso, specificare SharedAccessProtocol.HttpsOnly.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareCodeFixTitle">
        <source>Use 'string.Equals'</source>
        <target state="new">Use 'string.Equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareDescription">
        <source>It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero.</source>
        <target state="new">It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareMessage">
        <source>Use 'string.Equals' instead of comparing the result of 'string.Compare' to 0</source>
        <target state="new">Use 'string.Equals' instead of comparing the result of 'string.Compare' to 0</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareTitle">
        <source>Use 'string.Equals'</source>
        <target state="new">Use 'string.Equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatCodeFixTitle">
        <source>Use 'AsSpan' with 'string.Concat'</source>
        <target state="new">Use 'AsSpan' with 'string.Concat'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatDescription">
        <source>It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator.</source>
        <target state="new">It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatMessage">
        <source>Use span-based 'string.Concat' and 'AsSpan' instead of 'Substring'</source>
        <target state="new">Use span-based 'string.Concat' and 'AsSpan' instead of 'Substring'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatTitle">
        <source>Use span-based 'string.Concat'</source>
        <target state="new">Use span-based 'string.Concat'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersDescription">
        <source>'string.Contains(char)' is available as a better performing overload for single char lookup.</source>
        <target state="new">'string.Contains(char)' is available as a better performing overload for single char lookup.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.Contains(char)' instead of 'string.Contains(string)' when searching for a single character</source>
        <target state="new">Use 'string.Contains(char)' instead of 'string.Contains(string)' when searching for a single character</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersTitle">
        <source>Use char literal for a single character lookup</source>
        <target state="new">Use char literal for a single character lookup</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringDescription">
        <source>Platform compatibility analyzer requires a valid platform name and version.</source>
        <target state="new">Platform compatibility analyzer requires a valid platform name and version.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringInvalidVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Use a version with 2{2} parts for this platform.</source>
        <target state="new">Version '{0}' is not valid for platform '{1}'. Use a version with 2{2} parts for this platform.</target>
        <note>Version '7' is not valid for platform 'windows'. Use a version with 2-4 parts for this platform.</note>
      </trans-unit>
      <trans-unit id="UseValidPlatformStringNoVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Do not use versions for this platform.</source>
        <target state="new">Version '{0}' is not valid for platform '{1}'. Do not use versions for this platform.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringTitle">
        <source>Use valid platform string</source>
        <target state="new">Use valid platform string</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringUnknownPlatform">
        <source>The platform '{0}' is not a known platform name</source>
        <target state="new">The platform '{0}' is not a known platform name</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyDescription">
        <source>ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</source>
        <target state="translated">Gli elementi ValueTask restituiti da chiamate ai membri devono essere usati direttamente tramite await. Se si prova a utilizzare più volte un elemento ValueTask oppure ad accedere direttamente al risultato di un oggetto prima che sia realmente completato, potrebbe verificarsi eccezioni o danneggiamenti dei dati. Un elemento ValueTask ignorato è probabilmente indicativo di un bug funzionale e potrebbe influire negativamente sulle prestazioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_AccessingIncompleteResult">
        <source>ValueTask instances should not have their result directly accessed unless the instance has already completed. Unlike Tasks, calling Result or GetAwaiter().GetResult() on a ValueTask is not guaranteed to block until the operation completes. If you can't simply await the instance, consider first checking its IsCompleted property (or asserting it's true if you know that to be the case).</source>
        <target state="translated">Il risultato di istanze di ValueTask non deve essere accessibile direttamente a meno che l'istanza non sia già stata completata. Diversamente da Tasks, la chiamata di Result o GetAwaiter().GetResult() su un elemento ValueTask non ne garantisce il blocco fino al completamento dell'operazione. Se non è possibile attendere l'istanza, provare prima a controllarne la proprietà IsCompleted (o ad asserire che sia true se si è a conoscenza che lo sia).</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_DoubleConsumption">
        <source>ValueTask instances should only be consumed once, such as via an await. Consuming the same ValueTask instance multiple times can result in exceptions and data corruption.</source>
        <target state="translated">Le istanze di ValueTask devono essere utilizzate una sola volta, ad esempio tramite await. Se si utilizza più volte la stessa istanza di ValueTask, possono verificarsi eccezioni e danneggiamenti dei dati.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_General">
        <source>ValueTask instances returned from method calls should be directly awaited, returned, or passed as an argument to another method call. Other usage, such as storing an instance into a local or a field, is likely an indication of a bug, as ValueTask instances must only ever be consumed once.</source>
        <target state="translated">Le istanze di ValueTask restituite da chiamate a un metodo devono essere usate direttamente tramite await, restituite o passate come argomento a un'altra chiamata a un metodo. Se vengono utilizzate per altri scopi, ad esempio per l'archiviazione di un'istanza in una variabile locale o un campo, è probabile che si tratti di un bug, perché le istanze di ValueTask devono sempre essere utilizzate una sola volta.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_Unconsumed">
        <source>ValueTask instances returned from method calls should always be used, typically awaited. Not doing so often represents a functional bug, but even if it doesn't, it can result in degraded performance if the target method pools objects for use with ValueTasks.</source>
        <target state="translated">Le istanze di ValueTask restituite da chiamate a un metodo devono essere sempre usate, in genere tramite await. Se questa operazione non viene eseguita spesso, si tratta di un bug funzionale, ma anche se non lo è, può verificarsi un peggioramento delle prestazioni se il metodo di destinazione raggruppa oggetti da usare con elementi ValueTask.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyTitle">
        <source>Use ValueTasks correctly</source>
        <target state="translated">Usare correttamente gli elementi ValueTask</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">Quando si carica codice XML da dati non attendibili, potrebbero essere caricati riferimenti esterni pericolosi, che devono essere limitati usando un elemento XmlReader con un resolver sicuro oppure disabilitando l'elaborazione DTD.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader for 'DataSet.ReadXml()'</source>
        <target state="translated">Usa XmlReader per 'DataSet.ReadXml()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader for 'XmlSerializer.Deserialize()'</source>
        <target state="translated">Usa XmlReader per 'XmlSerializer.Deserialize()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader for 'XmlSchema.Read()'</source>
        <target state="translated">Usa XmlReader per 'XmlSchema.Read()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader for XmlValidatingReader constructor</source>
        <target state="translated">Usa XmlReader per il costruttore XmlValidatingReader</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader for XPathDocument constructor</source>
        <target state="translated">Usa XmlReader per il costruttore XPathDocument</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the '{0}.{1}' method is potentially unsafe. It may enable Document Type Definition (DTD) which can be vulnerable to denial of service attacks, or might use an XmlResolver which can be vulnerable to information disclosure. Use an overload that takes a XmlReader instance instead, with DTD processing disabled and no XmlResolver.</source>
        <target state="translated">Questo overload del metodo '{0}.{1}' è potenzialmente non sicuro. Può abilitare DTD (Document Type Definition), che può essere vulnerabile ad attacchi Denial of Service oppure usare un elemento XmlResolver che può essere vulnerabile alla diffusione di informazioni. Usare un overload che accetta un'istanza di XmlReader, con elaborazione DTD disabilitata e nessun elemento XmlResolver.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>