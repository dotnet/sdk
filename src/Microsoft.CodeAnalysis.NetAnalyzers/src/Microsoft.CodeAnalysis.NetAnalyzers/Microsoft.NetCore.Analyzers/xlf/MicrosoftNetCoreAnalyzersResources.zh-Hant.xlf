<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../MicrosoftNetCoreAnalyzersResources.resx">
    <body>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">將 'NonSerialized' 屬性新增至此欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">新增可序列化屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherMode">
        <source>Review cipher mode usage with cryptography experts</source>
        <target state="translated">與加密專家一同審查 Cipher 模式使用方式</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These cipher modes might be vulnerable to attacks. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">這些 Cipher 模式可能容易遭受攻擊。請考慮使用建議的模式 (CBC、CTS)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>Review the usage of cipher mode '{0}' with cryptography experts. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">與加密專家一同審查 Cipher 模式 '{0}' 的使用方式。請考慮使用建議的模式 (CBC、CTS)。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">屬性的字串常值參數並未正確剖析 URL、GUID 或版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'</source>
        <target state="translated">在 '{0}' 的建構函式中，將目前為 "{2}" 的引數值 '{1}'，變更為可正確剖析成 '{3}' 的值</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'</source>
        <target state="translated">在 '{0}' 的建構函式中，將目前為空字串 ("") 的引數值 '{1}'，變更為可正確剖析成 '{2}' 的值</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">屬性字串常值應正確剖析</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidConstArraysCodeFixTitle">
        <source>Extract to static readonly field</source>
        <target state="translated">解壓縮至靜態唯讀欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidConstArraysDescription">
        <source>Constant arrays passed as arguments are not reused when called repeatedly, which implies a new array is created each time. Consider extracting them to 'static readonly' fields to improve performance if the passed array is not mutated within the called method.</source>
        <target state="translated">重複呼叫時不會重複使用以引數傳遞的常數陣列，這表示每次都會建立新的陣列。如果傳遞的陣列在呼叫的方法中未變動，請考慮將它們解壓縮至 'static readonly' 欄位，以提升效能。</target>
        <note>{Locked="static readonly"}</note>
      </trans-unit>
      <trans-unit id="AvoidConstArraysMessage">
        <source>Prefer 'static readonly' fields over constant array arguments if the called method is called repeatedly and is not mutating the passed array</source>
        <target state="translated">如果重複以呼叫的方法進行呼叫且未變動傳遞的陣列，則優先使用 'static readonly' 欄位，而不是常數陣列引數</target>
        <note>{Locked="static readonly"}</note>
      </trans-unit>
      <trans-unit id="AvoidConstArraysTitle">
        <source>Avoid constant arrays as arguments</source>
        <target state="translated">避免常數陣列作為引數</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingDescription">
        <source>In many situations, logging is disabled or set to a log level that results in an unnecessary evaluation for this argument.</source>
        <target state="translated">在許多情況下，記錄會被停用或設定為某個記錄層級，這會導致此引數進行不必要的評估。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingMessage">
        <source>Evaluation of this argument may be expensive and unnecessary if logging is disabled</source>
        <target state="translated">如果停用記錄，則此引數的評估可能會非常昂貴且不必要</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingTitle">
        <source>Avoid potentially expensive logging</source>
        <target state="translated">避免潛在的昂貴記錄</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsDescription">
        <source>Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead. Single use 'JsonSerializerOptions' instances can substantially degrade the performance of your application.</source>
        <target state="translated">避免為每個序列化作業建立新的 'JsonSerializerOptions' 執行個體。改為快取並重新使用執行個體。單一使用 'JsonSerializerOptions' 執行個體可能會大幅降低應用程式的效能。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsMessage">
        <source>Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead.</source>
        <target state="translated">避免為每個序列化作業建立新的 'JsonSerializerOptions' 執行個體。改為快取並重新使用執行個體。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsTitle">
        <source>Cache and reuse 'JsonSerializerOptions' instances</source>
        <target state="translated">快取並重新使用 'JsonSerializerOptions' 執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersDescription">
        <source>Marshalling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshalling operation.</source>
        <target state="translated">封送處理 'StringBuilder' 一律都會建立原生緩衝區複本，因而導致單一封送處理作業出現多重配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersMessage">
        <source>Avoid 'StringBuilder' parameters for P/Invokes. Consider using a character buffer instead.</source>
        <target state="translated">請勿對 P/Invoke 使用 'StringBuilder' 參數。請考慮改用字元緩衝區。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersTitle">
        <source>Avoid 'StringBuilder' parameters for P/Invokes</source>
        <target state="translated">請勿對 P/Invoke 使用 'StringBuilder' 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadCodeFixTitle">
        <source>Use 'Stream.ReadExactly'</source>
        <target state="translated">使用 'Stream.ReadExactly'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadDescription">
        <source>A call to 'Stream.Read' may return fewer bytes than requested, resulting in unreliable code if the return value is not checked.</source>
        <target state="translated">呼叫 'Stream.Read' 傳回的位元組數可能少於要求的位元組，如果未檢查值，將導致程式碼不可靠。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadMessage">
        <source>Avoid inexact read with '{0}'</source>
        <target state="translated">避免使用 '{0}' 進行不精確的讀取</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadTitle">
        <source>Avoid inexact read with 'Stream.Read'</source>
        <target state="translated">避免使用 'Stream.Read' 行不精確的讀取。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">.NET Framework 類別庫可提供擷取自訂屬性的方法。根據預設，這些方法會搜尋屬性繼承階層。使用密封屬性可免於搜尋整個繼承階層，因而能提升效能。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">避免非密封屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">避免非密封屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">避免非必要長度為零的陣列配置。改為使用 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations</source>
        <target state="translated">避免長度為零的陣列配置</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">將未受信任的資料還原序列化時，若沒有使用 SerializationBinder 來限制已還原序列化物件圖中的物件類型，方法 '{0}' 就不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</source>
        <target state="translated">呼叫 BinaryFormatter.Deserialize 之前，請務必先設定 BinaryFormatter.Binder</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">將未受信任的資料還原序列化時，若沒有使用 SerializationBinder 來限制已還原序列化物件圖中的物件類型，方法 '{0}' 就不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetTitle">
        <source>Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</source>
        <target state="translated">未先設定 BinaryFormatter.Binder 之前，請勿呼叫 BinaryFormatter.Deserialize</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect BinaryFormatter deserialization without a SerializationBinder set, then disable rule CA2300, and enable rules CA2301 and CA2302.</source>
        <target state="translated">將不受信任的資料還原序列化時，方法 '{0}' 不安全。如果您需要改為偵測 BinaryFormatter 還原序列化，而不想要設定 SerializationBinder，則請停用規則 CA2300，並啟用規則 CA2301 和 CA2302。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">將不受信任的資料還原序列化時，方法 '{0}' 不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer BinaryFormatter</source>
        <target state="translated">請勿使用不安全的還原序列化程式 BinaryFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyDescription">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.</source>
        <target state="translated">'Buffer.BlockCopy' 應該有要針對 'count' 引數複製的位元組數。使用 'Array.Length' 可能不符合需要複製的位元組數。</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyLengthMessage">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.</source>
        <target state="translated">'Buffer.BlockCopy' 應該有要針對 'count' 引數複製的位元組數。使用 'Array.Length' 可能不符合需要複製的位元組數。</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyLengthTitle">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument</source>
        <target state="translated">'Buffer.BlockCopy' 應該有要針對 'count' 引數複製的位元組數</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).</source>
        <target state="translated">實作 Dispose 的方法，不會呼叫 GC.SuppressFinalize; 或未實作的 Dispose，會呼叫 GC.SuppressFinalize; 或方法會呼叫 GC.SuppressFinalize，並傳遞 'this' (Visual Basic 中為 Me) 以外的項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">將 {0} 變更為呼叫 {1}。如此一來，引進完成項的衍生類型即無須重新實作 'IDisposable' 就可呼叫它。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">將 {0} 變更為呼叫 {1}。如此一來，可避免在物件處置過後或不在範圍內時，產生不必要的完成項。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">{0} 於本身以外的其他項目上呼叫了 {1}。變更呼叫位置以傳遞 'this' (在 Visual Basic 中為 'Me')。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">{0} 呼叫了 {1}，但此方法通常只在 'IDisposable.Dispose' 的實作內呼叫。如需詳細資訊，請參閱 IDisposable 模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">Dispose 方法應該呼叫 SuppressFinalize</target>
        <note />
      </trans-unit>
      <trans-unit id="CommaSeparator">
        <source>, </source>
        <target state="translated">, </target>
        <note>Separator used for separating list of platform names: {API} is only supported on: {‘windows’, ‘browser’, ‘linux’}</note>
      </trans-unit>
      <trans-unit id="ConstantExpectedApplicationDescription">
        <source>ConstantExpected attribute is not applied correctly on the parameter.</source>
        <target state="translated">未在參數上正確套用 ConstantExpected 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedApplicationTitle">
        <source>Incorrect usage of ConstantExpected attribute</source>
        <target state="translated">ConstantExpected 屬性的用法不正確</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedAttributExpectedMessage">
        <source>The ConstantExpected attribute is required for the parameter due to the parent method annotation</source>
        <target state="translated">由於父方法註釋，參數需要 ConstantExpected 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedIncompatibleConstantTypeMessage">
        <source>The '{0}' value is not compatible with parameter type of '{1}'</source>
        <target state="translated">'{0}' 值與 '{1}' 的參數類型不相容</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvalidBoundsMessage">
        <source>The '{0}' value does not fit within the parameter value bounds of '{1}' to '{2}'</source>
        <target state="translated">'{0}' 值不符合 '{1}' 到 '{2}' 的參數值範圍</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvalidMessage">
        <source>The constant is not of the same '{0}' type as the parameter</source>
        <target state="translated">常數不是與參數相同的 '{0}' 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvertedRangeMessage">
        <source>The Min and Max values are inverted</source>
        <target state="translated">最小值和最大值會反轉</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedNotConstantMessage">
        <source>The argument should be a constant for optimal performance</source>
        <target state="translated">引數應為常數，以獲得最佳效能</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedNotSupportedMessage">
        <source>The '{0}' type is not supported for ConstantExpected attribute</source>
        <target state="translated">ConstantExpected 屬性不支援 '{0}' 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedOutOfBoundsMessage">
        <source>The constant does not fit within the value bounds of '{0}' to '{1}'</source>
        <target state="translated">常數不符合 '{0}' 到 '{1}' 的值範圍</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedUsageDescription">
        <source>The parameter expects a constant for optimal performance.</source>
        <target state="translated">參數需要常數，以獲得最佳效能。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedUsageTitle">
        <source>A constant is expected for the parameter</source>
        <target state="translated">預期參數為常數</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">還原序列化不受信任的輸入時，將 {0} 物件還原序列化並不安全。'{1}' 屬於或衍生自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type found in deserializable object graph</source>
        <target state="translated">在可還原序列化的物件圖形中，找到不安全的 DataSet 或 DataTable 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}. Ensure that the auto-generated type is never deserialized with untrusted data.</source>
        <target state="translated">以 IFormatter 形式的序列化程式，還原序列化不受信任的輸入時，還原序列化 {0} 物件並不安全。'{1}' 屬於或衍生自 {0}。請確認自動產生的類型一律不會還原序列化不受信任的資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in auto-generated serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">自動產生的可序列化類型中，出現的不安全 DataSet 或 DataTable，容易受到遠端程式碼執行攻擊</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">還原序列化不受信任的輸入時，將 {0} 物件還原序列化並不安全。'{1}' 屬於或衍生自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks</source>
        <target state="translated">還原序列化後之物件圖表中的 Unsafe DataSet 或 DataTable 容易受到遠端程式碼執行攻擊</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}.</source>
        <target state="translated">當使用採用 IFormatter 之序列化程式還原序列化不信任的輸入時，將 {0} 物件還原序列化並不安全。'{1}' 屬於或衍生自 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">可序列化類型中不安全的 DataSet 或 DataTable 容易受到遠端程式碼執行攻擊</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">還原序列化不受信任的輸入時，將 {0} 物件還原序列化並不安全。'{1}' 屬於或衍生自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type</source>
        <target state="translated">可序列化類型中不安全的 DataSet 或 DataTable</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">還原序列化不受信任的輸入時，將 {0} 物件還原序列化並不安全。'{1}' 屬於或衍生自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type in web deserializable object graph</source>
        <target state="translated">可還原序列化之物件圖形中不安全的 DataSet 或 DataTable 類型</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data. Make sure that auto-generated class containing the '{0}' call is not deserialized with untrusted data.</source>
        <target state="translated">還原序列化不受信任的資料時，方法 '{0}' 並不安全。請確定包含 '{0}' 呼叫的自動產生類別，不會還原序列化不受信任的資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedTitle">
        <source>Ensure auto-generated class containing DataSet.ReadXml() is not used with untrusted data</source>
        <target state="translated">請確認包含 DataSet.ReadXml() 的自動產生類別，不會與不受信任的資料一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">還原序列化不受信任的資料時，方法 '{0}' 不安全</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlTitle">
        <source>Do not use DataSet.ReadXml() with untrusted data</source>
        <target state="translated">使用 DataSet.ReadXml() 時請勿附上不受信任的資料</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">還原序列化不受信任的資料時，方法 '{0}' 不安全</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlTitle">
        <source>Do not use DataTable.ReadXml() with untrusted data</source>
        <target state="translated">使用 DataTable.ReadXml() 時請勿附上不受信任的資料</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheck">
        <source>HttpClients should enable certificate revocation list checks</source>
        <target state="translated">HttpClients 應啟用憑證撤銷清單檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheckMessage">
        <source>HttpClient is created without enabling CheckCertificateRevocationList</source>
        <target state="translated">已建立 HttpClient，但未啟用 CheckCertificateRevocationList</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="translated">請勿將憑證新增至根存放區</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="translated">將憑證新增至作業系統的受信任根憑證，會增加驗證非法憑證不正確的風險</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIV">
        <source>Do not use CreateEncryptor with non-default IV</source>
        <target state="translated">請勿使用具有非預設 IV 的 CreateEncryptor</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIVMessage">
        <source>Symmetric encryption uses non-default initialization vector, which could be potentially repeatable</source>
        <target state="translated">對稱式加密使用可能可重複的非預設初始化向量</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">在 ASP.Net Core 中使用安全 Cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">在設定 Cookie 時設定 CookieOptions.Secure = true</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCount">
        <source>Do Not Use Weak Key Derivation Function With Insufficient Iteration Count</source>
        <target state="translated">不要使用反覆運算計數不足的弱式金鑰衍生函數 (Key Derivation Function)</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCountMessage">
        <source>Use at least {0} iterations when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">當從密碼衍生密碼編譯金鑰時，請至少使用 {0} 個反覆項目。根據預設，Rfc2898DeriveByte 的 IterationCount 只有 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsDescription">
        <source>Older protocol versions of Transport Layer Security (TLS) are less secure than TLS 1.2 and TLS 1.3, and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk.</source>
        <target state="translated">較舊的通訊協定版本的傳輸層安全性 (TLS) 比 TLS 1.2 和 TLS 1.3 不安全，而且更可能有新的弱點。請避免較舊的通訊協定版本，以將風險降至最低。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsMessage">
        <source>Transport Layer Security protocol version '{0}' is deprecated.  Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">傳輸層安全性通訊協定版本 '{0}' 已淘汰。請使用 'None' 讓作業系統選擇版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsTitle">
        <source>Do not use deprecated SslProtocols values</source>
        <target state="translated">不要使用已淘汰的 SslProtocols 值</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivesFromPreviewClassMessage">
        <source>'{0}' derives from preview class '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}' 衍生自預覽類別 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivesFromPreviewClassMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' derives from preview class '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}' 衍生自預覽類別 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesDescription">
        <source>An assembly has to opt into preview features before using them.</source>
        <target state="translated">組合在使用前必須先加入預覽功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesMessage">
        <source>Using '{0}' requires opting into preview features. See {1} for more information.</source>
        <target state="translated">使用 '{0}' 必須加入預覽功能。如需詳細資訊，請參閱 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesMessageWithCustomMessagePlaceholder">
        <source>{2} Using '{0}' requires opting into preview features. See {1} for more information.</source>
        <target state="translated">{2} 使用 '{0}' 必須加入預覽功能。如需詳細資訊，請參閱 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesTitle">
        <source>This API requires opting into preview features</source>
        <target state="translated">此 API 需要加入預覽功能</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">實作 System.IDisposable 的類型，宣告的欄位會是也實作 IDisposable 的類型。該欄位的 Dispose 方法，並非由宣告類型的 Dispose 方法呼叫。若要修正此規則違規，如果由您負責配置及釋放由該欄位所保留的非受控資源，則請在會實作 IDisposable 的欄位類型欄位上，呼叫 Dispose。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>'{0}' contains field '{1}' that is of IDisposable type '{2}', but it is never disposed. Change the Dispose method on '{0}' to call Close or Dispose on this field.</source>
        <target state="translated">'{0}' 包含 IDisposable 類型 '{2}' 的欄位 '{1}'，但從未處置過該欄位。請變更 '{0}' 上的 Dispose 方法，在此欄位上呼叫 Close 或 Dispose。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">可處置的欄位應受到處置</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">實作 System.IDisposable 且有欄位會建議使用非受控資源的類型，不會實作完成項 (如 Object.Finalize 所述)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">可處置的類型應宣告完成項</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">可處置的類型應宣告完成項</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.</source>
        <target state="translated">實作 System.IDisposable 的類型，會繼承自也實作 IDisposable 的類型。但繼承類型的 Dispose 方法，並未呼叫父類型的 Dispose 方法。若要修正此規則違規，請在 Dispose 方法中呼叫 base.Dispose。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Ensure that method '{0}' calls '{1}' in all possible control flow paths</source>
        <target state="translated">確保方法 '{0}' 呼叫了所有可能控制流程路徑中的 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose methods should call base class dispose</source>
        <target state="translated">Dispose 方法應該呼叫基底類別處置</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</source>
        <target state="translated">如果未在可處置物件的所有參考都超出範圍前明確處置掉該物件，則該物件將在記憶體回收行程執行該物件的完成項時，於某個不定時間被處置掉。因為可能發生例外事件，導致物件的完成項無法執行，所以應改為明確處置掉物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">請使用建議的處置模式，確認會在所有路徑上，處置由 '{0}' 所建立的物件。在可能的情況下，請將建立包在 'using' 陳述式或 'using' 宣告內。否則，請使用 try-finally 模式，同時在 try 區域之前先宣告專用的區域變數，並在 'finally' 區域中的非 null 值上，設定無條件 Dispose 引動過程，比如 'x?.Dispose()'。如果 try 區域內已明確地處置了該物件，或是處置擁有權已轉移到另一個物件或方法，則請在這類作業之後，對區域變數指派 'null'，以避免在 'finally' 中發生雙重處置。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all exception paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">請使用建議的處置模式，確認會在所有例外狀況路徑上，處置由 '{0}' 所建立的物件。在可能的情況下，請將建立包在 'using' 陳述式或 'using' 宣告內。否則，請使用 try-finally 模式，同時在 try 區域之前先宣告專用的區域變數，並在 'finally' 區域中的非 null 值上，設定無條件 Dispose 引動過程，比如 'x?.Dispose()'。如果 try 區域內已明確地處置了該物件，或是處置擁有權已轉移到另一個物件或方法，則請在這類作業之後，對區域變數指派 'null'，以避免在 'finally' 中發生雙重處置。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedMessage">
        <source>Call System.IDisposable.Dispose on object created by '{0}' before all references to it are out of scope</source>
        <target state="translated">在 '{0}' 所建立的物件上，在所有參考 System.IDisposable.Dispose 的項目超出範圍前，呼叫 System.IDisposable.Dispose</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage">
        <source>Object created by '{0}' is not disposed along all exception paths. Call System.IDisposable.Dispose on the object before all references to it are out of scope.</source>
        <target state="translated">由 {0} 所建立的物件，並非隨著所有例外狀況路徑處置。於物件的所有參考之前呼叫 System.IDisposable.Dispose，超出範圍。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose objects before losing scope</source>
        <target state="translated">必須在超出範圍前處置物件</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPath">
        <source>Do Not Add Archive Item's Path To The Target File System Path</source>
        <target state="translated">請勿將封存項目的路徑新增到目標檔案系統路徑</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription">
        <source>When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</source>
        <target state="translated">從封存擷取檔案並使用封存項目的路徑時，請檢查路徑是否安全。封存路徑可以是相對路徑，可能導致從預期的檔案系統目標路徑外存取檔案系統，從而引發透過偷襲技術進行的惡意組態變更及遠端程式碼執行。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage">
        <source>When creating path for '{0} in method {1}' from relative archive item path to extract file and the source is an untrusted zip archive, make sure to sanitize relative archive item path '{2} in method {3}'</source>
        <target state="translated">在從相對封存項目路徑建立「方法 {1} 中的 {0}」路徑以擷取檔案，而且來源是未受信任的 ZIP 封存時，請務必處理相對封存項目路徑「方法 {3} 中的 {2}」</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">請勿利用 URL 新增結構描述</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">XmlSchemaCollection.Add 方法的此項多載，會在使用的 XML 讀取器執行個體上，從內部啟用 DTD 處理，然後使用 UrlResolver 解析外部 XML 實體。而結果就是會導致資訊外洩。攻擊者有可能會看到來自檔案系統或網路共用要進行機器處理 XML 的內容。此外，攻擊者也可將其用作為 DoS 向量。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">因為 Add 方法的此項多載可能解析了危險的外部參考，而有可能不安全</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesDescription">
        <source>By setting critical TokenValidationParameter validation delegates to true, important authentication safeguards are disabled which can lead to tokens from any issuer or expired tokens being wrongly validated.</source>
        <target state="translated">將重大的 TokenValidationParameter 驗證委派設定為 True 時，會停用重要的驗證保護，這可能會導致來自任何發行者或過期權杖的權杖遭到錯誤驗證。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesMessage">
        <source>The {0} is set to a function that is always returning true. By setting the validation delegate, you are overriding default validation and by always returning true, this validation is completely disabled.</source>
        <target state="translated">{0} 設定為永遠傳回 True 的函式。設定驗證委派之後，即會覆寫預設驗證，並因為永遠會傳回 True，表示已完全停用此驗證。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesTitle">
        <source>Do not always skip token validation in delegates</source>
        <target state="translated">永遠不要在委派中略過權杖驗證</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">不安全的還原序列化是一種弱點，會在有人使用未受信任的資料來不當使用應用程式的邏輯、發動拒絕服務的攻擊 (DoS)，甚至是在任何程式碼的還原序列化期間執行該程式碼時出現。惡意使用者經常會在應用程式將他們控制的未受信任資料還原序列化時，濫用這些還原序列化功能 (基本上就是在還原序列化期間叫用危險的方法)。不安全的還原序列化攻擊一旦成功，攻擊者就有機會發動後續攻擊，例如 DoS 攻擊、驗證略過和遠端程式碼執行。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class '{0}', method '{1}' can directly or indirectly call dangerous method '{2}'</source>
        <target state="translated">將類別 '{0}' 的執行個體還原序列化時，方法 '{1}' 可以直接或間接呼叫危險的方法 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationTitle">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">不要在還原序列化期間呼叫危險的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesDescription">
        <source>Enumerable.Cast&lt;T&gt; and Enumerable.OfType&lt;T&gt; require compatible types to function expectedly.  
The generic cast (IL 'unbox.any') used by the sequence returned by Enumerable.Cast&lt;T&gt; will throw InvalidCastException at runtime on elements of the types specified.  
The generic type check (C# 'is' operator/IL 'isinst') used by Enumerable.OfType&lt;T&gt; will never succeed with elements of types specified, resulting in an empty sequence.  
Widening and user defined conversions are not supported with generic types.</source>
        <target state="translated">Enumerable.Cast&lt;T&gt; 和 Enumerable.OfType&lt;T&gt; 需要相容的型別，以預期運作。 
Enumerable.Cast&lt;T&gt; 返回序列所使用的一般轉換 (IL 'unbox.any') 將在執行階段的指定型別元素上擲回 InvalidCastException。 
Enumerable.OfType&lt;T&gt; 使用的一般型別檢查 (C# 'is' operator/IL 'isinst') 永遠不會與指定的型別元素成功，因而產生空的順序。 
一般型別不支援擴大和使用者定義的轉換。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageCast">
        <source>Type '{0}' is incompatible with type '{1}' and cast attempts will throw InvalidCastException at runtime</source>
        <target state="translated">型別 '{0}' 與型別 '{1}' 不相容，轉換嘗試將在執行階段擲出 InvalidCastException</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageOfType">
        <source>This call will always result in an empty sequence because type '{0}' is incompatible with type '{1}'</source>
        <target state="translated">因為型別 '{0}' 與型別 '{1}' 不相容，所以此呼叫一定會產生空的順序</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesTitle">
        <source>Do not call Enumerable.Cast&lt;T&gt; or Enumerable.OfType&lt;T&gt; with incompatible types</source>
        <target state="translated">請勿呼叫型別不相容的 Enumerable.Cast&lt;T&gt; 或 Enumerable.OfType&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueMessage">
        <source>Do not call {0} on an {1} value</source>
        <target state="translated">請勿對 {1} 值呼叫 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueTitle">
        <source>Do not call ToImmutableCollection on an ImmutableCollection value</source>
        <target state="translated">請勿對 ImmutableCollection 值呼叫 TolmmutableCollection</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToDefaultMessage">
        <source>Comparing a span to 'default' might not do what you intended, make the code more explicit by checking 'IsEmpty'</source>
        <target state="translated">將範圍與 'default' 進行比較，可能無法達到您預期的效果，請檢查 'IsEmpty'，讓程式碼更加明確</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullIsEmptyCodeFixTitle">
        <source>Use 'IsEmpty'</source>
        <target state="translated">使用 'IsEmpty'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullMessage">
        <source>Comparing a span to 'null' might be redundant, the 'null' literal will be implicitly converted to a 'Span&lt;T&gt;.Empty'</source>
        <target state="translated">將範圍與 'null' 進行比較可能是多餘的，'null' 常值會隱含轉換為 'Span&lt;T&gt;.Empty'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullOrDefaultDescription">
        <source>Comparing a span to 'null' or 'default' might not do what you intended. 'default' and the 'null' literal are implicitly converted to 'Span&lt;T&gt;.Empty'. Remove the redundant comparison or make the code more explicit by using 'IsEmpty'.</source>
        <target state="translated">將範圍與 'null' 或 'default' 進行比較，可能無法達到您預期的效果。'default' 和 'null' 常值會隱含轉換為 'Span&lt;T&gt;.Empty'。移除多餘的比較，或使用 'IsEmpty' 讓程式碼更明確。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullOrDefaultTitle">
        <source>Do not compare Span&lt;T&gt; to 'null' or 'default'</source>
        <target state="translated">請勿將 Span&lt;T&gt; 與 'null' 或 'default' 進行比較</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsDescription">
        <source>TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.  Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</source>
        <target state="translated">TaskCompletionSource 有建構函式會採用控制基礎工作的 TaskCreationOptions，也有會採用儲存在工作內物件狀態的建構函式。不小心傳遞了 TaskContinuationOptions 而非 TaskCreationOptions 時，會導致呼叫將選項視為狀態。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsFix">
        <source>Replace TaskContinuationOptions with TaskCreationOptions.</source>
        <target state="translated">以 TaskCreationOptions 取代 TaskContinuationOptions。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsMessage">
        <source>Argument contains TaskContinuationsOptions enum instead of TaskCreationOptions enum</source>
        <target state="translated">引數內含 TaskContinuationsOptions 列舉，而非 TaskCreationOptions 列舉</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsTitle">
        <source>Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</source>
        <target state="translated">傳遞到 TaskCompletionSource 建構函式的引數應為 TaskCreationOptions 列舉，而非 TaskContinuationOptions 列舉</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerDescription">
        <source>Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear.</source>
        <target state="translated">建立工作時，請務必使用採用 TaskScheduler 的其中一個多載。預設會在 TaskScheduler.Current 上排程，但如此會造成死結。您可以使用 TaskScheduler.Default 在執行緒集區上進行排程，或明確傳遞 TaskScheduler.Current 以讓目的更加明確。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerMessage">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">建立工作時請務必傳遞 TaskScheduler</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerTitle">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">建立工作時請務必傳遞 TaskScheduler</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerDescription">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;.</source>
        <target state="translated">將完成項新增到衍生自 MemoryManager&lt;T&gt; 的類型時，可能會允許在 Span&lt;T&gt; 仍在使用記憶體時，釋出該記憶體。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerMessage">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;</source>
        <target state="translated">將完成項新增到衍生自 MemoryManager&lt;T&gt; 的型別時，可能會在 Span&lt;T&gt; 仍在使用記憶體時，允許釋出該記憶體</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerTitle">
        <source>Do not define finalizers for types derived from MemoryManager&lt;T&gt;</source>
        <target state="translated">請勿為衍生自 MemoryManager&lt;T&gt; 的類型定義完成項</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">請勿停用憑證驗證</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">憑證可協助驗證伺服器的身分識別。用戶端應該驗證伺服器憑證來確保要求會傳送到正確的伺服器。如果 ServerCertificateValidationCallback 一律傳回 'true'，則所有憑證都會通過驗證。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">ServerCertificateValidationCallback 已設定為會一律傳回 true 來接受所有伺服器憑證的函式。請確保伺服器憑證經過驗證，以驗證收到要求之伺服器的身分識別。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">請勿停用 HTTP 標頭檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">利用 HTTP 標頭檢查可編碼回應標頭中所發現的歸位字元與換行字元 (\r 與 \n)。此編碼方式有助於避開插入式攻擊，這類攻擊會惡意探索應用程式是否會回應標頭所包含的不受信任資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">請勿停用 HTTP 標頭檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHttpClientCRLCheckDescription">
        <source>Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid.</source>
        <target state="translated">當 CheckCertificateRevocationList 屬性設為 true 時，使用 HttpClient 而不提供平台特定處理常式 (WinHttpHandler 或 CurlHandler 或 HttpClientHandler)，將允許 HttpClient 接受已撤銷的憑證為有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">請勿停用要求驗證</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">要求驗證是 ASP.NET 中的功能，其會檢查 HTTP 要求，並會決定其是否包含具潛在危險性的內容。這項檢查對標記或程式碼的 URL 查詢字串、Cookie 或因惡意目的而可能新增的張貼表單值，提供更佳的安全性。因此，一般最好能使用，且應持續啟用以達到全面性防禦。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">{0} 已停用要求驗證</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">請勿停用 SChannel 使用強式加密</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommended to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">自 .NET Framework 4.6 起，即建議 System.Net.ServicePointManager 及 System.Net.Security.SslStream 類別使用新的通訊協定。舊款通訊協定中有通訊協定弱點，已不支援。將 Switch.System.Net.DontEnableSchUseStrongCrypto 設定為 true，將會使用舊的弱式密碼編譯檢查，並會選擇退出通訊協定移轉。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">{0} 停用 TLS 1.2 並啟用 SSLv3</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksDescription">
        <source>Token validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation.</source>
        <target state="translated">權杖驗證檢查可確保在驗證權杖時，分析並驗證所有方面。關閉驗證可能會造成安全性漏洞，因為可能會允許未受信任的權杖通過驗證。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksMessage">
        <source>TokenValidationParameters.{0} should not be set to false as it disables important validation</source>
        <target state="translated">TokenValidationParameters.{0} 不應設定為 False，因為它會停用重要驗證</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksTitle">
        <source>Do not disable token validation checks</source>
        <target state="translated">請勿停用權杖驗證檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsMessage">
        <source>Do not set Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols to true.  Setting this switch limits Windows Communication Framework (WCF) to using Transport Layer Security (TLS) 1.0, which is insecure and obsolete.</source>
        <target state="translated">不要將 Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols 設定為 true。設定此參數會限制 Windows Communication Framework (WCF) 使用不安全且已淘汰的傳輸層安全性 (TLS) 1.0。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsTitle">
        <source>Do not disable ServicePointManagerSecurityProtocols</source>
        <target state="translated">不要停用 ServicePointManagerSecurityProtocols</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyDescription">
        <source>Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'. The former already checks whether the key exists, and will not throw if it does not.</source>
        <target state="translated">請勿使用 'Dictionary.ContainsKey(key)' 保護 'Dictionary.Remove(key)'。前者已檢查金鑰是否存在，若沒有，則不會擲回。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyMessage">
        <source>Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'</source>
        <target state="translated">請勿使用 'Dictionary.ContainsKey(key)' 保護 'Dictionary.Remove(key)'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyTitle">
        <source>Unnecessary call to 'Dictionary.ContainsKey(key)'</source>
        <target state="translated">不需要呼叫 'Dictionary.ContainsKey(key)'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsDescription">
        <source>Do not guard 'Add(item)' or 'Remove(item)' with 'Contains(item)' for the set. The former two already check whether the item exists and will return if it was added or removed.</source>
        <target state="translated">請勿為集合使用 'Contains(item)' 來防護 'Add(item)' 或 'Remove(item)'。前兩者已檢查項目是否存在，並將在新增或移除項目時退回。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsMessage">
        <source>Do not guard '{0}' with '{1}'</source>
        <target state="translated">不要使用 '{1}' 來防護 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsTitle">
        <source>Unnecessary call to 'Contains(item)'</source>
        <target state="translated">對 'Contains(item)' 的不必要呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificate">
        <source>Do not hard-code certificate</source>
        <target state="translated">不要硬式編碼憑證</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateDescription">
        <source>Hard-coded certificates in source code are vulnerable to being exploited.</source>
        <target state="translated">原始程式碼中的硬式編碼憑證容易受到攻擊。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded certificate from '{2}' in method '{3}'</source>
        <target state="translated">發現潛在的安全性弱點，方法 '{1}' 中的 '{0}' 可能受來自方法 '{3}' 中 '{2}' 由硬式編碼的憑證所感染</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKey">
        <source>Do not hard-code encryption key</source>
        <target state="translated">不要硬式編碼加密金鑰</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyDescription">
        <source>SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hard-coded value.</source>
        <target state="translated">SymmetricAlgorithm 的 .Key 屬性，或方法的 rgbKey 參數不應為硬式編碼值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded key from '{2}' in method '{3}'</source>
        <target state="translated">發現潛在的安全性弱點，方法 '{1}' 中的 '{0}' 可能受來自方法 '{3}' 中 '{2}' 由硬式編碼的金鑰所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="translated">根據預設，信任的根憑證授權單位的憑證存放區，設定有一組符合 Microsoft 根憑證計劃需求的公開 CA。因為所有信任的根 CA，都可以為任何所有發出憑證，所以攻擊者可以挑選一個您自行安裝的弱式 CA 或強迫式 CA 來攻擊，而只要一個弱式、惡意或強迫式 CA，就會侵害整個系統的安全性。而且，這些攻擊還很可能輕易地就被忽略，而讓事情變得更糟。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">若可以跨應用程式定義域界限直接存取某個物件，該物件即為弱式識別。嘗試取得弱式識別物件的鎖定之執行緒，有可能會被具有相同物件鎖定之不同應用程式定義域中的第二個執行緒封鎖。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">請勿鎖定弱式識別的物件</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">請勿鎖定弱式識別的物件</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersDescription">
        <source>A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.</source>
        <target state="translated">方法會將字串常值以參數方式傳遞到 .NET Framework 類別庫中的建構函式或方法，且該字串應當地語系化。若要修正此規則的違規，請以透過 ResourceManager 類別的執行個體所擷取的字串，取代字串常值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersMessage">
        <source>Method '{0}' passes a literal string as parameter '{1}' of a call to '{2}'. Retrieve the following string(s) from a resource table instead: "{3}".</source>
        <target state="translated">方法 '{0}' 在呼叫 '{2}' 時傳遞了常值字串做為參數 '{1}'。請改為從資源表格擷取下列字串: "{3}"。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersTitle">
        <source>Do not pass literals as localized parameters</source>
        <target state="translated">不要將常值當做已當地語系化的參數傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullCodeFixTitle">
        <source>Remove superfluous 'ArgumentNullException.ThrowIfNull' call</source>
        <target state="translated">移除非必要的 'ArgumentNullException.ThrowIfNull' 呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullDescription">
        <source>'ArgumentNullException.ThrowIfNull' throws when the passed argument is 'null'. Certain constructs like non-nullable structs, 'nameof()' and 'new' expressions are known to never be null, so 'ArgumentNullException.ThrowIfNull' will never throw.</source>
        <target state="translated">傳遞的引數為 'null' 時，會擲回 'ArgumentNullException.ThrowIfNull'。已知某些建構一律不可為 Null，例如不可為 Null 的結構、'nameof()' 和 'new' 運算式，因此 'ArgumentNullException.ThrowIfNull' 永遠不會擲回。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullMessage">
        <source>Calling 'ArgumentNullException.ThrowIfNull' and passing a non-nullable value is a no-op</source>
        <target state="translated">呼叫 'ArgumentNullException.ThrowIfNull' 且傳遞不可為 Null 的值是無作業</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullTitle">
        <source>Do not pass a non-nullable value to 'ArgumentNullException.ThrowIfNull'</source>
        <target state="translated">請勿將不可為 Null 的值傳遞到 'ArgumentNullException.ThrowIfNull'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullCodeFixTitle">
        <source>Replace the 'ArgumentNullException.ThrowIfNull' call with a conditional</source>
        <target state="translated">以條件式取代 'ArgumentNullException.ThrowIfNull' 呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullDescription">
        <source>'ArgumentNullException.ThrowIfNull' accepts an 'object', so passing a nullable struct may cause the value to be boxed.</source>
        <target state="translated">'ArgumentNullException.ThrowIfNull' 接受 'object'，所以傳遞可為 Null 的結構可能導致值受到 box 處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullMessage">
        <source>Passing a nullable struct to 'ArgumentNullException.ThrowIfNull' may cause boxing</source>
        <target state="translated">將可為 Null 的結構傳遞至 'ArgumentNullException.ThrowIfNull' 可能會導致 boxing</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullTitle">
        <source>Do not pass a nullable struct to 'ArgumentNullException.ThrowIfNull'</source>
        <target state="translated">請勿將可為 Null 的結構傳遞到 'ArgumentNullException.ThrowIfNull'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">明確度不足或由執行階段所保留的例外狀況類型，一律不應由使用者程式碼引發。這會讓原始錯誤的偵測與偵錯更加困難。如果可能會擲回此例外狀況執行個體，請使用其他例外狀況類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime</source>
        <target state="translated">例外狀況型別 {0} 由執行階段所保留</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific</source>
        <target state="translated">例外狀況型別 {0} 不夠明確</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">請勿引發保留的例外狀況類型</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">請勿將類型序列化為指標欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">指標並非「安全類型」意味著您無法保證其所指向的記憶體是否正確。因此，指標欄位若為序列化類型很危險，因為如此可能會讓攻擊者能控制指標。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type</source>
        <target state="translated">可序列化型別上的指標欄位 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">不要使用帳戶共用存取簽章</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">共用存取簽章 (SAS) 對於使用 Azure 儲存體的任何應用程式而言，都是資訊安全模型至關重要的一部份，應向不具帳戶金鑰的用戶端提供儲存體帳戶有限且安全的權限。只要是可以透過服務 SAS 提供的作業，就也可以透過帳戶 SAS 提供，這意味著帳戶 SAS 的權限過大。因此建議您使用服務 SAS，更謹慎地委派存取權。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">請使用服務 SAS 而非帳戶 SAS，以執行微調的存取控制和容器層級存取原則</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">請勿使用損壞的密碼編譯演算法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">目前出現可用運算方式中斷此演算法的攻擊。如此會讓攻擊者能破壞原設計保證提供的密碼編譯。視此密碼編譯演算法的類型及應用方式之不同，會讓攻擊者能讀取加密的訊息、竄改加密的訊息、偽造數位簽章、竄改雜湊內容，或危害任何以此演算法為基礎的密碼系統。以長度大於或等於 128 位元的金鑰，取代搭配 AES (可接受 AES-256、AES-192 和 AES-128) 演算法的加密。以 SHA512、SHA384 或 SHA256 等 SHA-2 系列中的雜湊函數，取代雜湊用法。以長度大於或等於 2048 位元的金鑰，或金鑰長度大於或等於 256 位元的 ECDSA，取代搭配 RSA 的數位簽章。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">{0} 使用損壞的密碼編譯演算法 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingDescription">
        <source>The ConfigureAwaitOptions.SuppressThrowing option is only supported with the non-generic Task, not a Task&lt;TResult&gt;.  To use it with a Task&lt;TResult&gt;, first cast to the base Task.</source>
        <target state="translated">ConfigureAwaitOptions.SuppressThrowing 選項只支援非一般工作，不支援 Task&lt;TResult&gt;。 若要與 Task&lt;TResult&gt; 一起使用，請先強制型轉到基本任務。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingMessage">
        <source>The ConfigureAwaitOptions.SuppressThrowing option is only supported with the non-generic Task</source>
        <target state="translated">ConfigureAwaitOptions.SuppressThrowing 選項只支援非一般工作</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingTitle">
        <source>Do not use ConfigureAwaitOptions.SuppressThrowing with Task&lt;TResult&gt;</source>
        <target state="translated">請勿使用 ConfigureAwaitOptions.SuppressThrowing 與 Task&lt;TResult&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedDescription">
        <source>For non-empty collections, CountAsync() and LongCountAsync() enumerate the entire sequence, while AnyAsync() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">對於非空白集合，CountAsync() 和 LongCountAsync() 會列舉整個序列，而 AnyAsync() 則會停止於第一個項目或第一個符合條件的項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedMessage">
        <source>{0}() is used where AnyAsync() could be used instead to improve performance</source>
        <target state="translated">會在可使用 AnyAsync() 的地方改用 {0}() 來提升效能</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedTitle">
        <source>Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used</source>
        <target state="translated">不要在可使用 AnyAsync() 時使用 CountAsync() 或 LongCountAsync()</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedDescription">
        <source>For non-empty collections, Count() and LongCount() enumerate the entire sequence, while Any() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">對於非空白集合，Count() 和 LongCount() 會列舉整個序列，而 Any() 則會停止於第一個項目或第一個符合條件的項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedMessage">
        <source>{0}() is used where Any() could be used instead to improve performance</source>
        <target state="translated">會在可使用 Any() 的地方改用 {0}() 來提升效能</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedTitle">
        <source>Do not use Count() or LongCount() when Any() can be used</source>
        <target state="translated">若可以使用 Any()，就不要使用 Count() 來提高效能</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCreateEncryptorWithNonDefaultIVDescription">
        <source>Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</source>
        <target state="translated">對稱式加密應永遠使用不可重複的初始化向量以防止字典攻擊。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="translated">請勿使用數位簽章演算法 (DSA)</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="translated">DSA 太弱，所以無法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">非對稱式加密演算法 {0} 是弱式加密。請改為至少有 2048 金鑰大小的 RSA、ECDH 或 ECDSA 演算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">請勿使用已淘汰的安全性通訊協定</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">使用了已淘汰的安全性通訊協定而非系統預設值，相當具風險。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">硬式編碼使用了已淘汰的安全性通訊協定 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsDescription">
        <source>The property 'StreamReader.EndOfStream' can cause unintended synchronous blocking when no data is buffered. Instead, use 'StreamReader.ReadLineAsync' directly, which returns 'null' when reaching the end of the stream.</source>
        <target state="translated">沒有緩衝資料時，屬性 'StreamReader.EndOfStream' 可能會導致意外的同步封鎖。相反地，請直接使用 'StreamReader.ReadLineAsync'，當到達資料流的結尾時，它會傳回 'null'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsMessage">
        <source>Do not use '{0}' in an async method</source>
        <target state="translated">請勿在非同步方法中使用 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsTitle">
        <source>Do not use 'StreamReader.EndOfStream' in async methods</source>
        <target state="translated">請勿在非同步方法中使用 'StreamReader.EndOfStream'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">此集合是可直接編製索引的集合。完成此處的 LINQ 會導致不必要的配置與 CPU 工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly.</source>
        <target state="translated">請勿在可索引的集合上，使用 Enumerable 方法。改為直接使用集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections</source>
        <target state="translated">請勿在可索引的集合上，使用 Enumerable 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomness">
        <source>Do not use insecure randomness</source>
        <target state="translated">不要使用不安全的隨機性</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessDescription">
        <source>Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated. Use a cryptographically strong random number generator if an unpredictable value is required, or ensure that weak pseudo-random numbers aren't used in a security-sensitive manner.</source>
        <target state="translated">使用密碼編譯弱式虛擬亂數產生器可能會讓攻擊者得以預測將要產生的安全性敏感性值。如果需要無法預測的值，或是要確保未以安全性敏感性方式使用弱式虛擬亂數時，請使用密碼編譯強式亂數產生器。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessMessage">
        <source>{0} is an insecure random number generator. Use cryptographically secure random number generators when randomness is required for security.</source>
        <target state="translated">{0} 是不安全的亂數產生器。當安全性需要隨機性時，請使用密碼編譯安全性亂數產生器。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">請勿使用已淘汰的金鑰衍生函數</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">以密碼為基礎的金鑰衍生應搭配 SHA-2 使用 PBKDF2。請避免使用 PasswordDeriveBytes，因為這會產生 PBKDF1 金鑰。請避免使用 Rfc2898DeriveBytes.CryptDeriveKey，因為其未使用反覆運算次數或 Salt。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">呼叫已淘汰的金鑰衍生函數 {0}.{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersDescription">
        <source>String parameters passed by value with the 'OutAttribute' can destabilize the runtime if the string is an interned string.</source>
        <target state="translated">如果字串是暫留字串，則使用 'OutAttribute' 以值傳遞的字串參數可能會造成執行階段不穩定。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersMessage">
        <source>Do not use the 'OutAttribute' for string parameter '{0}' which is passed by value. If marshalling of modified data back to the caller is required, use the 'out' keyword to pass the string by reference instead.</source>
        <target state="translated">請勿對以值傳遞的字串參數 '{0}' 使用 'OutAttribute'。如果需要將已修改的資料封送處理至呼叫者，請改用 'out' 關鍵字以傳址方式傳遞字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersTitle">
        <source>Do not use 'OutAttribute' on string parameters for P/Invokes</source>
        <target state="translated">請勿在 P/Invoke 的字串參數上使用 'OutAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesComparerMessage">
        <source>Do not pass an argument with value type '{0}' to the 'Equals' method on 'ReferenceEqualityComparer'. Due to value boxing, this call to 'Equals' can return an unexpected result. Consider using 'EqualityComparer' instead, or pass reference type arguments if you intend to use 'ReferenceEqualityComparer'.</source>
        <target state="translated">請勿將數值型別為 '{0}' 的引數傳遞至 'ReferenceEqualityComparer' 上的 'Equals' 方法。由於值 Boxing，這個對 'Equals' 的呼叫可能會返回未預期的結果。如果您想要使用 'ReferenceEqualityComparer'，請考慮改為使用 'EqualityComparer'，或傳遞參考型別引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesDescription">
        <source>Value type typed arguments are uniquely boxed for each call to this method, therefore the result can be unexpected.</source>
        <target state="translated">每次呼叫此方法時，實值型別所輸入的引數，都是經過 Box 的唯一值，因此其結果可以是未預期的。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesMethodMessage">
        <source>Do not pass an argument with value type '{0}' to 'ReferenceEquals'. Due to value boxing, this call to 'ReferenceEquals' can return an unexpected result. Consider using 'Equals' instead, or pass reference type arguments if you intend to use 'ReferenceEquals'.</source>
        <target state="translated">請勿將數值型別為 '{0}' 的引數傳遞至 'ReferenceEquals'。由於值 Boxing，這個對 'Equals' 的呼叫可能會返回未預期的結果。如果您想要使用 'ReferenceEquals'，請考慮改為使用 'Equals'，或傳遞參考型別引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesTitle">
        <source>Do not use ReferenceEquals with value types</source>
        <target state="translated">請勿使用有實值型別的 ReferenceEquals</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsDescription">
        <source>Stack space allocated by a stackalloc is only released at the end of the current method's invocation.  Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</source>
        <target state="translated">stackalloc 配置的堆疊空間只會在目前方法的引動過程結束時釋出。在迴圈中使用該空間可能會造成堆疊無限增長，最終導致堆疊溢位。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsMessage">
        <source>Potential stack overflow. Move the stackalloc out of the loop.</source>
        <target state="translated">可能發生堆疊溢位。請將 stackalloc 移出迴圈。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsTitle">
        <source>Do not use stackalloc in loops</source>
        <target state="translated">請勿在迴圈中使用 stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseThreadVolatileReadWriteCodeFixTitle">
        <source>Replace obsolete call</source>
        <target state="translated">取代過時的通話</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">更高頻率的週期性活動，會讓 CPU 一直處於忙碌狀態，且會干擾關閉顯示器與硬碟的省電閒置計時器。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">請勿使用會讓電源狀態無法變更的計時器</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">請勿使用會讓電源狀態無法變更的計時器</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPath">
        <source>Do not use unsafe DllImportSearchPath value</source>
        <target state="translated">不要使用不安全的 DllImportSearchPath 值</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathDescription">
        <source>There could be a malicious DLL in the default DLL search directories. Or, depending on where your application is run from, there could be a malicious DLL in the application's directory. Use a DllImportSearchPath value that specifies an explicit search path instead. The DllImportSearchPath flags that this rule looks for can be configured in .editorconfig.</source>
        <target state="translated">預設 DLL 搜尋目錄中可能有惡意的 DLL。或者，視應用程式的執行位置而定，應用程式的目錄中可能有惡意的 DLL。請改用指定明確搜尋路徑的 DllImportSearchPath 值。此規則尋找的 DllImportSearchPath 旗標可在 .editorconfig 中設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathMessage">
        <source>Use of unsafe DllImportSearchPath value {0}</source>
        <target state="translated">使用不安全的 DllImportSearchPath 值 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskDescription">
        <source>Using 'WaitAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="translated">對單一工作使用 'WaitAll' 可能會造成效能降低，請改為等待或返回工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskFix">
        <source>Replace 'WaitAll' with single 'Wait'</source>
        <target state="translated">以單一 'Wait' 取代 'WaitAll'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskTitle">
        <source>Do not use 'WaitAll' with a single task</source>
        <target state="translated">不要對單一工作使用 'WaitAll'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">請勿使用弱式密碼編譯演算法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">因為攻擊者取得更多的運算存取，讓攻擊升級，以致密碼編譯演算法隨著時間減弱。視此密碼編譯演算法的類型及應用方式之不同，密碼編譯強度日益減弱，會讓攻擊者能讀取加密的訊息、竄改加密的訊息、偽造數位簽章、竄改雜湊內容，或危害任何以此演算法為基礎的密碼系統。以長度大於或等於 128 位元的金鑰，取代搭配 AES (可接受 AES-256、AES-192 和 AES-128) 演算法的加密。以 SHA-2 512、SHA-2 384 或 SHA-2 256 等 SHA-2 系列中的雜湊函數，取代雜湊用途。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">{0} 使用弱式密碼編譯演算法 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Ensure Key Derivation Function algorithm is sufficiently strong</source>
        <target state="translated">確認金鑰衍生函數 (Key Derivation Function) 演算法是否夠強</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="translated">Rfc2898DeriveBytes 類別的部分實作使雜湊演算法能在建構函式參數中指定，或在 HashAlgorithm 屬性中覆寫。如果指定雜湊演算法，則其應為 SHA-256 以上 (含)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} might be using a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password.</source>
        <target state="translated">{0} 可能使用的是弱式雜湊演算法。請使用 SHA256、SHA384 或 SHA512，從密碼建立增強式金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFInsufficientIterationCountDescription">
        <source>When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).</source>
        <target state="translated">當從密碼等使用者提供的輸入衍生密碼編譯金鑰時，請使用足夠的反覆項目計數 (至少 100k)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskDescription">
        <source>Using 'WhenAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="translated">對單一工作使用 'WhenAll' 可能會造成效能降低，請改為等待或返回工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskFix">
        <source>Replace 'WhenAll' call with argument</source>
        <target state="translated">請以引數取代 'WhenAll' 呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskTitle">
        <source>Do not use 'WhenAll' with a single task</source>
        <target state="translated">不要對單一工作使用 'WhenAll'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">請勿使用 XslTransform</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">請勿使用 XslTransform。它不會限制可能引發危險的外部參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedDescription">
        <source>Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic.</source>
        <target state="translated">提供功能性 'DynamicInterfaceCastableImplementationAttribute' 屬性介面需要預設的介面成員功能，但 Visual Basic 不支援此功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedMessage">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="translated">不支援在 Visual Basic 中提供 'DynamicInterfaceCastableImplementation' 介面</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedTitle">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="translated">不支援在 Visual Basic 中提供 'DynamicInterfaceCastableImplementation' 介面</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledDescription">
        <source>Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.</source>
        <target state="translated">停用執行階段封送處理時，使用需要執行階段封送處理的功能會導致執行階段例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageAutoLayoutTypes">
        <source>Types with '[StructLayout(LayoutKind.Auto)]' require runtime marshalling to be enabled</source>
        <target state="translated">具有 '[StructLayout(LayoutKind.Auto)]' 的類型需要啟用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageByRefParameters">
        <source>By-ref parameters require runtime marshalling to be enabled</source>
        <target state="translated">By-ref 參數需要啟用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageDelegateUsage">
        <source>Delegates with managed types as parameters or the return type require runtime marshalling to be enabled in the assembly where the delegate is defined</source>
        <target state="translated">若委派受管理的類型為參數或傳回型別，則需要在定義委派的組件中啟用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageHResultSwapping">
        <source>HResult-swapping requires runtime marshalling to be enabled</source>
        <target state="translated">HResult-swapping 需要啟用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageLCIDConversionAttribute">
        <source>Using 'LCIDConversionAttribute' requires runtime marshalling to be enabled</source>
        <target state="translated">使用 'LCIDConversionAttribute' 需要啟用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageManagedParameterOrReturnTypes">
        <source>Managed parameter or return types require runtime marshalling to be enabled</source>
        <target state="translated">受控參數或傳回類型需要啟用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageSetLastError">
        <source>Setting SetLastError to 'true' requires runtime marshalling to be enabled</source>
        <target state="translated">將 SetLastError 設定為 'true' 需要啟用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageVarargPInvokes">
        <source>Varadic P/Invoke signatures require runtime marshalling to be enabled</source>
        <target state="translated">Varadic P/Invoke 簽章需要啟用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledTitle">
        <source>Property, type, or attribute requires runtime marshalling</source>
        <target state="translated">屬性、類型或屬性需要執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldIsPreviewTypeMessage">
        <source>'{0}''s type contains the preview type '{1}' and requires opting into preview features. See {2} for more information.</source>
        <target state="translated">'{0}' 的類型包含預覽類型 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldIsPreviewTypeMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}''s type contains the preview type '{1}' and requires opting into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}' 的類型包含預覽類型 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsDescription">
        <source>Forward the 'CancellationToken' parameter to methods to ensure the operation cancellation notifications gets properly propagated, or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token.</source>
        <target state="translated">將 'CancellationToken' 參數轉送給方法，以確保作業取消通知能正確地散佈，或明確地傳入 'CancellationToken.None'，以表示刻意不散佈權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsMessage">
        <source>Forward the '{0}' parameter to the '{1}' method or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token</source>
        <target state="translated">將 '{0}' 參數傳遞給 '{1}' 方法，或明確傳遞 'CancellationToken.None'，以表示有意不散佈權杖</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsTitle">
        <source>Forward the 'CancellationToken' parameter to methods</source>
        <target state="translated">將 'CancellationToken' 參數轉送給方法</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="translated">請避免對 SecurityProtocolType {0} 進行硬式編碼，並改為使用 SecurityProtocolType.SystemDefault 以便作業系統針對要使用的傳輸層安全性通訊協定進行最佳選擇。</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="translated">請避免對 SecurityProtocolType 值進行硬式編碼</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsDescription">
        <source>Current Transport Layer Security protocol versions may become deprecated if vulnerabilities are found. Avoid hardcoding SslProtocols values to keep your application secure. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">若發現弱點，則目前的傳輸層安全性通訊協定版本可能會受到淘汰。請避免硬式編碼 SslProtocols 值來確保應用程式安全。請使用 'None' 讓作業系統選擇版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsMessage">
        <source>Avoid hardcoding SslProtocols '{0}' to ensure your application remains secure in the future. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">請避免硬式編碼 SslProtocols '{0}'，以確保應用程式在未來的安全性。請使用 'None' 讓作業系統選擇版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsTitle">
        <source>Avoid hardcoded SslProtocols values</source>
        <target state="translated">避免硬式編碼 SslProtocols 值</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyDescription">
        <source>Generic math interfaces require the derived type itself to be used for the self recurring type parameter.</source>
        <target state="translated">泛型數學介面需要衍生型別本身，才能用於自我週期性類型參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyMessage">
        <source>The '{0}' requires the '{1}' type parameter to be filled with the derived type '{2}'</source>
        <target state="translated">'{0}' 需要 '{1}' 類型參數，以填入衍生類型 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyTitle">
        <source>Use correct type parameter</source>
        <target state="translated">使用正確的類型參數</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementInterfacesOnDynamicCastableImplementation">
        <source>Implement inherited interfaces</source>
        <target state="translated">實作繼承的介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewInterfaceMessage">
        <source>'{0}' implements the preview interface '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}' 會實作預覽介面 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewInterfaceMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' implements the preview interface '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}' 會實作預覽介面 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewMethodMessage">
        <source>'{0}' implements the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}' 會實作預覽方法 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewMethodMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' implements the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}' 會實作預覽方法 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">參考型別會宣告明確的靜態建構函式。若要修正此規則的違規，請於宣告所有靜態資料時將其初始化，並移除靜態建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">初始化參考型別靜態欄位內嵌</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">在宣告 {0} 中的所有靜態欄位時，將其初始化，並移除明確的靜態建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">實值型別會宣告明確的靜態建構函式。若要修正此規則的違規，請於宣告所有靜態資料時將其初始化，並移除靜態建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">初始化實值型別靜態欄位內嵌</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyChangeToTwoArgumentCodeFixTitle">
        <source>Change to call the two argument constructor, pass null for the message.</source>
        <target state="translated">變更為呼叫兩個引數建構函式，針對訊息傳遞 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">已呼叫例外狀況類型為 ArgumentException 或由其衍生的預設 (無參數) 建構函式; 或將不正確的字串引數傳遞到例外狀況類型為 ArgumentException 或由其衍生的參數化建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyFlipArgumentOrderCodeFixTitle">
        <source>Swap the arguments order</source>
        <target state="translated">交換引數順序</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">方法 {0} 會將參數名稱 '{1}' 以 {2} 引數傳遞到 {3} 建構函式。請以描述性訊息取代此引數，並將該參數名稱傳遞到正確的位置。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">方法 {0} 會將 '{1}' 以 {2} 引數傳遞到 {3} 建構函式。請以此方法的其中一個參數名稱，取代此引數。請注意，提供的參數名稱大小寫必須和該方法上宣告的大小寫完全一樣。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter</source>
        <target state="translated">呼叫包含 message 及 (或) paramName 參數的 {0} 建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate argument exceptions correctly</source>
        <target state="translated">正確地將引數例外狀況具現化</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationDescription">
        <source>Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise.</source>
        <target state="translated">以 'DynamicInterfaceCastableImplementationAttribute' 作為屬性的類型，會當作實作 'IDynamicInterfaceCastable' 類型之類型的介面實作。因此，它必須提供繼承介面中定義之所有成員的實作，因為實作 'IDynamicInterfaceCastable' 的類型不會以其他方式提供它們。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationMessage">
        <source>Type '{0}' has the 'DynamicInterfaceCastableImplementationAttribute' applied to it but does not provide an implementation of all interface members defined in inherited interfaces</source>
        <target state="translated">類型 '{0}' 已套用 'DynamicInterfaceCastableImplementationAttribute'，但未提供繼承介面中定義之所有介面成員的實作</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationTitle">
        <source>All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface</source>
        <target state="translated">在父介面中宣告的所有成員，在 DynamicInterfaceCastableImplementation 屬性介面中都必須有一個實作</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Ensure that the JavaScriptSerializer is initialized without a JavaScriptTypeResolver specified, or initialized with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">若使用以 SimpleTypeResolver 初始化的 JavaScriptSerializer 將未受信任的資料還原序列化，方法 '{0}' 就不安全。請確認將 JavaScriptSerializer 初始化時，未指定 JavaScriptTypeResolver，或使用 JavaScriptTypeResolver 來限制已還原序列化物件圖中的物件類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverTitle">
        <source>Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</source>
        <target state="translated">請確認 JavaScriptSerializer 在還原序列化之前未以 SimpleTypeResolver 初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Initialize JavaScriptSerializer without a JavaScriptTypeResolver specified, or initialize with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">若使用以 SimpleTypeResolver 初始化的 JavaScriptSerializer 將未受信任的資料還原序列化，方法 '{0}' 就不安全。將 JavaScriptSerializer 初始化時，請不要指定 JavaScriptTypeResolver，或使用 JavaScriptTypeResolver 來限制已還原序列化物件圖中的物件類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverTitle">
        <source>Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</source>
        <target state="translated">無法以使用了 SimpleTypeResolver 的 JavaScriptSerializer 還原序列化</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">將不信任的輸入還原序列化時，允許將任意類型還原序列化是不安全的。當使用還原序列化 JsonSerializer 時，請使用 TypeNameHandling.None，或對 None 以外的值使用 SerializationBinder 來限制還原序列化類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerTitle">
        <source>Do not deserialize with JsonSerializer using an insecure configuration</source>
        <target state="translated">不要使用不安全的組態以 JsonSerializer 還原序列化</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">將不信任的輸入還原序列化時，允許將任意類型還原序列化是不安全的。當使用 JsonSerializerSettings 時，請使用 TypeNameHandling.None，或對 None 以外的值使用 SerializationBinder 來限制還原序列化類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsTitle">
        <source>Do not use insecure JsonSerializerSettings</source>
        <target state="translated">請勿使用不安全的 JsonSerializerSettings</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">將不信任的輸入還原序列化時，允許將任意類型還原序列化是不安全的。當使用還原序列化 JsonSerializer 時，請使用 TypeNameHandling.None，或對 None 以外的值使用 SerializationBinder 來限制還原序列化類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerTitle">
        <source>Ensure that JsonSerializer has a secure configuration when deserializing</source>
        <target state="translated">還原序列化時，請確認 JsonSerializer 有安全的組態</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, ensure TypeNameHandling.None is specified, or for values other than None, ensure a SerializationBinder is specified to restrict deserialized types.</source>
        <target state="translated">將不信任的輸入還原序列化時，允許將任意類型還原序列化是不安全的。當使用 JsonSerializerSettings 時，請確保指定 TypeNameHandling.None，或對 None 以外的值確保指定 SerializationBinder 來限制還原序列化類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsTitle">
        <source>Ensure that JsonSerializerSettings are secure</source>
        <target state="translated">確保 JsonSerializerSettings 是安全的</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingDescription">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.  If you need to instead detect Json.NET deserialization when a SerializationBinder isn't specified, then disable rule CA2326, and enable rules CA2327, CA2328, CA2329, and CA2330.</source>
        <target state="translated">使用非 None 的 TypeNameHandling 值時，將 JSON 還原序列化可能不安全。若您需要在未指定 SerializationBinder 時，偵測 Json.NET 還原序列化，請停用規則 CA2326，並啟用規則 CA2327、CA2328、CA2329 及 CA2330。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingMessage">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.</source>
        <target state="translated">使用非 None 的 TypeNameHandling 值時，將 JSON 還原序列化可能不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingTitle">
        <source>Do not use TypeNameHandling values other than None</source>
        <target state="translated">請勿使用非 None 的 TypeNameHandling 值</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">將不受信任的資料還原序列化時，方法 '{0}' 不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer LosFormatter</source>
        <target state="translated">請勿使用不安全的還原序列化程式 LosFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMethodDeclaredOnImplementationTypeStatic">
        <source>Convert to static method</source>
        <target state="translated">轉換成靜態方法</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMethodDeclaredOnImplementationTypeStaticMayProduceInvalidCode">
        <source>Converting an instance method to a static method may produce invalid code</source>
        <target state="translated">將執行個體方法轉換為靜態方法可能會產生不正確的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeParameterlessConstructorPublic">
        <source>Make the constructor that takes zero parameters 'public'</source>
        <target state="translated">將接受零個參數的建構函式設為 'public'</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">非可序列化類型的執行個體欄位，被宣告為可序列化的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">欄位 {0} 是可序列化類型 {1} 的成員，但其所屬類型 {2} 則不可序列化</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">必須標記所有不可序列化的欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageDescription">
        <source>The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set.</source>
        <target state="translated">NeutralResourcesLanguage 屬性會通知 ResourceManager 用於顯示組件之中性文化特性 (Culture) 資源的語言。如此可改善載入第一項源的查閱效能，且可減少您的工作集。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageMessage">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">將組件標記為 NeutralResourcesLanguageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageTitle">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">將組件標記為 NeutralResourcesLanguageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">布林值資料類型在非受控的程式碼中有多種表示法。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">將 MarshalAsAttribute 新增至 P/Invoke {1} 的參數 {0}。若相對應的非受控參數為 4 位元組的 Win32 'BOOL'，請使用 [MarshalAs(UnmanagedType.Bool)]。若為 1 位元組的 C++ 'bool'，請使用 MarshalAs(UnmanagedType.U1)。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">將 MarshalAsAttribute 新增至 P/Invoke {0} 的傳回型別。若相對應的非受控傳回型別為 4 位元組的 Win32 'BOOL'，請使用 MarshalAs(UnmanagedType.Bool)。若為 1 位元組的 C++ 'bool'，請使用 MarshalAs(UnmanagedType.U1)。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">將布林值 PInvoke 引數標記為 MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">若要通用語言執行階段將其辨識為可序列化，即使類型透過實作 ISerializable 介面使用自訂序列化常式，也必須使用 SerializableAttribute 屬性來標示類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">將 [Serializable] 新增至 {0}，因為這個類型會實作 ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">將 ISerializable 類型標示為可序列化</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheck">
        <source>Ensure HttpClient certificate revocation list check is not disabled</source>
        <target state="translated">確認未停用 HttpClient 憑證撤銷清單檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheckMessage">
        <source>HttpClient may be created without enabling CheckCertificateRevocationList</source>
        <target state="translated">可在不啟用 CheckCertificateRevocationList 的情況下建立 HttpClient</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="translated">請確認憑證不會新增至根存放區</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="translated">將憑證新增至作業系統的受信任根憑證並不安全。請確認目標存放區並非根存放區。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIV">
        <source>Use CreateEncryptor with the default IV</source>
        <target state="translated">使用具有預設 IV 的 CreateEncryptor</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIVMessage">
        <source>The non-default initialization vector, which can be potentially repeatable, is used in the encryption. Ensure use the default one.</source>
        <target state="translated">加密中使用了可能可以重複的非預設初始化向量。請務必使用預設值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">請確認在 ASP.Net Core 中使用安全 Cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">請確認設定 Cookie 時，CookieOptions.Secure = true</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCount">
        <source>Ensure Sufficient Iteration Count When Using Weak Key Derivation Function</source>
        <target state="translated">使用弱式金鑰衍生函數 (Key Derivation Function) 時，請確保反覆項目計量足夠</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCountMessage">
        <source>Ensure that the iteration count is at least {0} when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">當從密碼衍生密碼編譯金鑰時，請確保反覆項目計數至少為 {0}。根據預設，Rfc2898DeriveByte 的 IterationCount 只有 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticDescription">
        <source>Since a type that implements 'IDynamicInterfaceCastable' may not implement a dynamic interface in metadata, calls to an instance interface member that is not an explicit implementation defined on this type are likely to fail at runtime. Mark new interface members 'static' to avoid runtime errors.</source>
        <target state="translated">因為實作 'IDynamicInterfaceCastable' 的類型不會在中繼資料中實作動態介面，所以呼叫在此類型不是明確實作的執行個體介面成員，在執行階段可能會失敗。請標示新的介面成員 'static' 以避免執行階段錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticMessage">
        <source>The '{0}' member on the '{1}' type should be marked 'static' as '{1}' has the 'DynamicInterfaceImplementationAttribute' applied</source>
        <target state="translated">'{1}' 類型的 '{0}' 成員應該標記為 'static'，因為 '{1}' 已套用 'DynamicInterfaceImplementationAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticTitle">
        <source>Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'static'</source>
        <target state="translated">在有 'DynamicInterfaceCastableImplementationAttribute' 介面上定義的成員應為 'static'</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodReturnsPreviewTypeMessage">
        <source>'{0}' returns the preview type '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}' 會傳回預覽類型 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodReturnsPreviewTypeMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' returns the preview type '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}' 會傳回預覽類型 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesPreviewTypeAsParameterMessage">
        <source>'{0}' takes in a preview parameter of type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}' 接受類型 '{1}' 的預覽參數，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesPreviewTypeAsParameterMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' takes in a preview parameter of type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}' 接受類型 '{1}' 的預覽參數，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledDescription">
        <source>This method uses runtime marshalling even when runtime marshalling is disabled, which can cause unexpected behavior differences at runtime due to different expectations of a type's native layout.</source>
        <target state="translated">即使停用執行階段封送處理，此方法也會使用執行階段封送處理，這可能會在執行階段造成未預期的行為差異，因為對類型原生配置有不同的期望。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledMessage">
        <source>'{0}' uses runtime marshalling even when 'DisableRuntimeMarshallingAttribute' is applied. Use features like 'sizeof' and pointers directly to ensure accurate results.</source>
        <target state="translated">即使已套用 'DisableRuntimeMarshallingAttribute'，'{0}' 也會使用執行階段封送處理。直接使用 'sizeof' 和指標等功能，以確保結果正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledTitle">
        <source>This method uses runtime marshalling even when the 'DisableRuntimeMarshallingAttribute' is applied</source>
        <target state="translated">即使已套用 'DisableRuntimeMarshallingAttribute'，此方法也會使用執行階段封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttribute">
        <source>Miss HttpVerb attribute for action methods</source>
        <target state="translated">缺少動作方法的 HttpVerb 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeDescription">
        <source>All the methods that create, edit, delete, or otherwise modify data do so in the [HttpPost] overload of the method, which needs to be protected with the anti forgery attribute from request forgery. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</source>
        <target state="translated">建立、編輯、刪除或修改資料的所有方法，都會在方法的 [HttpPost] 多載中進行，其需要由反偽造屬性保護免受偽造要求侵害。執行 GET 作業是安全的操作，沒有任何副作用且不會修改保存的資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeMessage">
        <source>Action method {0} needs to specify the HTTP request kind explicitly</source>
        <target state="translated">Action 方法 {0} 必須明確地指定 HTTP 要求種類</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesDescription">
        <source>Module initializers are intended to be used by application code to ensure an application's components are initialized before the application code begins executing. If library code declares a method with the 'ModuleInitializerAttribute', it can interfere with application initialization and also lead to limitations in that application's trimming abilities. Instead of using methods marked with 'ModuleInitializerAttribute', the library should expose methods that can be used to initialize any components within the library and allow the application to invoke the method during application initialization.</source>
        <target state="translated">模組初始設定式供應用程式程式碼使用，以確保應用程式程式碼開始執行前先初始化應用程式的元件。如果程式庫程式碼宣告擁有 'ModuleInitializerAttribute' 的方法，它可能會干擾應用程式初始化，而且也會導致該應用程式的截斷功能遭到限制。不使用標示為 'ModuleInitializerAttribute' 的方法，程式庫應該公開可用於初始化程式庫內任何元件的方法，並允許應用程式在應用程式初始化期間叫用方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesMessage">
        <source>The 'ModuleInitializer' attribute is only intended to be used in application code or advanced source generator scenarios</source>
        <target state="translated">'ModuleInitializer' 屬性只適用於應用程式程式碼或進階原始檔產生器案例中</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesTitle">
        <source>The 'ModuleInitializer' attribute should not be used in libraries</source>
        <target state="translated">程式庫中不應使用 'ModuleInitializer' 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">將未受信任的資料還原序列化時，若沒有使用 SerializationBinder 來限制已還原序列化物件圖中的物件類型，方法 '{0}' 就不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure NetDataContractSerializer.Binder is set before deserializing</source>
        <target state="translated">還原序列化之前，請務必先設定 NetDataContractSerializer.Binder</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">將未受信任的資料還原序列化時，若沒有使用 SerializationBinder 來限制已還原序列化物件圖中的物件類型，方法 '{0}' 就不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetTitle">
        <source>Do not deserialize without first setting NetDataContractSerializer.Binder</source>
        <target state="translated">未先設定 NetDataContractSerializer.Binder 之前，請勿還原序列化</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect NetDataContractSerializer deserialization without a SerializationBinder set, then disable rule CA2310, and enable rules CA2311 and CA2312.</source>
        <target state="translated">將不受信任的資料還原序列化時，方法 '{0}' 不安全。如果您需要改為偵測 NetDataContractSerializer 還原序列化，而不想要設定 SerializationBinder，則請停用規則 CA2310，並啟用規則 CA2311 和 CA2312。</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">將不受信任的資料還原序列化時，方法 '{0}' 不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedTitle">
        <source>Do not use insecure deserializer NetDataContractSerializer</source>
        <target state="translated">請勿使用不安全的還原序列化程式 NetDataContractSerializer</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">字串應標準化為大寫。如果有一小組的字元轉換為小寫，這些字元就無法再轉換回來。進行來回行程即表示會將字元從某個地區設定轉換成其他地區設定 (以不同的方式呈現字元資料)，然後精確地擷取來自轉換字元的原始字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'</source>
        <target state="translated">在方法 '{0}' 中，以 '{2}' 取代對 '{1}' 的呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">將字串標準化為大寫</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">將不受信任的資料還原序列化時，方法 '{0}' 不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer ObjectStateFormatter</source>
        <target state="translated">請勿使用不安全的還原序列化程式 ObjectStateFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="OverridesPreviewMethodMessage">
        <source>'{0}' overrides the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}' 會覆寫預覽方法 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverridesPreviewMethodMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' overrides the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}' 會覆寫預覽方法 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">公用類型中的公用方法或受保護方法，具有 System.Runtime.InteropServices.DllImportAttribute 屬性 (也由 Visual Basic 中的 Declare 關鍵字實作)。這類方法不應公開。</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">不應看得見 P/Invokes 方法 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">不應看得見 P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="ParenthesisWithPlaceHolder">
        <source> ({0})</source>
        <target state="translated"> ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllPlatforms">
        <source>and all other platforms</source>
        <target state="translated">及所有其他平台</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and later, and all other platforms</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllVersions">
        <source>'{0}' all versions</source>
        <target state="translated">'{0}' 所有版本</target>
        <note>This call site is reachable on: 'Windows' all versions.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityDescription">
        <source>Using platform dependent API on a component makes the code no longer work across all platforms.</source>
        <target state="translated">在元件上使用相依於平台的 API，會使程式碼無法繼續在所有平台上運作。</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityFromVersionToVersion">
        <source>'{0}' from version {1} to {2}</source>
        <target state="translated">'{0}' 從 {1} 至 {2} 的版本</target>
        <note>'SupportedOnWindows1903UnsupportedOn2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityObsoletedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is obsoleted on: {1}.</source>
        <target state="translated">可在所有平台上連線到此呼叫網站。'{0}' 已在 {1} 上淘汰。</target>
        <note>This call site is reachable on all platforms. 'OboletedOnMacOS()' is obsoleted on: 'macos'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityObsoletedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is obsoleted on: {1}.</source>
        <target state="translated">可在 {2} 上連線到此呼叫網站。'{0}' 已在 {1} 上淘汰。</target>
        <note>This call site is reachable on 'macos', 'linux'. 'OboletedOnMacOS()' is obsoleted on: 'macos'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is only supported on: {1}.</source>
        <target state="translated">可在所有平台上連線到此呼叫網站。只有 {1} 支援 '{0}'。</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindowsAndBrowser()' is only supported on: 'windows', 'browser' .</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">可在 {2} 上連線到此呼叫網站。只有 {1} 支援 '{0}'。</target>
        <note>This call site is reachable on: 'windows' all versions.'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsUnreachableMessage">
        <source>This call site is unreachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">無法在下列位置連線到此呼叫網站: {2}。只有 {1} 支援 '{0}'。</target>
        <note>This call site is unreachable on: 'browser'. 'SupportedOnWindowsAndBrowser()' is only supported on: 'browser', 'windows'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is supported on: {1}.</source>
        <target state="translated">可在所有平台上連線到此呼叫網站。{1} 支援 '{0}'。</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindows1903UnsupportedFrom2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is supported on: {1}.</source>
        <target state="translated">可在 {2} 上連線到此呼叫網站。{1} 支援 '{0}'。</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and before. 'UnsupportedOnWindowsSupportedOn1903()' is supported on: 'windows' 10.0.1903 and later.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityTitle">
        <source>Validate platform compatibility</source>
        <target state="translated">驗證平台相容性</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is unsupported on: {1}.</source>
        <target state="translated">可在所有平台上連線到此呼叫網站。{1} 不支援 '{0}'。</target>
        <note>This call site is reachable on all platforms. 'UnsupportedOnWindows()' is unsupported on: 'windows'</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is unsupported on: {1}.</source>
        <target state="translated">可在 {2} 上連線到此呼叫網站。{1} 不支援 '{0}'。</target>
        <note>This call site is reachable on: 'windows', 'browser'. 'UnsupportedOnBrowser()' is unsupported on: 'browser'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndBefore">
        <source>'{0}' {1} and before</source>
        <target state="translated">'{0}' {1} 及之前的版本</target>
        <note>'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndLater">
        <source>'{0}' {1} and later</source>
        <target state="translated">'{0}' {1} 及之後的版本</target>
        <note>'SupportedOnWindows10()' is only supported on: 'windows' 10.0 and later.</note>
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphDescription">
        <source>Review code that processes untrusted deserialized data for handling of unexpected reference cycles. An unexpected reference cycle should not cause the code to enter an infinite loop. Otherwise, an unexpected reference cycle can allow an attacker to DOS or exhaust the memory of the process when deserializing untrusted data.</source>
        <target state="translated">檢閱會處理未受信任之還原序列化資料的程式碼，以處理未預期的參考迴圈。未預期的參考迴圈不應導致程式碼進入無限迴圈，否則，未預期的參考週期可能讓攻擊者得以 DOS，或在將未受信任的資料還原序列化時耗盡處理序的記憶體。</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">{0} 參與了可能的參照循環</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphTitle">
        <source>Potential reference cycle in deserialized object graph</source>
        <target state="translated">還原序列化物件圖中的潛在參考迴圈</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringCodefixTitle">
        <source>Replace 'Substring' with 'AsSpan'</source>
        <target state="translated">請以 'AsSpan' 取代 'Substring'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringDescription">
        <source>'AsSpan' is more efficient than 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost.</source>
        <target state="translated">'AsSpan' 比 'Substring' 更有效率。'Substring' 會執行 O(n) 字串複製，而 'AsSpan' 不會且有固定成本。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringMessage">
        <source>Prefer 'AsSpan' over 'Substring' when span-based overloads are available</source>
        <target state="translated">當範圍型的多載可用時，建議使用 'AsSpan' 而不是 'Substring'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringTitle">
        <source>Prefer 'AsSpan' over 'Substring'</source>
        <target state="translated">建議使用 'AsSpan' 而不是 'Substring'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderDescription">
        <source>'StringBuilder.Append(char)' is more efficient than 'StringBuilder.Append(string)' when the string is a single character. When calling 'Append' with a constant, prefer using a constant char rather than a constant string containing one character.</source>
        <target state="translated">當字串是單一字元時，'StringBuilder.Append(char)' 比 'StringBuilder.Append(string)' 更有效率。當以常數呼叫 'Append' 時，建議使用常數字元，而不要使用包含一個字元的常數字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderMessage">
        <source>Use 'StringBuilder.Append(char)' instead of 'StringBuilder.Append(string)' when the input is a constant unit string</source>
        <target state="translated">當輸入為常數單元字串時，請使用 'StringBuilder.Append(char)'，而非 'StringBuilder.Append(string)'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderTitle">
        <source>Consider using 'StringBuilder.Append(char)' when applicable</source>
        <target state="translated">請在適當時考慮使用 'StringBuilder.Append(char)'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterCodeFixTitle">
        <source>Replace with 'Convert.{0}'</source>
        <target state="translated">以 'Convert.{0}' 取代</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterDescription">
        <source>Use 'Convert.ToHexString' or 'Convert.ToHexStringLower' when encoding bytes to a hexadecimal string representation. These methods are more efficient and allocation-friendly than using 'BitConverter.ToString' in combination with 'String.Replace' to replace dashes and 'String.ToLower'.</source>
        <target state="translated">將位元組編碼為十六進位字串表示法時，請使用 'Convert.ToHexString' 或 'Convert.ToHexStringLower'。這些方法比使用 'BitConverter.ToString' 與 'String.Replace' 一起取代虛線和 'String.ToLower' 更有效率且更易配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterMessage">
        <source>Prefer '{0}' over call chains based on '{1}'</source>
        <target state="translated">比起以 '{1}' 為基礎的呼叫鏈，更偏好 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterTitle">
        <source>Prefer 'Convert.ToHexString' and 'Convert.ToHexStringLower' over call chains based on 'BitConverter.ToString'</source>
        <target state="translated">比起以 'BitConverter.ToString' 為基礎的呼叫鏈結，更偏好 'Convert.ToHexString' 和 'Convert.ToHexStringLower'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferCountOverAnyCodeFixTitle">
        <source>Use 'Count' check instead of 'Any()'</source>
        <target state="translated">使用 'Count' 檢查而非 'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferCountOverAnyMessage">
        <source>Prefer comparing 'Count' to 0 rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">為了清楚明瞭和為了提升效能，偏好比較 'Count' 與 0，而不是使用 'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyCodeFixTitle">
        <source>Use 'ContainsKey'</source>
        <target state="translated">請使用 'ContainsKey'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyDescription">
        <source>'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations.</source>
        <target state="translated">'ContainsKey' 通常為 O(1)，但在某些情況下，'Keys.Contains' 可能為 O(n)。此外，許多字典實作會延遲初始化 Keys 集合以縮減配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyMessage">
        <source>Prefer 'ContainsKey' over 'Keys.Contains' for dictionary type '{0}'</source>
        <target state="translated">字典類型 '{0}' 建議使用 'ContainsKey' 而不是 'Keys.Contains'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsMethodsTitle">
        <source>Prefer Dictionary.Contains methods</source>
        <target state="translated">建議使用 Dictionary.Contains 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueCodeFixTitle">
        <source>Use 'ContainsValue'</source>
        <target state="translated">請使用 'ContainsValue'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueDescription">
        <source>Many dictionary implementations lazily initialize the Values collection. To avoid unnecessary allocations, prefer 'ContainsValue' over 'Values.Contains'.</source>
        <target state="translated">許多字典實作會延遲初始化 Values 集合。為避免不必要的配置，建議使用 'ContainsValue' 而不是 'Values.Contains'。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueMessage">
        <source>Prefer 'ContainsValue' over 'Values.Contains' for dictionary type '{0}'</source>
        <target state="translated">字典類型 '{0}' 建議使用 'ContainsValue' 而不是 'Values.Contains'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddDescription">
        <source>Prefer a 'TryAdd' call over an 'Add' call guarded by a 'ContainsKey' check. 'TryAdd' behaves the same as 'Add', except that when the specified key already exists, it returns 'false' instead of throwing an exception.</source>
        <target state="translated">偏好 'TryAdd' 呼叫，而不要使用由 'ContainsKey' 檢查所防護的 'Add' 呼叫。'TryAdd' 的行為與 'Add' 相同，唯一的例外是，當指定的索引鍵已存在時會返回 'false'，而不是擲回例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddMessage">
        <source>To avoid double lookup, call 'TryAdd' instead of calling 'Add' with a 'ContainsKey' guard</source>
        <target state="translated">若要避免重複查閱，請呼叫 'TryAdd'，而不是使用 'ContainsKey' 成立條件呼叫 'Add'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddTitle">
        <source>Prefer the 'IDictionary.TryAdd(TKey, TValue)' method</source>
        <target state="translated">建議使用 'IDictionary.TryAdd(TKey, TValue)' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddValueCodeFixTitle">
        <source>Use 'TryAdd(TKey, TValue)'</source>
        <target state="translated">使用 'TryAdd(TKey, TValue)'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueCodeFixTitle">
        <source>Use 'TryGetValue(TKey, out TValue)'</source>
        <target state="translated">使用 'TryGetValue(TKey，out TValue)'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueDescription">
        <source>Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check. 'ContainsKey' and the indexer both would lookup the key under the hood, so using 'TryGetValue' removes the extra lookup.</source>
        <target state="translated">建議使用 'TryGetValue' 呼叫，而不是由 'ContainsKey' 檢查所防護的字典索引子存取權。'ContainsKey' 和索引子會在罩下查閱索引鍵，因此使用 'TryGetValue' 會移除額外的查閱。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueMessage">
        <source>Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check to avoid double lookup</source>
        <target state="translated">建議使用 'TryGetValue' 呼叫，而不是使用 'ContainsKey' 檢查所防護的字典索引子存取權，以避免再次查閱</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueTitle">
        <source>Prefer the 'IDictionary.TryGetValue(TKey, out TValue)' method</source>
        <target state="translated">建議使用 'IDictionary.TryGetValue(TKey，out TValue)' 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsCodeFixTitle">
        <source>Use generic overload</source>
        <target state="translated">使用泛型多載</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsDescription">
        <source>Using a generic overload is preferable to the 'System.Type' overload when the type is known, promoting cleaner and more type-safe code with improved compile-time checks.</source>
        <target state="translated">當型別為已知時，使用泛型多載會比使用 'System.Type' 多載更合適，可透過改善的編譯時間檢查來提升更為簡潔且型別安全的程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsMessage">
        <source>Prefer the generic overload '{0}' instead of '{1}'</source>
        <target state="translated">偏好泛型多載 '{0}'，而非 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsTitle">
        <source>Prefer generic overload when type is known</source>
        <target state="translated">當型別為已知時，優先使用泛型多載</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataCodefixTitle">
        <source>Replace with 'HashData' method</source>
        <target state="translated">以 'HashData' 方法取代</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerDescription">
        <source>It is more efficient to use the static 'HashData' method over creating and managing a HashAlgorithm instance to call 'ComputeHash'.</source>
        <target state="translated">使用靜態 'HashData' 方法比建立和管理 HashAlgorithm 執行個體來呼叫 'ComputeHash' 更有效率。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerMessage">
        <source>Prefer static '{0}.HashData' method over 'ComputeHash'</source>
        <target state="translated">偏好靜態 '{0}.HashData' 方法而非 'ComputeHash'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerTitle">
        <source>Prefer static 'HashData' method over 'ComputeHash'</source>
        <target state="translated">偏好靜態 'HashData' 方法而非 'ComputeHash'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverAnyCodeFixTitle">
        <source>Use 'IsEmpty' check instead of 'Any()'</source>
        <target state="translated">使用 'IsEmpty' 檢查，而不是 'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverAnyMessage">
        <source>Prefer an 'IsEmpty' check rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">為了清楚明瞭和為了提升效能，偏好 'IsEmpty' 檢查，而不是使用 'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountDescription">
        <source>For determining whether the object contains or not any items, prefer using 'IsEmpty' property rather than retrieving the number of items from the 'Count' property and comparing it to 0 or 1.</source>
        <target state="translated">若要判斷物件是否包含項目，建議使用 'IsEmpty' 屬性，而不要從 'Count' 屬性中擷取項目數來與 0 或 1 比較。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountMessage">
        <source>Prefer 'IsEmpty' over 'Count' to determine whether the object is empty</source>
        <target state="translated">若要判斷物件是否為空，建議使用 'IsEmpty'，而不要使用 'Count'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountTitle">
        <source>Prefer IsEmpty over Count</source>
        <target state="translated">建議使用 IsEmpty，而不要使用 Count</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthCountIsEmptyOverAnyDescription">
        <source>Prefer using 'IsEmpty', 'Count' or 'Length' properties whichever available, rather than calling 'Enumerable.Any()'. The intent is clearer and it is more performant than using 'Enumerable.Any()' extension method.</source>
        <target state="translated">偏好使用 'IsEmpty'、'Count' 或 'Length' 屬性 (以可用者為准)，而不是呼叫 'Enumerable.Any()'。意圖更清楚，而且比使用 'Enumerable.Any()' 擴充方法更具效能。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthCountIsEmptyOverAnyTitle">
        <source>Avoid using 'Enumerable.Any()' extension method</source>
        <target state="translated">避免使用 'Enumerable.Any()' 擴充方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthOverAnyCodeFixTitle">
        <source>Use 'Length' check instead of 'Any()'</source>
        <target state="translated">使用 'Length' 檢查而非 'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthOverAnyMessage">
        <source>Prefer comparing 'Length' to 0 rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">為了清楚明瞭和為了提升效能，偏好比較 'Length' 與 0，而不是使用 'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsDescription">
        <source>'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument. Prefer calling the memory based overloads, which are more efficient.</source>
        <target state="translated">'Stream' 具有採用 'Memory&lt;Byte&gt;' 作為第一個引數的 'ReadAsync' 多載，以及採用 'ReadOnlyMemory&lt;Byte&gt;' 作為第一個引數的 'WriteAsync' 多載。建議呼叫採用記憶體的多載，較有效率。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsMessage">
        <source>Change the '{0}' method call to use the '{1}' overload</source>
        <target state="translated">將 '{0}' 方法呼叫變更為使用 '{1}' 多載</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsTitle">
        <source>Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</source>
        <target state="translated">建議針對 'ReadAsync' 和 'WriteAsync' 使用採用 'Memory' 的多載</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfCodeFixTitle">
        <source>Replace with 'string.Contains'</source>
        <target state="translated">以 'string.Contains' 取代</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfDescription">
        <source>Calls to 'string.IndexOf' where the result is used to check for the presence/absence of a substring can be replaced by 'string.Contains'.</source>
        <target state="translated">呼叫 'String.IndexOf' 的結果，將用於確認有無子字串可由 'String.Contains' 取代。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfMessage">
        <source>Use 'string.Contains' instead of 'string.IndexOf' to improve readability</source>
        <target state="translated">使用 'String.Contains'，而不要使用 'String.IndexOf'，以提高可讀性</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfTitle">
        <source>Consider using 'string.Contains' instead of 'string.IndexOf'</source>
        <target state="translated">請考慮使用 'String.Contains'，而不要使用 'String.IndexOf'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsDescription">
        <source>StringBuilder.Append and StringBuilder.Insert provide overloads for multiple types beyond System.String.  When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</source>
        <target state="translated">StringBuilder.Append 與 StringBuilder.Insert 可為 System.String 以外的多種類型提供多載。建議盡可能使用強型別多載，而非 ToString() 與字串式多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsMessage">
        <source>Remove the ToString call in order to use a strongly-typed StringBuilder overload</source>
        <target state="translated">移除 ToString 呼叫，以使用強型別 StringBuilder 多載</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsRemoveToString">
        <source>Remove the ToString call</source>
        <target state="translated">移除 ToString 呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsTitle">
        <source>Prefer strongly-typed Append and Insert method overloads on StringBuilder</source>
        <target state="translated">建議在 StringBuilder 上使用強型別 Append 及 Insert 方法多載</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesConversionNotThrowMessage">
        <source>Starting with .NET 7 the explicit conversion '{0}' will not throw when overflowing in an unchecked context. Wrap the expression with a 'checked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">從 .NET 7 開始，在未選取的內容中溢位時將不會明確轉換 '{0}'。使用 'checked' 陳述式包裝運算式，以還原 .NET 6 行為。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesConversionThrowsMessage">
        <source>Starting with .NET 7 the explicit conversion '{0}' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">從 .NET 7 開始，在已選取的內容中溢位時將會明確轉換 '{0}'。使用 'unchecked' 陳述式包裝運算式，以還原 .NET 6 行為。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesDescription">
        <source>Some built-in operators added in .NET 7 behave differently when overflowing than did the corresponding user-defined operators in .NET 6 and earlier versions. Some operators that previously threw in an unchecked context now don't throw unless wrapped within a checked context. Also, some operators that did not previously throw in a checked context now throw unless wrapped in an unchecked context.</source>
        <target state="translated">在 .NET 7 中新增的某些內建運算子在溢位時的行為不同於 .NET 6 和較舊版本中對應的使用者定義運算子。某些先前擲回未核取內容的運算子現在不會擲回，除非包裝在核取的內容中。此外，某些先前未擲回核取內容的運算子現在會擲回，除非包裝在未選取的內容中。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesOperatorThrowsMessage">
        <source>Starting with .NET 7 the operator '{0}' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">從 .NET 7 開始，在已選取的內容中溢位時將會擲回運算子 '{0}'。使用 'unchecked' 陳述式包裝運算式，以還原 .NET 6 行為。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesTitle">
        <source>Prevent behavioral change</source>
        <target state="translated">防止行為變更</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagDescription">
        <source>'Enum.HasFlag' method expects the 'enum' argument to be of the same 'enum' type as the instance on which the method is invoked and that this 'enum' is marked with 'System.FlagsAttribute'. If these are different 'enum' types, an unhandled exception will be thrown at runtime. If the 'enum' type is not marked with 'System.FlagsAttribute' the call will always return 'false' at runtime.</source>
        <target state="translated">'Enum.HasFlag' 方法需要 'Enum' 引數的類型，與叫用方法之執行個體的類型相同，且此 'enum' 必須標記 'System.FlagsAttribute'。若兩者的 'Enum' 類型不同，將會在執行階段擲回未處理的例外狀況。若 'Enum' 類型未標記 'System.FlagsAttribute'，則此呼叫在執行階段時一律會傳回 'False'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagMessageDifferentType">
        <source>The argument type, '{0}', must be the same as the enum type '{1}'</source>
        <target state="translated">引數類型 '{0}' 與列舉類型 '{1}' 必須相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagTitle">
        <source>Provide correct 'enum' argument to 'Enum.HasFlag'</source>
        <target state="translated">為 'Enum.HasFlag' 提供正確的 'Enum' 引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">傳遞給 System.String.Format 的格式化引數，並未包含與每個物件引數相對應的格式項目，反之亦然。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsInvalidFormatMessage">
        <source>The format argument is not a valid format string</source>
        <target state="translated">格式引數不是有效的格式字串</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">為格式化方法提供正確的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">為格式化方法提供正確的引數</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyDescription">
        <source>The property 'MaxResponseHeadersLength' is measured in kilobytes, not in bytes. The provided value is multiplied by 1024, which might be greater than your intended maximum length.</source>
        <target state="translated">屬性 'MaxResponseHeadersLength' 以 KB 為衡量單位，而不是以位元組為衡量單位。提供的值會乘以 1024，這可能大於您預期的最大長度。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyMessage">
        <source>Make sure the value '{0}' is correct. This value is measured in kilobytes, not bytes.</source>
        <target state="translated">請確定值 '{0}' 正確無誤。此值以 KB 為衡量單位，而不是以位元組為衡量單位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyTitle">
        <source>Set 'MaxResponseHeadersLength' properly</source>
        <target state="translated">正確設定 'MaxResponseHeadersLength'</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorDescription">
        <source>Providing a parameterless constructor that is as visible as the containing type for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions.</source>
        <target state="translated">提供一種無參數的建構函式，與衍生自 'System.Runtime.InteropServices.SafeHandle' 之類型的包含類型一樣可見，使用原始檔產生的 interop 解決方案可提高效能及使用量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorMessage">
        <source>Provide a parameterless constructor that is as visible as the containing type for the '{0}' type that is derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="translated">提供一種無參數的建構函式，與衍生自 'System.Runtime.InteropServices.SafeHandle' 之 '{0}' 類型的包含類型一樣可見</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorTitle">
        <source>Provide a parameterless constructor that is as visible as the containing type for concrete types derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="translated">提供一種無參數的建構函式，與衍生自 'System.Runtime.InteropServices.SafeHandle' 之具體類型的包含類型一樣可見</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesDescription">
        <source>To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods.</source>
        <target state="translated">若要提升效能，請在加入子類別 'Stream' 時，覆寫記憶體型的非同步方法，然後以記憶體型方法的方式實作陣列型的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesMessage">
        <source>'{0}' overrides array-based '{1}' but does not override memory-based '{2}'. Consider overriding memory-based '{2}' to improve performance.</source>
        <target state="translated">'{0}' 會覆寫陣列型的 '{1}'，但不會覆寫記憶體型的 '{2}'。請考慮覆寫記憶體型的 '{2}' 以提升效能。</target>
        <note>0 = type that subclasses Stream directly, 1 = array-based method, 2 = memory-based method</note>
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesTitle">
        <source>Provide memory-based overrides of async methods when subclassing 'Stream'</source>
        <target state="translated">加入子類別 'Stream' 時，提供非同步方法的記憶體型覆寫</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons when using 'CompareTo', because they lead to an allocation. Instead, use 'StringComparer' to perform case-insensitive comparisons. Switching to using 'StringComparer' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'.</source>
        <target state="translated">避免在使用 'CompareTo' 時呼叫 'ToLower'、'ToUpper'、'ToLowerInvariant' 和 'ToUpperInvariant' 來執行不區分大小寫的字串比較，因為它們會導致配置。請改用 'StringComparer' 來執行不區分大小寫的比較。切換至使用 'StringComparer' 可能會導致行為發生輕微變更，因此在套用建議之後，必須進行全面性測試。此外，如果不需要文化相關比較，請考慮使用 'StringComparer.OrdinalIgnoreCase'。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerMessage">
        <source>Prefer using 'StringComparer' to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'</source>
        <target state="translated">建議使用 'StringComparer' 執行不區分大小寫的比較，但請注意，這可能會導致行為發生輕微變更，因此請務必在套用建議之後進行全面測試，或者如果不需要文化相關比較，請考慮使用 'StringComparer.OrdinalIgnoreCase'</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerStringComparisonCodeFixTitle">
        <source>Use the 'string.{0}(string, StringComparison)' overload</source>
        <target state="translated">使用 'string.{0}(string, StringComparison)' 多載</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons because they lead to an allocation. Instead, prefer calling the method overloads of 'Contains', 'IndexOf' and 'StartsWith' that take a 'StringComparison' enum value to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</source>
        <target state="translated">避免呼叫 'ToLower'、'ToUpper'、'ToLowerInvariant' 和 'ToUpperInvariant' 來執行不區分大小寫的字串比較，因為它們會導致配置。相反地，建議呼叫採用 'StringComparison' 列舉值的 'Contains'、'IndexOf' 和 'StartsWith' 方法多載，以執行不區分大小寫的比較。切換至使用多載 (其採用 'StringComparer') 可能會導致行為發生輕微變更，因此在套用建議之後，必須進行全面性測試。此外，如果不需要文化相關比較，請考慮使用 'StringComparison.OrdinalIgnoreCase'。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonMessage">
        <source>Prefer the string comparison method overload of '{0}' that takes a 'StringComparison' enum value to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</source>
        <target state="translated">建議採用 'StringComparison' 列舉值之 '{0}' 的字串比較方法多載，以執行不區分大小寫的比較，但請注意，這可能會導致行為發生輕微變更，因此請務必在套用建議之後進行全面測試，或者如果不需要文化相關比較，請考慮使用 'StringComparison.OrdinalIgnoreCase'</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonTitle">
        <source>Use the 'StringComparison' method overloads to perform case-insensitive string comparisons</source>
        <target state="translated">使用 'StringComparison' 方法多載來執行不區分大小寫的字串比較</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsCodeFixTitle">
        <source>Use 'string.Equals(string, StringComparison)'</source>
        <target state="translated">使用 'string.Equals(string, StringComparison)'</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons, as in 'string.ToLower() == string.ToLower()', because they lead to an allocation. Instead, use 'string.Equals(string, StringComparison)' to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</source>
        <target state="translated">避免呼叫 'ToLower'、'ToUpper'、'ToLowerInvariant' 和 'ToUpperInvariant' 來執行不區分大小寫的字串比較，例如在 'string.ToLower() == string.ToLower()' 中，因為它們會導致配置。請改用 'string.Equals(string, StringComparison)' 以執行不區分大小寫的比較。切換至使用多載 (其採用 'StringComparer') 可能會導致行為發生輕微變更，因此在套用建議之後，必須進行全面性測試。此外，如果不需要文化相關比較，請考慮使用 'StringComparison.OrdinalIgnoreCase'。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsMessage">
        <source>Prefer using 'string.Equals(string, StringComparison)' to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</source>
        <target state="translated">建議使用 'string.Equals(string, StringComparison)' 執行不區分大小寫的比較，但請注意，這可能會導致行為發生輕微變更，因此請務必在套用建議之後進行全面測試，或者如果不需要文化相關比較，請考慮使用 'StringComparison.OrdinalIgnoreCase</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantCall">
        <source>Remove redundant call</source>
        <target state="translated">移除冗餘的呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantGuardCallCodeFixTitle">
        <source>Remove unnecessary call</source>
        <target state="translated">移除不必要的呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplaceStringLiteralWithCharLiteralCodeActionTitle">
        <source>Replace string literal with char literal</source>
        <target state="translated">以字元常值取代字串常值</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesMessage">
        <source>Potential DLL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入 DLL 弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesTitle">
        <source>Review code for DLL injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有 DLL 插入弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesMessage">
        <source>Potential file path injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入檔案路徑弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesTitle">
        <source>Review code for file path injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有插入檔案路徑弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesMessage">
        <source>Potential information disclosure vulnerability was found where '{0}' in method '{1}' may contain unintended information from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的資訊洩漏弱點，方法 '{1}' 中的 '{0}' 可能包含來自方法 '{3}' 中 '{2}' 誤用的資訊</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesTitle">
        <source>Review code for information disclosure vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有資訊洩漏弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesMessage">
        <source>Potential LDAP injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入 LDAP 弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesTitle">
        <source>Review code for LDAP injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有插入 LDAP 弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesMessage">
        <source>Potential open redirect vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的開啟重新導向弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesTitle">
        <source>Review code for open redirect vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有開啟重新導向弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesMessage">
        <source>Potential process command injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入處理序命令弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesTitle">
        <source>Review code for process command injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有插入處理序命令弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesMessage">
        <source>Potential regex injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入 regex 弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesTitle">
        <source>Review code for regex injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有插入 regex 弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesMessage">
        <source>Potential SQL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入 SQL 弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesTitle">
        <source>Review code for SQL injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有插入 SQL 弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesMessage">
        <source>Potential XPath injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入 XPath 弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesTitle">
        <source>Review code for XPath injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有插入 XPath 弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesMessage">
        <source>Potential XAML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入 XAML 弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesTitle">
        <source>Review code for XAML injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有插入 XAML 弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesMessage">
        <source>Potential XML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的插入 XML 弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesTitle">
        <source>Review code for XML injection vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有插入 XML 弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesMessage">
        <source>Potential cross-site scripting (XSS) vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">發現潛在的跨網站指令碼 (XSS) 弱點，方法 '{1}' 中的 '{0}' 可能被來自方法 '{3}' 中 '{2}' 由使用者控制的資料所感染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesTitle">
        <source>Review code for XSS vulnerabilities</source>
        <target state="translated">檢閱程式碼以了解是否有 XSS 弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesDescription">
        <source>SQL queries that directly use user input can be vulnerable to SQL injection attacks. Review this SQL query for potential vulnerabilities, and consider using a parameterized SQL query.</source>
        <target state="translated">直接利用使用者輸入的 SQL 查詢，有可能會受到插入 SQL 的攻擊。請檢閱此 SQL 查詢是否有潛在的弱點，並請考慮使用參數化的 SQL 查詢。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesMessageNoNonLiterals">
        <source>Review if the query string passed to '{0}' in '{1}', accepts any user input</source>
        <target state="translated">檢閱查詢字串是否已傳遞到 '{1}' 中的 '{0}'，接受所有使用者輸入</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesTitle">
        <source>Review SQL queries for security vulnerabilities</source>
        <target state="translated">必須檢閱 SQL 查詢中是否有安全性弱點</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesCodeFixTitle">
        <source>Seal class</source>
        <target state="translated">密封類別</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesDescription">
        <source>When a type is not accessible outside its assembly and has no subtypes within its containing assembly, it can be safely sealed. Sealing types can improve performance.</source>
        <target state="translated">當一個類型無法在其組建外部進行存取，且其包含元件內沒有子類型時，可以安全地密封該類型。密封類型可以改善效能。</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesMessage">
        <source>Type '{0}' can be sealed because it has no subtypes in its containing assembly and is not externally visible</source>
        <target state="translated">類型 '{0}' 可以被密封，因為它包含的組建中沒有任何子類型，而且無法從外部所見</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesTitle">
        <source>Seal internal types</source>
        <target state="translated">密封內部類型</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookie">
        <source>Set HttpOnly to true for HttpCookie</source>
        <target state="translated">針對 HttpCookie 將 HttpOnly 設為 true</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieDescription">
        <source>As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies.</source>
        <target state="translated">請確保安全性敏感性 HTTP Cookie 已標記為 HttpOnly，以防止全面性的測量。這代表 Web 瀏覽器應禁止指令碼存取 Cookie。插入的惡意指令碼是竊取 Cookie 的常見方式。</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieMessage">
        <source>HttpCookie.HttpOnly is set to false or not set at all when using an HttpCookie. Ensure security sensitive cookies are marked as HttpOnly to prevent malicious scripts from stealing the cookies</source>
        <target state="translated">使用 HttpCookie 時，HttpCookie.HttpOnly 設為 false 或完全未設定。請確保安全性敏感性 Cookie 已標記為 HttpOnly，以避免惡意指令碼竊取 Cookie。</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">設定頁面衍生類別的 ViewStateUserKey</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">設定 ViewStateUserKey 屬性可藉由讓您能為各個使用者的檢視狀態變數，指派識別碼，使其無法使用變數來產生攻擊，因而有助於避免應用程式受到攻擊。否則，將會出現跨網站偽造要求弱點。</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The class {0} derived from System.Web.UI.Page does not set the ViewStateUserKey property in the OnInit method or Page_Init method</source>
        <target state="translated">衍生自 System.Web.UI.Page 的 {0} 類別未在 OnInit 方法或 Page_Init 方法中設定 ViewStateUserKey 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperDescription">
        <source>Specify culture to help avoid accidental implicit dependency on current culture. Using an invariant version yields consistent results regardless of the culture of an application.</source>
        <target state="translated">指定文化，以避免意外隱含相依於目前的文化。無論應用程式的文化如何，使用固定版本會產生一致的結果。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperMessage">
        <source>Specify a culture or use an invariant version to avoid implicit dependency on current culture</source>
        <target state="translated">指定文化或使用固定版本，以避免目前文化上的隱含相依性</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperTitle">
        <source>Specify a culture or use an invariant version</source>
        <target state="translated">指定文化或使用固定版本</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">方法或建構函式會呼叫其多載接受 System.Globalization.CultureInfo 參數的成員，但方法或建構函式不會呼叫接受 CultureInfo 參數的多載。未提供 CultureInfo 或 System.IFormatProvider 物件時，多載成員提供的預設值可能無法在所有地區設定中呈現您想要的效果。如果要對使用者顯示此結果，請將 'CultureInfo.CurrentCulture' 指定為 'CultureInfo' 參數。否則，若將由軟體儲存結果及進行存取 (例如，要保存到磁碟或資料庫時)，請指定 'CultureInfo.InvariantCulture'</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}' 的行為可能會因目前使用者的地區設定而異。以呼叫 '{2}' 來取代 '{1}' 中的此呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">指定 CultureInfo</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCurrentCulture">
        <source>Specify current culture</source>
        <target state="translated">指定目前的文化</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">方法或建構函式會呼叫一或多個其多載接受 System.IFormatProvider 參數的成員，但方法或建構函式不會呼叫接受 IFormatProvider 參數的多載。未提供 System.Globalization.CultureInfo 或 IFormatProvider 物件時，多載成員提供的預設值可能無法在所有地區設定中呈現您想要的效果。如果結果將取決於輸入來源/對使用者顯示的輸出，請將 'CultureInfo.CurrentCulture' 指定為 'IFormatProvider'。否則，若將由軟體儲存結果及進行存取 (例如，從磁碟/資料庫載入時，以及要保存到磁碟/資料庫時)，請指定 'CultureInfo.InvariantCulture'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}' 的行為可能會因目前使用者的地區設定而異。以呼叫 '{2}' 來取代 '{1}' 中的此呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}' 的行為可能會因目前使用者的地區設定而異。以呼叫 '{2}' 來取代 '{1}' 中的此呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderOptional">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Provide a value for the 'IFormatProvider' argument.</source>
        <target state="translated">'{0}' 的行為可能會依據目前使用者之地區設定的不同而異。提供 'IFormatProvider' 引數的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">'{0}' 會將 '{1}' 以 'IFormatProvider' 參數的形式傳遞給 '{2}'。此屬性會傳回不適合格式化方法的文化特性 (Culture)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">'{0}' 會將 '{1}' 以 'IFormatProvider' 參數的形式傳遞給 '{2}'。此屬性會傳回不適合格式化方法的文化特性 (Culture)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">指定 IFormatProvider</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">平台叫用成員允許部分信任的呼叫端、具有字串參數，且不會明確地封送處理字串。如此可能會造成資訊安全漏洞。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">指定 P/Invoke 字串引數的封送處理</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. It is recommended to use the overload with StringComparison parameter for clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">字串比較作業使用不設定 StringComparison 參數的方法多載。建議您使用會採用 StringComparison 參數的多載，使意圖更清楚。若要對使用者顯示此結果 (例如，排序項目清單以顯示於清單方塊中)，請將 'StringComparison.CurrentCulture' 或 'StringComparison.CurrentCultureIgnoreCase' 指定為 'StringComparison' 參數。若要比較不區分大小寫的識別碼 (例如檔案路徑、環境變數或登錄機碼與值)，請指定 'StringComparison.OrdinalIgnoreCase'。而若要比較區分大小寫的識別碼，請指定 'StringComparison.Ordinal'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Message">
        <source>'{0}' has a method overload that takes a 'StringComparison' parameter. Replace this call in '{1}' with a call to '{2}' for clarity of intent.</source>
        <target state="translated">'{0}' 具有採用 'StringComparison' 參數的方法多載。請以對 '{2}' 的呼叫取代 '{1}' 中的此呼叫，使意圖更清楚。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Title">
        <source>Specify StringComparison for clarity</source>
        <target state="translated">指定 StringComparison 以提升明確性</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter, hence its behavior could vary based on the current user's locale settings. It is strongly recommended to use the overload with StringComparison parameter for correctness and clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">字串比較作業使用不設定 StringComparison 參數的方法多載，因此，根據目前使用者的地區設定，其行為可能不同。強烈建議您使用會採用 StringComparison 參數的多載，以提升意圖的正確性及明確性。若要對使用者顯示此結果 (例如，排序項目清單以顯示於清單方塊中)，請將 'StringComparison.CurrentCulture' 或 'StringComparison.CurrentCultureIgnoreCase' 指定為 'StringComparison' 參數。若要比較不區分大小寫的識別項碼 (例如檔案路徑、環境變數或登錄機碼與值)，請指定 'StringComparison.OrdinalIgnoreCase'。而若要比較區分大小寫的識別碼，請指定 'StringComparison.Ordinal'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Message">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}' 的行為可能會因目前使用者的地區設定而異。以呼叫 '{2}' 來取代 '{1}' 中的此呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Title">
        <source>Specify StringComparison for correctness</source>
        <target state="translated">指定 StringComparison 以提升正確性</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticAndAbstractRequiresPreviewFeatures">
        <source>Using both 'static' and 'abstract' modifiers requires opting into preview features. See https://aka.ms/dotnet-warnings/preview-features for more information.</source>
        <target state="translated">同時使用 'static' 和 'abstract' 修飾元必須加入預覽功能。如需詳細資訊，請參閱 https://aka.ms/dotnet-warnings/preview-features。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">使用 String.Length 屬性或 String.IsNullOrEmpty 方法來比較字串的速度，大幅快過於使用 Equals。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check</source>
        <target state="translated">請使用 'string.Length' 屬性或 'string.IsNullOrEmpty' 方法測試空白字串，而非使用相等檢查</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">使用字串長度測試空白字串</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">此運算式會對 Single.Nan 或 Double.Nan 測試值。使用 Single.IsNan(Single) 或 Double.IsNan(Double) 來測試該值。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">正確地測試 NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">正確地測試 NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineDescription">
        <source>'ThreadStatic' fields should be initialized lazily on use, not with inline initialization nor explicitly in a static constructor, which would only initialize the field on the thread that runs the type's static constructor.</source>
        <target state="translated">'ThreadStatic' 欄位應該在使用時初始化，而非使用內嵌初始化，也不應該明確初始化在靜態建構函式中，而此建構函式只會初始化執行該類型之靜態建構函式之執行緒上的欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineMessage">
        <source>'ThreadStatic' fields should not use inline initialization</source>
        <target state="translated">'ThreadStatic' 欄位不應該使用內嵌初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineTitle">
        <source>Improper 'ThreadStatic' field initialization</source>
        <target state="translated">不正確的 'ThreadStatic' 欄位初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldDescription">
        <source>'ThreadStatic' only affects static fields. When applied to instance fields, it has no impact on behavior.</source>
        <target state="translated">'ThreadStatic' 只會影響靜態欄位。套用到執行個體欄位時，不會影響行為。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldMessage">
        <source>Ensure 'ThreadStatic' is only used with static fields</source>
        <target state="translated">確保 'ThreadStatic' 只用於靜態欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldTitle">
        <source>'ThreadStatic' only affects static fields</source>
        <target state="translated">'ThreadStatic' 只會影響靜態欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentExceptionThrowHelperTitle">
        <source>Use ArgumentException throw helper</source>
        <target state="translated">使用 ArgumentException 擲回協助程式</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentNullExceptionThrowHelperTitle">
        <source>Use ArgumentNullException throw helper</source>
        <target state="translated">使用 ArgumentNullException 擲回協助程式</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentOutOfRangeExceptionThrowHelperTitle">
        <source>Use ArgumentOutOfRangeException throw helper</source>
        <target state="translated">使用 ArgumentOutOfRangeException 擲回協助程式</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">使用 Array.Empty</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is often unwanted when it is implicitly used as a Span or Memory value. Use the AsSpan method to avoid the copy.</source>
        <target state="translated">陣列值中以 Range 為基礎的索引子會產生陣列中要求部分的複本。隱含使用此複本作為 Span 或 Memory 值時，通常不需此複本。請使用 AsSpan 方法來避免使用此複本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerMessage">
        <source>Use '{0}' instead of the '{1}'-based indexer on '{2}' to avoid creating unnecessary data copies</source>
        <target state="translated">在 '{2}' 上使用 '{0}' 代替以 '{1}' 為基礎的索引子，以避免建立不必要的資料複本</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAStringCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on a string</source>
        <target state="translated">請對字串使用 '{0}'，而不要使用範圍索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAnArrayCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on an array</source>
        <target state="translated">請對陣列使用 '{0}'，而不要使用範圍索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerTitle">
        <source>Use AsSpan or AsMemory instead of Range-based indexers when appropriate</source>
        <target state="translated">在適當情況下使用 AsSpan 或 AsMemory 取代以 Range 為基礎的索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfStringRangeIndexerDescription">
        <source>The Range-based indexer on string values produces a copy of requested portion of the string. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">字串值中以 Range 為基礎的索引子會產生字串中要求部分的複本。隱含使用此複本作為 ReadOnlySpan 或 ReadOnlyMemory 值時，通常不需此複本。請使用 AsSpan 方法來避免使用不必要的複本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanReadOnlyInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">陣列值中以 Range 為基礎的索引子會產生陣列中要求部分的複本。隱含使用此複本作為 ReadOnlySpan 或 ReadOnlyMemory 值時，通常不需此複本。請使用 AsSpan 方法來避免使用不必要的複本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextDescription">
        <source>When inside a Task-returning method, use the async version of methods, if they exist.</source>
        <target state="translated">在　Task-returning　方法內時，請使用方法的非同步版本 (如果存在)。</target>
        <note>{Locked="Task"}</note>
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextMessage">
        <source>'{0}' synchronously blocks. Await '{1}' instead.</source>
        <target state="translated">'{0}' 會同步封鎖。請改用 Await '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextMessage_NoAlternative">
        <source>'{0}' synchronously blocks. Use await instead.</source>
        <target state="translated">'{0}' 會同步封鎖。請改用 await。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextTitle">
        <source>Call async methods when in an async method</source>
        <target state="translated">在使用非同步方法時呼叫非同步方法</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryToken">
        <source>Use antiforgery tokens in ASP.NET Core MVC controllers</source>
        <target state="translated">使用 ASP.NET Core MVC 控制器中的 antiforgery 權杖</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenDescription">
        <source>Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</source>
        <target state="translated">在不驗證 antiforgery 權杖的情況下處理 POST、PUT、PATCH 或 DELETE 要求，可能會容易受到跨站台偽造要求攻擊。跨站台偽造要求攻擊可將惡意要求從已驗證的使用者傳送到 ASP.NET Core MVC 控制器。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenMessage">
        <source>Method {0} handles a {1} request without performing antiforgery token validation. You also need to ensure that your HTML form sends an antiforgery token.</source>
        <target state="translated">方法 {0} 會在不驗證 antiforgery 權杖的情況下處理 {1} 要求。您也必須確保 HTML 表單傳送 antiforgery 權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedCodeFixTitle">
        <source>Replace with 'CancellationToken.ThrowIfCancellationRequested'</source>
        <target state="translated">請以 'CancellationToken.ThrowIfCancellationRequested' 取代</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedDescription">
        <source>'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has.</source>
        <target state="translated">'ThrowIfCancellationRequested' 會自動檢查是否已取消權杖，如果是，則會擲回 'OperationCanceledException'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedMessage">
        <source>Use 'ThrowIfCancellationRequested' instead of checking 'IsCancellationRequested' and throwing 'OperationCanceledException'</source>
        <target state="translated">請使用 'ThrowIfCancellationRequested'，而不是檢查 'IsCancellationRequested' 並擲回 'OperationCanceledException'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedTitle">
        <source>Use 'ThrowIfCancellationRequested'</source>
        <target state="translated">請使用 'ThrowIfCancellationRequested'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatDescription">
        <source>Cache and use a 'CompositeFormat' instance as the argument to this formatting operation, rather than passing in the original format string. This reduces the cost of the formatting operation.</source>
        <target state="translated">快取並使用 'CompositeFormat' 執行個體做為此格式化作業的引數，而不是傳遞原始格式字串。這樣可降低格式化作業的成本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatMessage">
        <source>Cache a 'CompositeFormat' for repeated use in this formatting operation</source>
        <target state="translated">在此格式化作業中，針對重複使用的 'CompositeFormat' 進行緩存</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatTitle">
        <source>Use 'CompositeFormat'</source>
        <target state="translated">使用 'CompositeFormat'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeDescription">
        <source>Using concrete types avoids virtual or interface call overhead and enables inlining.</source>
        <target state="translated">使用具象類型可以避免虛擬或介面呼叫額外負荷，並啟用內嵌。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForFieldMessage">
        <source>Change type of field '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">將欄位 '{0}' 的類型從 '{1}' 變更為 '{2}' 以提高效能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForLocalMessage">
        <source>Change type of variable '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">將變數 '{0}' 的類型從 '{1}' 變更為 '{2}' 以提高效能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForMethodReturnMessage">
        <source>Change return type of method '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">將方法 '{0}' 的傳回型別從 '{1}' 變更為 '{2}' 以提高效能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForParameterMessage">
        <source>Change type of parameter '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">將參數 '{0}' 的類型從 '{1}' 變更為 '{2}' 以提高效能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForPropertyMessage">
        <source>Change type of property '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">將屬性 '{0}' 的型別從 '{1}' 變更為 '{2}' 以提高效能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeTitle">
        <source>Use concrete types when possible for improved performance</source>
        <target state="translated">盡可能使用具象類型以提高效能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="translated">使用容器層級存取原則</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="translated">因為未指定任何存取原則識別碼，所以使權杖無法撤銷。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS.</source>
        <target state="translated">如果可行的話，請考慮從共用存取簽章 (SAS) 改為使用 Azure 的角色型存取控制。如果您仍需要使用 SAS，請於建立 SAS 時使用容器層級存取原則。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttribute">
        <source>Use DefaultDllImportSearchPaths attribute for P/Invokes</source>
        <target state="translated">針對 P/Invoke 使用 DefaultDllImportSearchPaths 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeDescription">
        <source>By default, P/Invokes using DllImportAttribute probe a number of directories, including the current working directory for the library to load. This can be a security issue for certain applications, leading to DLL hijacking.</source>
        <target state="translated">根據預設，使用 DllImportAttribute 的 P/Invoke 會探查許多目錄，包括目前正在運作的目錄以供程式庫載入。這可能成為部分應用程式的安全性問題，導致 DLL 劫持。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeMessage">
        <source>The method {0} didn't use DefaultDllImportSearchPaths attribute for P/Invokes.</source>
        <target state="translated">方法 {0} 未針對 P/Invoke 使用 DefaultDllImportSearchPaths 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDisabledMarshallingEquivalentCodeFix">
        <source>Use equivalent code that works when marshalling is disabled</source>
        <target state="translated">使用停用封送處理時可運作的對等程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdDescription">
        <source>'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'.</source>
        <target state="translated">'Environment.CurrentManagedThreadId' 比 'Thread.CurrentThread.ManagedThreadId' 更簡單快速。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdFix">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="translated">請使用 'Environment.CurrentManagedThreadId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdMessage">
        <source>Use 'Environment.CurrentManagedThreadId' instead of 'Thread.CurrentThread.ManagedThreadId'</source>
        <target state="translated">請使用 'Environment.CurrentManagedThreadId' 而非 'Thread.CurrentThread.ManagedThreadId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdTitle">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="translated">請使用 'Environment.CurrentManagedThreadId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdDescription">
        <source>'Environment.ProcessId' is simpler and faster than 'Process.GetCurrentProcess().Id'.</source>
        <target state="translated">'Environment.ProcessId' 比 'Process.GetCurrentProcess().Id' 更簡單快速。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdFix">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">請使用 'Environment.ProcessId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdMessage">
        <source>Use 'Environment.ProcessId' instead of 'Process.GetCurrentProcess().Id'</source>
        <target state="translated">請使用 'Environment.ProcessId' 而非 'Process.GetCurrentProcess().Id'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdTitle">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">請使用 'Environment.ProcessId'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathDescription">
        <source>'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'.</source>
        <target state="translated">'Environment.ProcessPath' 比 'Process.GetCurrentProcess().MainModule.FileName' 更簡單快速。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathFix">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="translated">請使用 'Environment.ProcessPath'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathMessage">
        <source>Use 'Environment.ProcessPath' instead of 'Process.GetCurrentProcess().MainModule.FileName'</source>
        <target state="translated">請使用 'Environment.ProcessPath' 而非 'Process.GetCurrentProcess().MainModule.FileName'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathTitle">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="translated">請使用 'Environment.ProcessPath'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIndexer">
        <source>Use indexer</source>
        <target state="translated">使用索引子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseInvariantVersion">
        <source>Use an invariant version</source>
        <target state="translated">使用固定版本</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">定義有作業系統叫用方法，且在 .NET Framework 類別庫中具有對等的功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">使用 Win32 API 的受控對等項</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">使用 Win32 API 的受控對等項</target>
        <note />
      </trans-unit>
      <trans-unit id="UseObjectDisposedExceptionThrowHelperTitle">
        <source>Use ObjectDisposedException throw helper</source>
        <target state="translated">使用 ObjectDisposedException 擲回協助程式</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">非語言的字串比較作業不會將 StringComparison 參數設為 Ordinal 或 OrdinalIgnoreCase。將參數明確設定為 StringComparison.Ordinal 或 StringComparison.OrdinalIgnoreCase 時，程式碼通常會更快速、精確且更可靠。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal string comparison</source>
        <target state="translated">使用序數字串比較</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableDescription">
        <source>Enumerable.Count() potentially enumerates the sequence while a Length/Count property is a direct access.</source>
        <target state="translated">當長度/計數屬性為直接存取時，Enumerable.Count() 可能會列舉序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableMessage">
        <source>Use the "{0}" property instead of Enumerable.Count()</source>
        <target state="translated">使用 "{0}" 屬性而非 Enumerable.Count()</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableTitle">
        <source>Use Length/Count property instead of Count() when available</source>
        <target state="translated">可行時，使用長度/計數屬性而非 Count()</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest-Shamir-Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="translated">使用有足夠金鑰大小的 Rivest-Shamir-Adleman (RSA) 加密演算法</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="translated">當使用的金鑰大小太小時，加密演算法易面臨暴力密碼破解攻擊。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">非對稱式加密演算法 {0} 的金鑰大小小於 2048。請改為切換成至少有 2048 金鑰大小的 RSA、ECDH 或 ECDSA 演算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountDescription">
        <source>'Regex.Count' is simpler and faster than 'Regex.Matches(...).Count'.</source>
        <target state="translated">'Regex.Count' 比 'Regex.Matches(...).Count' 更簡單、更快速。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountFix">
        <source>Use 'Regex.Count'</source>
        <target state="translated">使用 'Regex.Count'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountMessage">
        <source>Use 'Regex.Count' instead of 'Regex.Matches(...).Count'</source>
        <target state="translated">使用 'Regex.Count' 而不是 'Regex.Matches(...).Count'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountTitle">
        <source>Use 'Regex.Count'</source>
        <target state="translated">使用 'Regex.Count'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchDescription">
        <source>'Regex.IsMatch' is simpler and faster than 'Regex.Match(...).Success'.</source>
        <target state="translated">'Regex.IsMatch' 比 'Regex.Match(...).Success' 更簡單、更快速。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchFix">
        <source>Use 'Regex.IsMatch'</source>
        <target state="translated">使用 'Regex.IsMatch'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchMessage">
        <source>Use 'Regex.IsMatch' instead of 'Regex.Match(...).Success'</source>
        <target state="translated">使用 'Regex.IsMatch' 而不是 'Regex.Match(...).Success'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchTitle">
        <source>Use 'Regex.IsMatch'</source>
        <target state="translated">使用 'Regex.IsMatch'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesCodeFixTitle">
        <source>Use 'SearchValues'</source>
        <target state="translated">使用 'SearchValues'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesDescription">
        <source>Using a cached 'SearchValues' instance is more efficient than passing values to 'IndexOfAny'/'ContainsAny' directly.</source>
        <target state="translated">使用快取的 'SearchValues' 執行個體比直接將值傳遞至 'IndexOfAny'/'ContainsAny' 更有效率。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesMessage">
        <source>Use a cached 'SearchValues' instance for improved searching performance</source>
        <target state="translated">使用快取的 'SearchValues' 執行個體改善搜尋效能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesTitle">
        <source>Use a cached 'SearchValues' instance</source>
        <target state="translated">使用快取的 'SearchValues' 執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="translated">透過 HTTPS 使用的應用程式必須使用安全 Cookie。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">使用 SharedAccessProtocol HttpsOnly</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">HTTPS 會加密網路流量。請使用 HttpsOnly 而非 HttpOrHttps，以確保網路流量一律會經過加密來避免敏感性資料洩漏。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly.</source>
        <target state="translated">如果可行的話，請考慮從共用存取簽章 (SAS) 改為使用 Azure 的角色型存取控制。如果您仍需要使用 SAS，請指定 SharedAccessProtocol.HttpsOnly。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatCodeFixTitle">
        <source>Use 'AsSpan' with 'string.Concat'</source>
        <target state="translated">請將 'AsSpan' 與 'string.Concat' 一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatDescription">
        <source>It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator.</source>
        <target state="translated">使用 'AsSpan' 和 'string.Concat' 比 'Substring' 和串連運算子更有效率。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatMessage">
        <source>Use span-based 'string.Concat' and 'AsSpan' instead of 'Substring'</source>
        <target state="translated">請使用範圍型的 'string.Concat' 和 'AsSpan'，而非 'Substring'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatTitle">
        <source>Use span-based 'string.Concat'</source>
        <target state="translated">請使用範圍型的 'string.Concat'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillCodeFixTitle">
        <source>Use 'Clear()'</source>
        <target state="translated">使用 'Clear()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillDescription">
        <source>It is more efficient to use 'Clear', instead of 'Fill' with default value.</source>
        <target state="translated">使用 'Clear' 比使用預設值的 'Fill' 更有效率。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillMessage">
        <source>Prefer 'Span&lt;T&gt;.Clear()' instead of 'Span&lt;T&gt;.Fill(default)'</source>
        <target state="translated">優先使用 'Span&lt;T&gt;.Clear()'，而不是 'Span&lt;T&gt;.Fill(default)'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillTitle">
        <source>Prefer 'Clear' over 'Fill'</source>
        <target state="translated">優先使用 'Clear' 而不是 'Fill'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFixTitle">
        <source>Use 'StartsWith'</source>
        <target state="translated">使用 'StartsWith'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroDescription">
        <source>It is both clearer and faster to use 'StartsWith' instead of comparing the result of 'IndexOf' to zero.</source>
        <target state="translated">使用 'StartsWith' 更清楚且更快速，而不是將 'IndexOf' 的結果與 0 比較。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroMessage">
        <source>Use 'StartsWith' instead of comparing the result of 'IndexOf' to 0</source>
        <target state="translated">使用 'StartsWith' 而不是將 'IndexOf' 的結果與 0 比較</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroTitle">
        <source>Use 'StartsWith' instead of 'IndexOf'</source>
        <target state="translated">使用 'StartsWith' 代替 'IndexOf'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersDescription">
        <source>'string.Contains(char)' is available as a better performing overload for single char lookup.</source>
        <target state="translated">'string.Contains(char)' 對單一字元查閱而言可做為更佳的執行多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.Contains(char)' instead of 'string.Contains(string)' when searching for a single character</source>
        <target state="translated">請在搜尋單一字元時使用 'string.Contains(char)' 而非 'string.Contains(string)'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersTitle">
        <source>Use char literal for a single character lookup</source>
        <target state="translated">請為單一字元查閱使用字元常值</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareCodeFixTitle">
        <source>Use 'string.Equals'</source>
        <target state="translated">請使用 'string.Equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareDescription">
        <source>It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero.</source>
        <target state="translated">使用 'string.Equals' 更清楚也更快，而不是將 'string.Compare' 的結果與 0 比較。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareMessage">
        <source>Use 'string.Equals' instead of comparing the result of 'string.Compare' to 0</source>
        <target state="translated">請使用 'string.Equals' 而不是將 'string.Compare' 的結果與 0 比較</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareTitle">
        <source>Use 'string.Equals'</source>
        <target state="translated">請使用 'string.Equals'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersDescription">
        <source>The char overload is a better performing overload than a string with a single char.</source>
        <target state="translated">與具有單一字元的字串相比，字元多載的效能較佳。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.{0}(char)' instead of 'string.{0}(string)' when you have a string with a single char</source>
        <target state="translated">字串含有單一字元時，請使用 'string.{0}(char)'，而非 'string.{0}(string)'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersTitle">
        <source>Use char overload</source>
        <target state="translated">使用字元多載</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperDescription">
        <source>Throw helpers are simpler and more efficient than an if block constructing a new exception instance.</source>
        <target state="translated">擲回協助程式比建構新例外狀況執行個體的 if 區塊更簡單且更有效率。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperFix">
        <source>Use '{0}.{1}'</source>
        <target state="translated">使用 '{0}.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperMessage">
        <source>Use '{0}.{1}' instead of explicitly throwing a new exception instance</source>
        <target state="translated">使用 '{0}.{1}'，而不是明確擲回新的例外狀況執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringDescription">
        <source>Platform compatibility analyzer requires a valid platform name and version.</source>
        <target state="translated">平台相容性分析器需要有效的平台名稱和版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringInvalidVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Use a version with 2{2} parts for this platform.</source>
        <target state="translated">版本 '{0}' 對平台 '{1}' 而言無效。請為此平台使用 2{2} 部分的版本。</target>
        <note>Version '7' is not valid for platform 'windows'. Use a version with 2-4 parts for this platform.</note>
      </trans-unit>
      <trans-unit id="UseValidPlatformStringNoVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Do not use versions for this platform.</source>
        <target state="translated">版本 '{0}' 對平台 '{1}' 而言無效。請不要為此平台使用版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringTitle">
        <source>Use valid platform string</source>
        <target state="translated">請使用有效的平台字串</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringUnknownPlatform">
        <source>The platform '{0}' is not a known platform name</source>
        <target state="translated">平台 '{0}' 不是已知的平台名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyDescription">
        <source>ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</source>
        <target state="translated">應直接等候從成員引動過程傳回的 ValueTask。若在已得知完成 ValueTask 之前，嘗試多次使用 ValueTask 或直接存取其結果，可能會導致發生例外狀況或損毀。忽略這類 ValueTask 可能表示發生功能性 Bug，而且可能會降低效能。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_AccessingIncompleteResult">
        <source>ValueTask instances should not have their result directly accessed unless the instance has already completed. Unlike Tasks, calling Result or GetAwaiter().GetResult() on a ValueTask is not guaranteed to block until the operation completes. If you can't simply await the instance, consider first checking its IsCompleted property (or asserting it's true if you know that to be the case).</source>
        <target state="translated">除非 ValueTask 執行個體已經完成，否則不應直接存取其結果。與 Tasks 不同，在 ValueTask 上呼叫 Result 或 GetAwaiter().GetResult() 無法保證會封鎖到作業完成為止。如果您無法耐心等候該執行個體，請考慮先檢查其 IsCompleted 屬性 (或如果您知道確實為 true，則可判斷其為 true)。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_DoubleConsumption">
        <source>ValueTask instances should only be consumed once, such as via an await. Consuming the same ValueTask instance multiple times can result in exceptions and data corruption.</source>
        <target state="translated">ValueTask 執行個體應只能使用一次，例如透過 await。多次使用同一個 ValueTask 執行個體可能會導致發生例外狀況及資料損毀。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_General">
        <source>ValueTask instances returned from method calls should be directly awaited, returned, or passed as an argument to another method call. Other usage, such as storing an instance into a local or a field, is likely an indication of a bug, as ValueTask instances must only ever be consumed once.</source>
        <target state="translated">從方法呼叫傳回的 ValueTask 執行個體應直接等候、傳回，或作為引數傳遞給另一個方法呼叫。其他使用方式，例如將執行個體儲存到本機或欄位，則可能表示發生 Bug，原因是 ValueTask 執行個體一律只能使用一次。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_Unconsumed">
        <source>ValueTask instances returned from method calls should always be used, typically awaited. Not doing so often represents a functional bug, but even if it doesn't, it can result in degraded performance if the target method pools objects for use with ValueTasks.</source>
        <target state="translated">應一律使用 (通常為等候) 從方法呼叫傳回的 ValueTask 執行個體。未使用通常表示發生功能性 Bug，但即便不是這種情況，如果目標方法集區物件搭配 ValueTasks 使用，也可能會造成效能下降。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyTitle">
        <source>Use ValueTasks correctly</source>
        <target state="translated">正確使用 ValueTasks</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">處理不受信任資料的 XML，可能會載入危險的外部參考，應使用具有安全解析程式或已停用 DTD 處理的 XmlReader，加以限制。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader for 'DataSet.ReadXml()'</source>
        <target state="translated">將 XmlReader 用於 'DataSet.ReadXml()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader for 'XmlSerializer.Deserialize()'</source>
        <target state="translated">將 XmlReader 用於 'XmlSerializer.Deserialize()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader for 'XmlSchema.Read()'</source>
        <target state="translated">將 XmlReader 用於 'XmlSchema.Read()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader for XmlValidatingReader constructor</source>
        <target state="translated">將 XmlReader 用於 XmlValidatingReader 建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader for XPathDocument constructor</source>
        <target state="translated">將 XmlReader 用於 XPathDocument 建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the '{0}.{1}' method is potentially unsafe. It may enable Document Type Definition (DTD) which can be vulnerable to denial of service attacks, or might use an XmlResolver which can be vulnerable to information disclosure. Use an overload that takes a XmlReader instance instead, with DTD processing disabled and no XmlResolver.</source>
        <target state="translated">'{0}.{1}' 方法的此多載可能不安全。其會啟用文件類型定義 (DTD) ，而如此可能會容易受到阻斷服務攻擊，或可能會使用 XmlResolver，而造成資訊洩漏。請改用採用 XmlReader 執行個體的多載，並停用 DTD 處理以及禁用 XmlResolver。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsesPreviewTypeParameterMessage">
        <source>'{0}' uses the preview type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}' 使用預覽類型 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsesPreviewTypeParameterMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' uses the preview type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}' 使用預覽類型 '{1}'，因此必須加入預覽功能。如需詳細資訊，請參閱 {2}。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>