<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../MicrosoftNetCoreAnalyzersResources.resx">
    <body>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">将 "NonSerialized" 特性添加到此字段。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">添加 Serializable 特性</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherMode">
        <source>Review cipher mode usage with cryptography experts</source>
        <target state="translated">与加密专家一起审阅密码模式使用情况</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These cipher modes might be vulnerable to attacks. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">这些密码模式可能易受攻击。请考虑使用建议的模式(CBC、CTS)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>Review the usage of cipher mode '{0}' with cryptography experts. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">与加密专家一起审阅密码模式“{0}”的使用情况。请考虑使用建议的模式(CBC、CTS)。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">特性的字符串文本参数未正确解析 URL、GUID 或版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'</source>
        <target state="translated">在“{0}”的构造函数中，将参数“{1}”的当前值“{2}”更改为可正确解析为“{3}”的某个值</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'</source>
        <target state="translated">在“{0}”的构造函数中，将参数“{1}”的值(此值当前为空字符串(""))更改为可正确解析为“{2}”的某个值</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">特性字符串文本应正确分析</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidConstArraysCodeFixTitle">
        <source>Extract to static readonly field</source>
        <target state="translated">提取到 static readonly 字段</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidConstArraysDescription">
        <source>Constant arrays passed as arguments are not reused when called repeatedly, which implies a new array is created each time. Consider extracting them to 'static readonly' fields to improve performance if the passed array is not mutated within the called method.</source>
        <target state="translated">重复调用时不会重复使用作为参数传递的常量数组，这意味着每次都会创建一个新数组。如果所传递的数组未在调用的方法中发生改变，请考虑将其提取到 "static readonly" 字段以提高性能。</target>
        <note>{Locked="static readonly"}</note>
      </trans-unit>
      <trans-unit id="AvoidConstArraysMessage">
        <source>Prefer 'static readonly' fields over constant array arguments if the called method is called repeatedly and is not mutating the passed array</source>
        <target state="translated">如果调用的方法重复调用且未改变传递的数组，则首选 "static readonly" 字段而不是常量数组参数</target>
        <note>{Locked="static readonly"}</note>
      </trans-unit>
      <trans-unit id="AvoidConstArraysTitle">
        <source>Avoid constant arrays as arguments</source>
        <target state="translated">不要将常量数组作为参数</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsDescription">
        <source>Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead. Single use 'JsonSerializerOptions' instances can substantially degrade the performance of your application.</source>
        <target state="translated">避免为每个序列化操作创建新的“JsonSerializerOptions”实例。请改为缓存和重用实例。仅使用“JsonSerializerOptions”实例可能会显著降低应用程序的性能。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsMessage">
        <source>Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead.</source>
        <target state="translated">避免为每个序列化操作创建新的“JsonSerializerOptions”实例。请改为缓存和重用实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsTitle">
        <source>Cache and reuse 'JsonSerializerOptions' instances</source>
        <target state="translated">缓存并重用“JsonSerializerOptions”实例</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersDescription">
        <source>Marshalling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshalling operation.</source>
        <target state="translated">"StringBuilder" 的封送处理总是会创建一个本机缓冲区副本，这导致一个封送处理操作出现多次分配。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersMessage">
        <source>Avoid 'StringBuilder' parameters for P/Invokes. Consider using a character buffer instead.</source>
        <target state="translated">不要对 P/Invoke 使用 "StringBuilder" 参数。请考虑改用字符缓冲区。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersTitle">
        <source>Avoid 'StringBuilder' parameters for P/Invokes</source>
        <target state="translated">不要对 P/Invoke 使用 "StringBuilder" 参数</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">.NET Framework 类库提供用于检索自定义特性的方法。默认情况下，这些方法搜索特性继承层次结构。通过密封特性，将无需搜索继承层次结构并可提高性能。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">避免使用非密封特性</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">避免使用非密封特性</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">避免不必要的长度为零的数组分配。改用 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations</source>
        <target state="translated">避免长度为零的数组分配</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">在不使用 SerializationBinder 的情况下对不受信任的数据进行反序列化，以限制反序列化对象图中的对象类型时，方法“{0}”不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</source>
        <target state="translated">请确保在调用 BinaryFormatter.Deserialize 之前设置 BinaryFormatter.Binder</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">在不使用 SerializationBinder 的情况下对不受信任的数据进行反序列化，以限制反序列化对象图中的对象类型时，方法“{0}”不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetTitle">
        <source>Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</source>
        <target state="translated">在未设置 BinaryFormatter.Binder 的情况下，请不要调用 BinaryFormatter.Deserialize</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect BinaryFormatter deserialization without a SerializationBinder set, then disable rule CA2300, and enable rules CA2301 and CA2302.</source>
        <target state="translated">反序列化不受信任的数据时，方法“{0}”不安全。如果需要在未设置 SerializationBinder 的情况下改为检测 BinaryFormatter 反序列化，则请禁用 CA2300 规则，并启用 CA2301 和 CA2302 规则。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">对不受信任的数据进行反序列化时，方法“{0}”不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer BinaryFormatter</source>
        <target state="translated">请勿使用不安全的反序列化程序 BinaryFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyDescription">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.</source>
        <target state="translated">“Buffer.BlockCopy” 需要为 “count” 参数复制字节数。使用 “Array.Length” 可能与需要复制的字节数不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyLengthMessage">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.</source>
        <target state="translated">“Buffer.BlockCopy” 需要为 “count” 参数复制字节数。使用 “Array.Length” 可能与需要复制的字节数不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyLengthTitle">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument</source>
        <target state="translated">“Buffer.BlockCopy” 需要为 “count” 参数复制字节数</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).</source>
        <target state="translated">表示 Dispose 实现的方法没有调用 GC.SuppressFinalize；或不表示 Dispose 实现的方法调用了 GC.SuppressFinalize；或方法调用了 GC.SuppressFinalize 并传递 this (在 Visual Basic 中是 Me)以外的某个值。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">将 {0} 更改为调用 {1}。这将使引入终结器的派生类型无需重新实现 "IDisposable" 即可调用它。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">将 {0} 更改为调用 {1}。这样可以防止当对象已释放并超出范围时，对该对象进行不必要的终止。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">{0} 对除自身以外的其他对象调用 {1}。请更改调用站点，改而传递 "this" (在 Visual Basic 中为 "Me")。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">{0} 调用 {1}，该方法通常只在 "IDisposable.Dispose" 实现内部调用。有关详细信息，请参见 IDisposable 模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">Dispose 方法应调用 SuppressFinalize</target>
        <note />
      </trans-unit>
      <trans-unit id="CommaSeparator">
        <source>, </source>
        <target state="translated">, </target>
        <note>Separator used for separating list of platform names: {API} is only supported on: {‘windows’, ‘browser’, ‘linux’}</note>
      </trans-unit>
      <trans-unit id="ConstantExpectedApplicationDescription">
        <source>ConstantExpected attribute is not applied correctly on the parameter.</source>
        <target state="translated">ConstantExpected 属性未正确应用于参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedApplicationTitle">
        <source>Incorrect usage of ConstantExpected attribute</source>
        <target state="translated">ConstantExpected 属性的用法不正确</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedAttributExpectedMessage">
        <source>The ConstantExpected attribute is required for the parameter due to the parent method annotation</source>
        <target state="translated">由于父方法批注，参数需要 ConstantExpected 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedIncompatibleConstantTypeMessage">
        <source>The '{0}' value is not compatible with parameter type of '{1}'</source>
        <target state="translated">"{0}" 值与 "{1}" 的参数类型不兼容</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvalidBoundsMessage">
        <source>The '{0}' value does not fit within the parameter value bounds of '{1}' to '{2}'</source>
        <target state="translated">"{0}" 值不符合 "{1}" 到 "{2}" 的参数值界限</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvalidMessage">
        <source>The constant is not of the same '{0}' type as the parameter</source>
        <target state="translated">常量与参数的 "{0}" 类型不同</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvertedRangeMessage">
        <source>The Min and Max values are inverted</source>
        <target state="translated">已反转最小值和最大值</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedNotConstantMessage">
        <source>The argument should be a constant for optimal performance</source>
        <target state="translated">参数应是一个常量，以获得最佳性能</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedNotSupportedMessage">
        <source>The '{0}' type is not supported for ConstantExpected attribute</source>
        <target state="translated">ConstantExpected 特性不支持 "{0}" 类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedOutOfBoundsMessage">
        <source>The constant does not fit within the value bounds of '{0}' to '{1}'</source>
        <target state="translated">该常量不适合 "{0}" 到 "{1}" 的值边界内</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedUsageDescription">
        <source>The parameter expects a constant for optimal performance.</source>
        <target state="translated">该参数需要一个常量来获得最佳性能。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedUsageTitle">
        <source>A constant is expected for the parameter</source>
        <target state="translated">参数需要常量</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">对不受信任的输入进行反序列化处理时，反序列化 {0} 对象是不安全的。“{1}”是或派生自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type found in deserializable object graph</source>
        <target state="translated">在可反序列化的对象图中找到不安全的数据集或数据表类型</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}. Ensure that the auto-generated type is never deserialized with untrusted data.</source>
        <target state="translated">在使用基于 IFormatter 的序列化程序对不受信任的输入进行反序列化处理时，反序列化 {0} 对象是不安全的。“{1}”是或派生自 {0}。请确保自动生成的类型绝不使用不受信任的数据进行反序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in auto-generated serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">自动生成的可序列化类型中不安全的数据集或数据表易受远程代码执行攻击</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">对不受信任的输入进行反序列化处理时，反序列化 {0} 对象是不安全的。“{1}”是或派生自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks</source>
        <target state="translated">已反序列化的对象图中不安全的数据集或数据表可能易受远程代码执行攻击</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}.</source>
        <target state="translated">在使用基于 IFormatter 的序列化程序来反序列化不受信任的输入时，反序列化 {0} 对象是不安全的。“{1}”是或派生自 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">可序列化类型中不安全的数据集或数据表易受远程代码执行攻击</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">对不受信任的输入进行反序列化处理时，反序列化 {0} 对象是不安全的。“{1}”是或派生自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type</source>
        <target state="translated">可序列化类型中不安全的数据集或数据表</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">对不受信任的输入进行反序列化处理时，反序列化 {0} 对象是不安全的。“{1}”是或派生自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type in web deserializable object graph</source>
        <target state="translated">Web 可反序列化对象图中的不安全数据集或数据表类型</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data. Make sure that auto-generated class containing the '{0}' call is not deserialized with untrusted data.</source>
        <target state="translated">对不受信任的数据进行反序列化处理时，方法“{0}”不安全。请确保包含“{0}”调用的自动生成的类没有使用不受信任的数据进行反序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedTitle">
        <source>Ensure auto-generated class containing DataSet.ReadXml() is not used with untrusted data</source>
        <target state="translated">请确保包含 DataSet.ReadXml() 的自动生成的类没有与不受信任的数据一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">对不受信任的数据进行反序列化处理时，方法“{0}”不安全</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlTitle">
        <source>Do not use DataSet.ReadXml() with untrusted data</source>
        <target state="translated">请勿将 DataSet.ReadXml() 与不受信任的数据一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">对不受信任的数据进行反序列化处理时，方法“{0}”不安全</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlTitle">
        <source>Do not use DataTable.ReadXml() with untrusted data</source>
        <target state="translated">请勿将 DataTable.ReadXml() 与不受信任的数据一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheck">
        <source>HttpClients should enable certificate revocation list checks</source>
        <target state="translated">HttpClients 应启用证书吊销列表检查</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheckMessage">
        <source>HttpClient is created without enabling CheckCertificateRevocationList</source>
        <target state="translated">在不启用 CheckCertificateRevocationList 的情况下创建了 HttpClient</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="translated">不将证书添加到根存储</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="translated">如果将证书添加到操作系统受信任的根证书中，则会增加非法证书验证不当的风险</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIV">
        <source>Do not use CreateEncryptor with non-default IV</source>
        <target state="translated">不要将 CreateEncryptor 与非默认 IV 结合使用</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIVMessage">
        <source>Symmetric encryption uses non-default initialization vector, which could be potentially repeatable</source>
        <target state="translated">对称加密使用非默认初始化向量，该向量可能是可重复的</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">在 ASP.NET Core 中使用安全 Cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">设置 Cookie 时设置 CookieOptions.Secure = true</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCount">
        <source>Do Not Use Weak Key Derivation Function With Insufficient Iteration Count</source>
        <target state="translated">请勿使用迭代计数不足的弱密钥派生功能</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCountMessage">
        <source>Use at least {0} iterations when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">基于密码派生加密密钥时，请至少进行 {0} 次迭代。默认情况下，Rfc2898DeriveByte 的 IterationCount 仅为 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsDescription">
        <source>Older protocol versions of Transport Layer Security (TLS) are less secure than TLS 1.2 and TLS 1.3, and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk.</source>
        <target state="translated">旧协议版本的传输层安全性(TLS)不如 TLS 1.2 和 TLS 1.3 安全，更有可能存在新的漏洞。请避免使用旧协议版本，以将风险降至最低。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsMessage">
        <source>Transport Layer Security protocol version '{0}' is deprecated.  Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">传输层安全协议版本“{0}”已被弃用。请使用“无”，让操作系统选择一个版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsTitle">
        <source>Do not use deprecated SslProtocols values</source>
        <target state="translated">请勿使用已弃用的 SslProtocols 值</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivesFromPreviewClassMessage">
        <source>'{0}' derives from preview class '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">“{0}”派生自预览类“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivesFromPreviewClassMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' derives from preview class '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3}.“{0}”派生自预览类“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesDescription">
        <source>An assembly has to opt into preview features before using them.</source>
        <target state="translated">程序集必须先选择加入预览功能，然后才能使用它们。</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesMessage">
        <source>Using '{0}' requires opting into preview features. See {1} for more information.</source>
        <target state="translated">使用“{0}”需要选择加入预览功能。有关详细信息，请参阅 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesMessageWithCustomMessagePlaceholder">
        <source>{2} Using '{0}' requires opting into preview features. See {1} for more information.</source>
        <target state="translated">{2} 使用“{0}”需要选择加入预览功能。有关详细信息，请参阅 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesTitle">
        <source>This API requires opting into preview features</source>
        <target state="translated">此 API 需要选择加入预览功能</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">实现 System.IDisposable 的类型将声明一些字段，这些字段所属的类型还实现 IDisposable。字段的 Dispose 方法不由声明类型的 Dispose 方法调用。若要修复此规则的违规行为，如果你负责分配和释放该字段持有的非托管资源，请在其所属类型实现 IDisposable 的字段上调用 Dispose。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>'{0}' contains field '{1}' that is of IDisposable type '{2}', but it is never disposed. Change the Dispose method on '{0}' to call Close or Dispose on this field.</source>
        <target state="translated">“{0}”包含 IDisposable 类型“{2}”的字段“{1}”，但从未进行释放。请更改“{0}”上的 Dispose 方法以对此字段调用 Close 或 Dispose。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">应释放可释放的字段</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">如果某类型实现了 System.IDisposable 且包含建议使用非托管资源的字段，则该类型不会实现 Object.Finalize 所述的终结器。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">可释放类型应声明终结器</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">可释放类型应声明终结器</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.</source>
        <target state="translated">实现 System.IDisposable 的类型继承自实现 IDisposable 的类型。继承类型的 Dispose 方法不调用父类型的 Dispose 方法。若要修复此规则的违规行为，请在 Dispose 方法中调用 base.Dispose。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Ensure that method '{0}' calls '{1}' in all possible control flow paths</source>
        <target state="translated">请确保方法“{0}”在所有可能的控制流路径中都调用“{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose methods should call base class dispose</source>
        <target state="translated">Dispose 方法应调用基类释放</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</source>
        <target state="translated">如果在对某个可释放对象的所有引用超出范围之前未显式释放该对象，则当垃圾回收器运行该对象的终结器时，会在某个不确定时间释放该对象。由于可能会发生阻止该对象的终结器运行的意外事件，因此应改为显式释放该对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">使用推荐的 Dispose 模式以确保“{0}”创建的对象释放于所有路径上。如果可能，将创建包装在 "using" 语句或 "using" 声明中。否则，使用 try-finally 模式，在 try 区域之前声明一个专用的本地变量，在 "finally" 区域中对非 null 值进行无条件 Dispose 调用，比如，"x?.Dispose()"。如果对象显式释放在 try 区域内或释放所有权转让给另一个对象或方法，则在这样的操作之后立即将 "null" 分配给本地变量，以防止在 "finally" 中进行双重释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all exception paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">使用推荐的 Dispose 模式以确保“{0}”创建的对象在所有异常路径上释放。如果可能，将创建包装在 "using" 语句或 "using" 声明中。否则，使用 try-finally 模式，在 try 区域之前声明一个专用的本地变量，在 "finally" 区域中对非 null 值进行无条件 Dispose 调用，比如，"x?.Dispose()"。如果对象显式释放在 try 区域内或释放所有权已转让给另一个对象或方法，则在这样的操作之后立即将 "null" 分配给本地变量，以防止在 "finally" 中进行双重释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedMessage">
        <source>Call System.IDisposable.Dispose on object created by '{0}' before all references to it are out of scope</source>
        <target state="translated">在对 System.IDisposable.Dispose 的所有引用超出范围之前，在“{0}”创建的对象上对其进行调用</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage">
        <source>Object created by '{0}' is not disposed along all exception paths. Call System.IDisposable.Dispose on the object before all references to it are out of scope.</source>
        <target state="translated">“{0}”创建的对象未按所有异常路径释放。请在对 System.IDisposable.Dispose 的所有引用超出范围之前，在该对象上对其进行调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose objects before losing scope</source>
        <target state="translated">丢失范围之前释放对象</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPath">
        <source>Do Not Add Archive Item's Path To The Target File System Path</source>
        <target state="translated">请勿将存档项的路径添加到目标文件系统路径</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription">
        <source>When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</source>
        <target state="translated">从存档中提取文件并使用该存档项的路径时，请检查该路径是否安全。存档路径可以是相对路径，并可能导致文件系统在预期的文件系统目标路径之外进行访问，从而导致恶意配置更改并通过 "lay-and-wait" 方法执行远程代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage">
        <source>When creating path for '{0} in method {1}' from relative archive item path to extract file and the source is an untrusted zip archive, make sure to sanitize relative archive item path '{2} in method {3}'</source>
        <target state="translated">从提取文件的相对存档项路径为“方法 {1} 中的 {0}”创建路径时，如果源为不受信任的 ZIP 存档文件，请确保净化相对存档项路径“方法 {3} 中的 {2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">请勿通过 URL 添加架构</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">XmlSchemaCollection.Add 方法的此项重载在内部启用了对所使用的 XML 读取器实例的 DTD 处理，并使用 UrlResolver 解析外部 XML 实体。这会导致信息泄漏。文件系统的内容或供计算机处理 XML 的网络共享中的内容可能会暴露给攻击者。此外，攻击者可将其用作 DoS 向量。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">Add 方法的此项重载可能不安全，因为它可能会解析危险的外部引用</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesDescription">
        <source>By setting critical TokenValidationParameter validation delegates to true, important authentication safeguards are disabled which can lead to tokens from any issuer or expired tokens being wrongly validated.</source>
        <target state="translated">将重要 TokenValidationParameter 验证委托设置为 true，会禁用重要身份验证安全措施，这可能导致来自任何颁发者的令牌或过期令牌被错误验证。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesMessage">
        <source>The {0} is set to a function that is always returning true. By setting the validation delegate, you are overriding default validation and by always returning true, this validation is completely disabled.</source>
        <target state="translated">{0} 被设置为总是返回 true 的函数。通过设置验证委托，将覆盖默认验证，并且通过始终返回 true，此验证将被完全禁用。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesTitle">
        <source>Do not always skip token validation in delegates</source>
        <target state="translated">不要总是跳过委托中的令牌验证</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">不安全反序列化是一种漏洞，当不受信任的数据被用来滥用应用程序的逻辑、实施拒绝服务(dos)攻击，甚至在反序列化时执行任意代码时发生。当应用程序反序列化由其控制的不受信任的数据时，恶意用户通常可能会滥用这些反序列化功能。具体来说，在反序列化过程中调用危险方法。成功的不安全反序列化攻击可能允许攻击者执行攻击，例如 dos 攻击、身份验证绕过和远程代码执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class '{0}', method '{1}' can directly or indirectly call dangerous method '{2}'</source>
        <target state="translated">反序列化类'{0}'的实例时，方法'{1}'可以直接或间接调用危险方法'{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationTitle">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">在反序列化中不要调用危险方法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesDescription">
        <source>Enumerable.Cast&lt;T&gt; and Enumerable.OfType&lt;T&gt; require compatible types to function expectedly.  
The generic cast (IL 'unbox.any') used by the sequence returned by Enumerable.Cast&lt;T&gt; will throw InvalidCastException at runtime on elements of the types specified.  
The generic type check (C# 'is' operator/IL 'isinst') used by Enumerable.OfType&lt;T&gt; will never succeed with elements of types specified, resulting in an empty sequence.  
Widening and user defined conversions are not supported with generic types.</source>
        <target state="translated">Enumerable.Cast&lt;T&gt;和 Enumerable.OfType&lt;T&gt; 需要兼容类型才能正常工作。 
Enumerable.Cast&lt;T&gt; 返回的序列使用的泛型强制转换 (IL 'unbox.any') 将在运行时对指定类型的元素引发 InvalidCastException。 
Enumerable.OfType&lt;T&gt; 使用的泛型类型检查 (C# 'is' operator/IL 'isinst') 将从不会成功与指定类型的元素一起使用，从而导致一个空序列。
泛型类型不支持扩大转换和用户定义的转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageCast">
        <source>Type '{0}' is incompatible with type '{1}' and cast attempts will throw InvalidCastException at runtime</source>
        <target state="translated">类型'{0}'与类型'{1}'不兼容，强制转换尝试将在运行时引发 InvalidCastException</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageOfType">
        <source>This call will always result in an empty sequence because type '{0}' is incompatible with type '{1}'</source>
        <target state="translated">此调用将始终导致空序列，因为类型'{0}'与类型'{1}'不兼容</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesTitle">
        <source>Do not call Enumerable.Cast&lt;T&gt; or Enumerable.OfType&lt;T&gt; with incompatible types</source>
        <target state="translated">请勿使用不兼容的类型调用 Enumerable.Cast&lt;T&gt; 或 Enumerable.OfType&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueMessage">
        <source>Do not call {0} on an {1} value</source>
        <target state="translated">请勿对 {1} 值调用 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueTitle">
        <source>Do not call ToImmutableCollection on an ImmutableCollection value</source>
        <target state="translated">请勿对 ImmutableCollection 值调用 ToImmutableCollection</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsDescription">
        <source>TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.  Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</source>
        <target state="translated">TaskCompletionSource 具有采用 TaskCreationOptions 的控制基础任务的构造函数，以及采用任务中存储的对象状态的构造函数。如果意外地传递 TaskContinuationOptions 而不是 TaskCreationOptions，会导致调用将选项视为状态。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsFix">
        <source>Replace TaskContinuationOptions with TaskCreationOptions.</source>
        <target state="translated">将 TaskContinuationOptions 替换为 TaskCreationOptions。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsMessage">
        <source>Argument contains TaskContinuationsOptions enum instead of TaskCreationOptions enum</source>
        <target state="translated">参数包含 TaskContinuationsOptions 枚举而不是 TaskCreationOptions 枚举</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsTitle">
        <source>Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</source>
        <target state="translated">传递到 TaskCompletionSource 构造函数的参数应为 TaskCreationOptions 枚举，而不是 TaskContinuationOptions 枚举</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerDescription">
        <source>Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear.</source>
        <target state="translated">除非使用具有 TaskScheduler 的任一重载，否则不要创建任务。默认是在 TaskScheduler.Current 上进行调度，但这将导致死锁。可使用 TaskScheduler.Default 在线程池上进行调度，或显示传递 TaskScheduler.Current 以明确表达意图。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerMessage">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">不要在未传递 TaskScheduler 的情况下创建任务</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerTitle">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">不要在未传递 TaskScheduler 的情况下创建任务</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerDescription">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;.</source>
        <target state="translated">将终结器添加到派生自 MemoryManager&lt;T&gt; 的类型可能使内存在仍被 Span&lt;T&gt; 使用时得到释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerMessage">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;</source>
        <target state="translated">将终结器添加到派生自 MemoryManager&lt;T&gt; 的类型可能使内存在仍被 Span&lt;T&gt; 使用时得到释放</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerTitle">
        <source>Do not define finalizers for types derived from MemoryManager&lt;T&gt;</source>
        <target state="translated">请勿为派生自 MemoryManager&lt;T&gt; 的类型定义终结器</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">请勿禁用证书验证</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">证书可以帮助认证服务器的身份。客户端应该验证服务器的证书，以确保将请求发送到预期的服务器。如果 ServerCertificateValidationCallback 始终返回 "true"，那么任何证书都将通过验证。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">已将 ServerCertificateValidationCallback 设置为通过始终返回 true 来接受任何服务器证书的一个函数。请确保服务器证书已经过验证，从而验证要接收请求的服务器的标识。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">请勿禁用 HTTP 标头检查</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">HTTP 标头检查可对在响应标头中找到的回车和换行符(\r 和 \n)进行编码。这种编码有助于避免注入攻击，此类攻击会利用应答标头包含的不受信任数据的应用程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">请勿禁用 HTTP 标头检查</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHttpClientCRLCheckDescription">
        <source>Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid.</source>
        <target state="translated">将 CheckCertificateRevocationList 属性设置为 true 时，如果使用 HttpClient 而不提供特定于平台的处理程序(WinHttpHandler、CurlHandler 或 HttpClientHandler)，则将允许 HttpClient 将被吊销的证书作为有效证书接受。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">请勿禁用请求验证</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">请求验证是 ASP.NET 中的一项功能，用于检查 HTTP 请求，并确定它们是否包含潜在危险内容。此检查可针对 URL 查询字符串中的标记或代码、cookie 或可能因恶意目的而添加的已发布表单值进行防护。因此，通常需要此验证并且应该保持启用以进行深度防御。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">{0} 已禁用请求验证</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">请勿禁用较强加密的 SChannel 使用</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommended to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">建议从 .NET Framework 4.6、System.Net.ServicePointManager 和 System.Net.Security.SslStream 类开始以使用新的协议。旧的协议具有协议缺陷，不受支持。将 Switch.System.Net.DontEnableSchUseStrongCrypto 设置为 true 将使用旧的弱加密检查并选择退出协议迁移。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">{0} 禁用 TLS 1.2 并且启用 SSLv3</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksDescription">
        <source>Token validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation.</source>
        <target state="translated">令牌验证检查确保在验证令牌时，对所有方面进行分析和验证。关闭验证会允许不受信任的令牌通过验证，从而导致安全漏洞。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksMessage">
        <source>TokenValidationParameters.{0} should not be set to false as it disables important validation</source>
        <target state="translated">TokenValidationParameters。{0} 不应设置为 false，因为它会禁用重要验证</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksTitle">
        <source>Do not disable token validation checks</source>
        <target state="translated">请勿禁用令牌验证检查</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsMessage">
        <source>Do not set Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols to true.  Setting this switch limits Windows Communication Framework (WCF) to using Transport Layer Security (TLS) 1.0, which is insecure and obsolete.</source>
        <target state="translated">不要将 Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols 设置为 true。设置此开关会将 Windows Communication Framework (WCF)限制为使用传输层安全性(TLS) 1.0，而该层不安全且已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsTitle">
        <source>Do not disable ServicePointManagerSecurityProtocols</source>
        <target state="translated">不禁用 ServicePointManagerSecurityProtocols</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyDescription">
        <source>Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'. The former already checks whether the key exists, and will not throw if it does not.</source>
        <target state="translated">不要使用 “Dictionary.ContainsKey(key)” 保护 “Dictionary.Remove(key)”。后者已检查密钥是否存在，并且如果不存在则不会引发。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyMessage">
        <source>Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'</source>
        <target state="translated">不要使用 “Dictionary.ContainsKey(key)” 保护 “Dictionary.Remove(key)”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyTitle">
        <source>Unnecessary call to 'Dictionary.ContainsKey(key)'</source>
        <target state="translated">对 “Dictionary.ContainsKey(key)” 的不必要调用</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsDescription">
        <source>Do not guard 'Add(item)' or 'Remove(item)' with 'Contains(item)' for the set. The former two already check whether the item exists and will return if it was added or removed.</source>
        <target state="translated">对于集，不要使用 "Contains(item)" 来保护 "Add(item)" 或 "Remove(item)"。前两者已检查是否存在项，并将在添加或移除项时返回。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsMessage">
        <source>Do not guard '{0}' with '{1}'</source>
        <target state="translated">不使用“{1}”保护“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsTitle">
        <source>Unnecessary call to 'Contains(item)'</source>
        <target state="translated">对 "Contains(item)" 的不必要调用</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificate">
        <source>Do not hard-code certificate</source>
        <target state="translated">请勿硬编码证书</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateDescription">
        <source>Hard-coded certificates in source code are vulnerable to being exploited.</source>
        <target state="translated">源代码中的硬编码证书易受攻击。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded certificate from '{2}' in method '{3}'</source>
        <target state="translated">找到了潜在安全漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的硬编码证书污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKey">
        <source>Do not hard-code encryption key</source>
        <target state="translated">请勿编码加密密钥</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyDescription">
        <source>SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hard-coded value.</source>
        <target state="translated">SymmetricAlgorithm 的 .Key 属性或方法的 rgbKey 参数永远都不得是硬编码值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded key from '{2}' in method '{3}'</source>
        <target state="translated">找到了潜在安全漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的硬编码密钥污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="translated">默认情况下，“受信任的根证书颁发机构”证书存储配置有一组符合 Microsoft 根证书程序的公共 CA。由于所有受信任的根 CA 都可为任意域颁发证书，因此攻击者可能会选择你自行安装的某个安全性较弱或可强迫的 CA 进行攻击 - 易受攻击、恶意或可强迫的 CA 会降低整个系统的安全性。更糟糕的是，这些攻击者可能很难被察觉。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">当可以跨应用程序域边界直接访问对象时，则认为该对象具有弱标识。如果某线程尝试获取具有弱标识的对象上的锁，则该线程可能会被其他应用程序域中持有同一对象的锁的另一线程阻止。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">不要锁定具有弱标识的对象</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">不要锁定具有弱标识的对象</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersDescription">
        <source>A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.</source>
        <target state="translated">方法将文本字符串作为参数传递到构造函数或 .NET Framework 类库中的方法，该字符串应该是可本地化字符串。若要修复此规则的违规行为，将文本字符串替换为通过 ResourceManager 类的实例检索到的字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersMessage">
        <source>Method '{0}' passes a literal string as parameter '{1}' of a call to '{2}'. Retrieve the following string(s) from a resource table instead: "{3}".</source>
        <target state="translated">方法“{0}”将文本字符串作为“{2}”的调用的参数“{1}”进行传递。改为从资源表检索以下字符串:“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersTitle">
        <source>Do not pass literals as localized parameters</source>
        <target state="translated">请不要将文本作为本地化参数传递</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">用户代码永不会引发不够具体或运行时保留的异常类型。这样会使原来的错误难以检测和调试。如有可能引发此异常实例，请使用其他异常类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime</source>
        <target state="translated">异常类型 {0} 是运行时保留的</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific</source>
        <target state="translated">异常类型 {0} 不够具体</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">不要引发保留的异常类型</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">请勿序列化具有 Pointer 字段的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">Pointer 不是“类型安全”，因为无法保证它们所指向内存的正确性。因此，序列化具有 Pointer 字段的类型是危险的，它可能允许攻击者控制指针。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type</source>
        <target state="translated">可序列化类型上的 Pointer 字段 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">不使用帐户共享访问签名</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">共享访问签名(SAS)是使用 Azure 存储的任何应用程序的安全模型的重要部分，它们应为没有帐户密钥的客户端提供对存储帐户的有限安全权限。通过服务 SAS可使用的所有操作也可通过帐户 SAS 实现，即帐户 SAS 的功能太过强大。因此，建议使用服务 SAS 更仔细地委派访问权限。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">使用服务 SAS 而不是帐户 SAS 实现精细访问控制和容器级访问策略</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">不要使用损坏的加密算法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">存在可能在计算方面破坏此算法的攻击。这使得攻击者可以破坏它本应提供的加密保证。根据此加密算法的类型和应用情况，可能会使攻击者读取加密消息、篡改加密消息、伪造数字签名、篡改哈希内容，或以其他方式危害任何基于该算法的加密系统。将加密用法替换为密钥长度大于或等于 128 位的 AES 算法(AES-256、AES-192 和 AES-128 均可)。将哈希用法替换为 SHA-2 系列中的哈希函数，例如 SHA512、SHA384 或 SHA256。将数字签名用法替换为密钥长度大于等于 2048 位的 RSA，或者密钥长度大于等于 256 位的 ECDSA。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">{0} 使用损坏的加密算法 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingDescription">
        <source>The ConfigureAwaitOptions.SuppressThrowing option is only supported with the non-generic Task, not a Task&lt;TResult&gt;.  To use it with a Task&lt;TResult&gt;, first cast to the base Task.</source>
        <target state="translated">ConfigureAwaitOptions.SuppressThrowing 仅支持用于非泛型任务，不可用于 Task&lt;TResult&gt;。若要将它用于 Task&lt;TResult&gt;，请先强制转换为基本任务。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingMessage">
        <source>The ConfigureAwaitOptions.SuppressThrowing option is only supported with the non-generic Task</source>
        <target state="translated">只有非泛型任务才支持 ConfigureAwaitOptions.SuppressThrowing</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingTitle">
        <source>Do not use ConfigureAwaitOptions.SuppressThrowing with Task&lt;TResult&gt;</source>
        <target state="translated">不要对 Task&lt;TResult&gt; 使用 ConfigureAwaitOptions.SuppressThrowing</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedDescription">
        <source>For non-empty collections, CountAsync() and LongCountAsync() enumerate the entire sequence, while AnyAsync() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">对于非空集合，CountAsync() 和 LongCountAsync() 将枚举整个序列，而 AnyAsync() 将在第一项或满足条件的第一项处停止。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedMessage">
        <source>{0}() is used where AnyAsync() could be used instead to improve performance</source>
        <target state="translated">使用的是 {0}()，但本可以使用 AnyAsync() 来提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedTitle">
        <source>Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used</source>
        <target state="translated">如果可以使用 AnyAsync()，请勿使用 CountAsync() 或 LongCountAsync()</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedDescription">
        <source>For non-empty collections, Count() and LongCount() enumerate the entire sequence, while Any() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">对于非空集合，Count() 和 LongCount() 将枚举整个序列，而 Any() 将在第一项或满足条件的第一项处停止。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedMessage">
        <source>{0}() is used where Any() could be used instead to improve performance</source>
        <target state="translated">如果可以使用 Any()，请改为使用 {0}() 来提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedTitle">
        <source>Do not use Count() or LongCount() when Any() can be used</source>
        <target state="translated">如果可以使用 Any()，请勿使用 Count() 或 LongCount()</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCreateEncryptorWithNonDefaultIVDescription">
        <source>Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</source>
        <target state="translated">对称加密应始终使用非可重复的初始化向量，以防止字典攻击。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="translated">不使用数字签名算法(DSA)</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="translated">DSA 太弱，无法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">非对称加密算法 {0} 较弱。请转而切换到至少具有 2048 位密钥大小的 RSA、ECDH 或者 ECDSA 算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">请勿使用弃用的安全协议</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">使用弃用的安全协议而不是系统默认协议将有风险。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">以硬编码方式使用弃用的安全协议 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">该集合是可直接索引的。在此处查看 LINQ 会导致不必要的分配和 CPU 工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly.</source>
        <target state="translated">不要在可索引的集合上使用 Enumerable 方法。而是直接使用集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections</source>
        <target state="translated">不要在可索引的集合上使用 Enumerable 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomness">
        <source>Do not use insecure randomness</source>
        <target state="translated">请勿使用不安全的随机性</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessDescription">
        <source>Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated. Use a cryptographically strong random number generator if an unpredictable value is required, or ensure that weak pseudo-random numbers aren't used in a security-sensitive manner.</source>
        <target state="translated">使用加密的弱伪随机数生成器，攻击者可以预测将生成的安全敏感值。如果需要不可预测的值，请使用加密的强随机数生成器，或确保不以安全敏感的方式使用弱伪随机数。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessMessage">
        <source>{0} is an insecure random number generator. Use cryptographically secure random number generators when randomness is required for security.</source>
        <target state="translated">{0} 是不安全的随机数生成器。当需要随机性以确保安全性时，请使用加密的安全随机数生成器。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">请勿使用已过时的密钥派生功能</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">基于密码的密钥派生应结合使用 PBKDF2 和 SHA-2。请避免使用 PasswordDeriveBytes，因为它会生成 PBKDF1 密钥。还需避免使用 Rfc2898DeriveBytes.CryptDeriveKey，因为它不使用迭代计数或加盐。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">调用已过时的密钥派生功能 {0}。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersDescription">
        <source>String parameters passed by value with the 'OutAttribute' can destabilize the runtime if the string is an interned string.</source>
        <target state="translated">如果字符串是暂存的字符串，则具有 "OutAttribute" 的值传递的字符串参数可能使运行时不稳定。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersMessage">
        <source>Do not use the 'OutAttribute' for string parameter '{0}' which is passed by value. If marshalling of modified data back to the caller is required, use the 'out' keyword to pass the string by reference instead.</source>
        <target state="translated">不要将 "OutAttribute" 用于通过值传递的字符串参数“{0}”。如果需要将已修改的数据整理回调用方，请改用 " out" 关键字通过引用传递字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersTitle">
        <source>Do not use 'OutAttribute' on string parameters for P/Invokes</source>
        <target state="translated">请勿对 P/Invokes 的字符串参数使用 "OutAttribute"</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesComparerMessage">
        <source>Do not pass an argument with value type '{0}' to the 'Equals' method on 'ReferenceEqualityComparer'. Due to value boxing, this call to 'Equals' can return an unexpected result. Consider using 'EqualityComparer' instead, or pass reference type arguments if you intend to use 'ReferenceEqualityComparer'.</source>
        <target state="translated">不要将值类型为 '{0}' 的参数传递到 'ReferenceEqualityComparer' 上的 'Equals' 方法。由于数据封装，此对 'Equals' 的调用可能会返回意外的结果。如果打算使用 'ReferenceEqualityComparer'，请考虑改用 'EqualityComparer' 或传递引用类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesDescription">
        <source>Value type typed arguments are uniquely boxed for each call to this method, therefore the result can be unexpected.</source>
        <target state="translated">每次调用此方法时，值类型的类型化参数都唯一装箱，因此结果可能是意外的。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesMethodMessage">
        <source>Do not pass an argument with value type '{0}' to 'ReferenceEquals'. Due to value boxing, this call to 'ReferenceEquals' can return an unexpected result. Consider using 'Equals' instead, or pass reference type arguments if you intend to use 'ReferenceEquals'.</source>
        <target state="translated">请勿将值类型为 '{0}' 的参数传递到 'ReferenceEquals'。由于数据封装，此对 'ReferenceEquals' 的调用可能会返回意外的结果。如果打算使用 'ReferenceEquals'，请考虑改用 'Equals' 或传递引用类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesTitle">
        <source>Do not use ReferenceEquals with value types</source>
        <target state="translated">不要使用具有值类型的 ReferenceEquals</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsDescription">
        <source>Stack space allocated by a stackalloc is only released at the end of the current method's invocation.  Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</source>
        <target state="translated">Stackalloc 分配的堆栈空间仅在当前方法的调用结束时释放。 在循环中使用它可能会导致无限堆栈增长和最终堆栈溢出条件。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsMessage">
        <source>Potential stack overflow. Move the stackalloc out of the loop.</source>
        <target state="translated">潜在的堆栈溢出。将 stackalloc 移出循环。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsTitle">
        <source>Do not use stackalloc in loops</source>
        <target state="translated">不要循环使用 stackalloc</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">频率较高的定期活动会使 CPU 处于忙状态并且干扰具有节能功能(关闭显示器和硬盘)的空闲计时器。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">不要使用阻止电源状态更改的计时器</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">不要使用阻止电源状态更改的计时器</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPath">
        <source>Do not use unsafe DllImportSearchPath value</source>
        <target state="translated">请勿使用不安全的 DllImportSearchPath 值</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathDescription">
        <source>There could be a malicious DLL in the default DLL search directories. Or, depending on where your application is run from, there could be a malicious DLL in the application's directory. Use a DllImportSearchPath value that specifies an explicit search path instead. The DllImportSearchPath flags that this rule looks for can be configured in .editorconfig.</source>
        <target state="translated">默认 DLL 搜索目录中可能有恶意 DLL。或者，根据应用程序的运行位置，应用程序的目录中可能有恶意 DLL。请改为使用指定显式搜索路径的 DllImportSearchPath 值。可在 .editorconfig 中配置此规则查找的 DllImportSearchPath 标志。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathMessage">
        <source>Use of unsafe DllImportSearchPath value {0}</source>
        <target state="translated">使用了不安全的 DllImportSearchPath 值 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskDescription">
        <source>Using 'WaitAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="translated">对单个任务使用 “WaitAll” 可能导致性能丢失、等待或返回该任务。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskFix">
        <source>Replace 'WaitAll' with single 'Wait'</source>
        <target state="translated">将 “WaitAll” 替换为单个 “Wait”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskTitle">
        <source>Do not use 'WaitAll' with a single task</source>
        <target state="translated">不要对单个任务使用 “WaitAll”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">不要使用弱加密算法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">加密算法随时间的推移而变弱，因为攻击成为攻击者获取更多计算的推动因素。根据此加密算法的类型和应用情况，其加密强度逐渐降低可能会使攻击者读取加密消息、篡改加密消息、伪造数字签名、篡改哈希内容，或以其他方式危害任何基于该算法的加密系统。将加密用法替换为密钥长度大于或等于 128 位的 AES 算法(AES-256、AES-192 和 AES-128 均可)。将哈希用法替换为 SHA-2 系列中的哈希函数，例如 SHA-2 512、SHA-2 384 或 SHA-2 256。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">{0} 使用弱加密算法 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Ensure Key Derivation Function algorithm is sufficiently strong</source>
        <target state="translated">确保密钥派生功能算法足够强大</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="translated">Rfc2898DeriveBytes 类的某些实现允许在构造函数参数中指定哈希算法或在 HashAlgorithm 属性中覆盖它。如果指定了哈希算法，则它应为 SHA-256 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} might be using a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password.</source>
        <target state="translated">{0} 可能正在使用弱哈希算法。请使用 SHA256、SHA384 或 SHA512 根据密码创建强密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFInsufficientIterationCountDescription">
        <source>When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).</source>
        <target state="translated">基于用户提供的输入(如密码)派生加密密钥时，请使用足够大的迭代计数(至少 100,000 次)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskDescription">
        <source>Using 'WhenAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="translated">将 “WhenAll” 与单个任务一起使用可能导致性能丢失、等待或返回任务。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskFix">
        <source>Replace 'WhenAll' call with argument</source>
        <target state="translated">将 “WhenAll” 调用替换为参数</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskTitle">
        <source>Do not use 'WhenAll' with a single task</source>
        <target state="translated">不要对单个任务使用 “WhenAll”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">请勿使用 XslTransform</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">请勿使用 XslTransform。它对具有潜在危险的外部引用并没有限制。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedDescription">
        <source>Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic.</source>
        <target state="translated">提供功能 “DynamicInterfaceCastableImplementationAttribute” 特性化接口需要默认接口成员功能，这在 Visual Basic 中不受支持。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedMessage">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="translated">不支持在 Visual Basic 中提供 “DynamicInterfaceCastableImplementation” 接口</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedTitle">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="translated">不支持在 Visual Basic 中提供 “DynamicInterfaceCastableImplementation” 接口</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledDescription">
        <source>Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.</source>
        <target state="translated">在禁用运行时封送时使用需要运行时封送的功能将导致运行时异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageAutoLayoutTypes">
        <source>Types with '[StructLayout(LayoutKind.Auto)]' require runtime marshalling to be enabled</source>
        <target state="translated">具有 “[StructLayout(LayoutKind.Auto)]” 的类型需要启用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageByRefParameters">
        <source>By-ref parameters require runtime marshalling to be enabled</source>
        <target state="translated">By-ref 参数需要启用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageDelegateUsage">
        <source>Delegates with managed types as parameters or the return type require runtime marshalling to be enabled in the assembly where the delegate is defined</source>
        <target state="translated">以托管类型作为参数或返回类型的委派需要在定义该委派的程序集中启用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageHResultSwapping">
        <source>HResult-swapping requires runtime marshalling to be enabled</source>
        <target state="translated">HResult-swapping 需要启用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageLCIDConversionAttribute">
        <source>Using 'LCIDConversionAttribute' requires runtime marshalling to be enabled</source>
        <target state="translated">使用 “LCIDConversionAttribute” 需要启用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageManagedParameterOrReturnTypes">
        <source>Managed parameter or return types require runtime marshalling to be enabled</source>
        <target state="translated">托管参数或返回类型需要启用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageSetLastError">
        <source>Setting SetLastError to 'true' requires runtime marshalling to be enabled</source>
        <target state="translated">将 SetLastError 设置为 “true” 需要启用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageVarargPInvokes">
        <source>Varadic P/Invoke signatures require runtime marshalling to be enabled</source>
        <target state="translated">Varadic P/Invoke 签名需要启用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledTitle">
        <source>Property, type, or attribute requires runtime marshalling</source>
        <target state="translated">属性、类型或特性需要运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldIsPreviewTypeMessage">
        <source>'{0}''s type contains the preview type '{1}' and requires opting into preview features. See {2} for more information.</source>
        <target state="translated">“{0}”类型包含预览类型“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldIsPreviewTypeMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}''s type contains the preview type '{1}' and requires opting into preview features. See {2} for more information.</source>
        <target state="translated">{3}.“{0}”类型包含预览类型“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsDescription">
        <source>Forward the 'CancellationToken' parameter to methods to ensure the operation cancellation notifications gets properly propagated, or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token.</source>
        <target state="translated">将 "CancellationToken" 参数转发给方法来确保操作取消通知得到正确传播，或者在 "CancellationToken.None" 中显式传递，以指示有意不传播令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsMessage">
        <source>Forward the '{0}' parameter to the '{1}' method or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token</source>
        <target state="translated">将“{0}”参数转发给“{1}”方法，或在 "CancellationToken.None" 中显式传递以指示有意不传播令牌</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsTitle">
        <source>Forward the 'CancellationToken' parameter to methods</source>
        <target state="translated">将 "CancellationToken" 参数转发给方法</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="translated">避免 hardcoding SecurityProtocolType {0}, 转而使用 SecurityProtocolType. SystemDefault 允许操作系统选择要使用的最佳传输层安全性协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="translated">避免 hardcoding SecurityProtocolType 值</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsDescription">
        <source>Current Transport Layer Security protocol versions may become deprecated if vulnerabilities are found. Avoid hardcoding SslProtocols values to keep your application secure. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">如果发现漏洞，则当前传输层安全协议版本可能会被弃用。请避免硬编码 SslProtocols 值，以确保应用程序安全。请使用“无”，让操作系统选择一个版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsMessage">
        <source>Avoid hardcoding SslProtocols '{0}' to ensure your application remains secure in the future. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">请避免硬编码 SslProtocols“{0}”，以确保应用程序在将来保持安全。请使用“无”，让操作系统选择一个版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsTitle">
        <source>Avoid hardcoded SslProtocols values</source>
        <target state="translated">避免硬编码的 SslProtocols 值</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyDescription">
        <source>Generic math interfaces require the derived type itself to be used for the self recurring type parameter.</source>
        <target state="translated">泛型数学接口要求将派生类型本身用于自重复类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyMessage">
        <source>The '{0}' requires the '{1}' type parameter to be filled with the derived type '{2}'</source>
        <target state="translated">"{0}" 需要使用派生类型 "{2}" 填充 "{1}" 类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyTitle">
        <source>Use correct type parameter</source>
        <target state="translated">使用正确的类型参数</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementInterfacesOnDynamicCastableImplementation">
        <source>Implement inherited interfaces</source>
        <target state="translated">实现继承的接口</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewInterfaceMessage">
        <source>'{0}' implements the preview interface '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">“{0}”实现预览界面“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewInterfaceMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' implements the preview interface '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3}.“{0}”实现预览界面“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewMethodMessage">
        <source>'{0}' implements the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">“{0}”实现预览方法“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewMethodMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' implements the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3}.“{0}”实现预览方法“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">某引用类型声明了显式静态构造函数。要修复与该规则的冲突，请在声明它时初始化所有静态数据，并删除静态构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">以内联方式初始化引用类型的静态字段</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">在声明这些字段时初始化“{0}”中的所有静态字段，并删除静态构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">某值类型声明了显式静态构造函数。要修复与该规则的冲突，请在声明它时初始化所有静态数据，并删除静态构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">以内联方式初始化值类型的静态字段</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyChangeToTwoArgumentCodeFixTitle">
        <source>Change to call the two argument constructor, pass null for the message.</source>
        <target state="translated">更改为调用两个参数构造函数，请为消息传递 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">调用了 ArgumentException 异常类型或其派生异常类型的默认(无参数)构造函数，或将不正确的字符串参数传递给 ArgumentException. 异常类型或其派生异常类型的参数化构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyFlipArgumentOrderCodeFixTitle">
        <source>Swap the arguments order</source>
        <target state="translated">交换参数顺序</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">方法 {0} 将参数名“{1}”作为变量 {2} 传递给构造函数 {3}。请将此参数替换为一则说明性消息并在正确的位置传递参数名。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">方法 {0} 将“{1}”作为变量 {2} 传递给构造函数 {3}。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter</source>
        <target state="translated">调用 {0} 构造函数，该函数包含 message 和/或 paramName 参数</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate argument exceptions correctly</source>
        <target state="translated">正确实例化参数异常</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationDescription">
        <source>Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise.</source>
        <target state="translated">使用 “DynamicInterfaceCastableImplementationAttribute” 特性化的类型充当实现 “IDynamicInterfaceCastable” 类型的类型的接口实现。因此，它必须提供在继承的接口中定义的所有成员的实现，因为实现 “IDynamicInterfaceCastable” 的类型将不会提供它们。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationMessage">
        <source>Type '{0}' has the 'DynamicInterfaceCastableImplementationAttribute' applied to it but does not provide an implementation of all interface members defined in inherited interfaces</source>
        <target state="translated">类型“{0}”已应用 “DynamicInterfaceCastableImplementationAttribute”，但不提供继承接口中定义的所有接口成员的实现</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationTitle">
        <source>All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface</source>
        <target state="translated">在父接口中声明的所有成员必须在 DynamicInterfaceCastableImplementation-attributed 接口中具有实现</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Ensure that the JavaScriptSerializer is initialized without a JavaScriptTypeResolver specified, or initialized with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">使用通过 SimpleTypeResolver 初始化的 JavaScriptSerializer 反序列化不可信数据时，{0} 方法不安全。请确保初始化 JavaScriptSerializer 但不指定 JavaScriptTypeResolver，或使用限制为反序列化对象图形中的对象类型的 JavaScriptTypeResolver 初始化该对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverTitle">
        <source>Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</source>
        <target state="translated">请确保 JavaScriptSerializer 在反序列化之前未使用 SimpleTypeResolver 初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Initialize JavaScriptSerializer without a JavaScriptTypeResolver specified, or initialize with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">使用通过 SimpleTypeResolver 初始化的 JavaScriptSerializer 反序列化不可信数据时，{0} 方法不安全。请初始化 JavaScriptSerializer 但不指定 JavaScriptTypeResolver，或使用限制为反序列化对象图形中的对象类型的 JavaScriptTypeResolver 初始化该对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverTitle">
        <source>Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</source>
        <target state="translated">请勿通过使用 SimpleTypeResolver 的 JavaScriptSerializer 进行反序列化</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">对不信任的输入进行反序列化时，允许反序列化任意类型这一行为是不安全的。使用反序列化 JsonSerializer 时，请使用 TypeNameHandling.None；对于“无”以外的值，请使用 SerializationBinder 限制反序列化的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerTitle">
        <source>Do not deserialize with JsonSerializer using an insecure configuration</source>
        <target state="translated">请勿使用不安全的配置对 JsonSerializer 进行反序列化</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">对不信任的输入进行反序列化时，允许反序列化任意类型这一行为是不安全的。使用 JsonSerializerSettings 时，请使用 TypeNameHandling.None；对于不是“无”的值，请使用 SerializationBinder 限制反序列化的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsTitle">
        <source>Do not use insecure JsonSerializerSettings</source>
        <target state="translated">请勿使用不安全的 JsonSerializerSettings</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">对不信任的输入进行反序列化时，允许反序列化任意类型这一行为是不安全的。使用反序列化 JsonSerializer 时，请使用 TypeNameHandling.None；对于“无”以外的值，请使用 SerializationBinder 限制反序列化的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerTitle">
        <source>Ensure that JsonSerializer has a secure configuration when deserializing</source>
        <target state="translated">请确保在反序列化时 JsonSerializer 具有安全配置</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, ensure TypeNameHandling.None is specified, or for values other than None, ensure a SerializationBinder is specified to restrict deserialized types.</source>
        <target state="translated">对不信任的输入进行反序列化时，允许反序列化任意类型这一行为是不安全的。使用 JsonSerializerSettings 时，请确保已指定 TypeNameHandling.None；对于不是“无”的值，请确保指定了 SerializationBinder 来限制反序列化的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsTitle">
        <source>Ensure that JsonSerializerSettings are secure</source>
        <target state="translated">请确保 JsonSerializerSetting 是安全的</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingDescription">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.  If you need to instead detect Json.NET deserialization when a SerializationBinder isn't specified, then disable rule CA2326, and enable rules CA2327, CA2328, CA2329, and CA2330.</source>
        <target state="translated">使用“无”以外的 TypeNameHandling 值时，进行 JSON 反序列化可能不安全。如需在未指定 SerializationBinder 时检测 Json.NET 反序列化，请禁用规则 CA2326 并启用规则 CA2327、CA2328、CA2329 和 CA2330。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingMessage">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.</source>
        <target state="translated">使用“无”以外的 TypeNameHandling 值时，进行 JSON 反序列化可能不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingTitle">
        <source>Do not use TypeNameHandling values other than None</source>
        <target state="translated">请勿使用“无”以外的 TypeNameHandling 值</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">对不受信任的数据进行反序列化时，方法“{0}”不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer LosFormatter</source>
        <target state="translated">请勿使用不安全的反序列化程序 LosFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMethodDeclaredOnImplementationTypeStatic">
        <source>Convert to static method</source>
        <target state="translated">转换为静态方法</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMethodDeclaredOnImplementationTypeStaticMayProduceInvalidCode">
        <source>Converting an instance method to a static method may produce invalid code</source>
        <target state="translated">将实例方法转换为静态方法可能生成无效的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeParameterlessConstructorPublic">
        <source>Make the constructor that takes zero parameters 'public'</source>
        <target state="translated">使采用零参数的构造函数成为 “public”</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">不可序列化类型的实例字段在可序列化类型中声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">字段 {0} 是可序列化类型 {1} 的成员，但该字段是不可序列化的类型 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">标记所有不可序列化的字段</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageDescription">
        <source>The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set.</source>
        <target state="translated">NeutralResourcesLanguage 特性将通知资源管理器用于显示程序集非特定区域性的资源的语言。这样可提高所加载的第一个资源的查找性能，并可减少工作集。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageMessage">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">用 NeutralResourcesLanguageAttribute 标记程序集</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageTitle">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">用 NeutralResourcesLanguageAttribute 标记程序集</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">布尔数据类型在非托管代码中有多个表示形式。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">向 P/Invoke {1} 的参数 {0} 添加 MarshalAsAttribute。如果对应的非托管参数为 4 字节的 Win32 "BOOL"，则使用 [MarshalAs(UnmanagedType.Bool)]。对于 1 字节的 C++ "bool"，请使用 MarshalAs(UnmanagedType.U1)。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">向 P/Invoke {0} 的返回类型添加 MarshalAsAttribute。如果对应的非托管返回类型为 4 字节的 Win32 "BOOL"，则使用 MarshalAs(UnmanagedType.Bool)。对于 1 字节的 C++ "bool"，请使用 MarshalAs(UnmanagedType.U1)。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">用 MarshalAs 标记布尔型 PInvoke 参数</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">要被公共语言运行时识别为可序列化，必须使用 SerializableAttribute 特性标记类型，即使类型通过 ISerializable 接口的实现使用自定义序列化例程时也不例外。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">将 [Serializable] 添加到 {0}，因为此类型实现 ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">将 ISerializable 类型标记为“可序列化”</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheck">
        <source>Ensure HttpClient certificate revocation list check is not disabled</source>
        <target state="translated">确保未禁用 HttpClient 证书吊销列表检查</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheckMessage">
        <source>HttpClient may be created without enabling CheckCertificateRevocationList</source>
        <target state="translated">可在不启用 CheckCertificateRevocationList 的情况下创建 HttpClient</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="translated">确保没有将证书添加到根存储</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="translated">将证书添加到操作系统受信任的根证书很不安全。请确保目标存储不是根存储。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIV">
        <source>Use CreateEncryptor with the default IV </source>
        <target state="translated">将 CreateEncryptor 与默认 IV 结合使用</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIVMessage">
        <source>The non-default initialization vector, which can be potentially repeatable, is used in the encryption. Ensure use the default one.</source>
        <target state="translated">加密中使用了可能是可重复的非默认初始化向量。请确保使用默认值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">确保在 ASP.NET Core 中使用安全 Cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">请确保设置 Cookie 时 CookieOptions.Secure = true</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCount">
        <source>Ensure Sufficient Iteration Count When Using Weak Key Derivation Function</source>
        <target state="translated">使用弱密钥派生功能时，请确保迭代计数足够大</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCountMessage">
        <source>Ensure that the iteration count is at least {0} when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">基于密码派生加密密钥时，请确保迭代计数至少为 {0}。默认情况下，Rfc2898DeriveByte 的 IterationCount 仅为 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticDescription">
        <source>Since a type that implements 'IDynamicInterfaceCastable' may not implement a dynamic interface in metadata, calls to an instance interface member that is not an explicit implementation defined on this type are likely to fail at runtime. Mark new interface members 'static' to avoid runtime errors.</source>
        <target state="translated">由于实现 “IDynamicInterfaceCastable” 的类型可能不会在元数据中实现动态接口，因此对不是针对此类型定义的显式实现的实例接口成员的调用可能会在运行时失败。请将新的接口成员标记为 “static” 以避免运行时错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticMessage">
        <source>The '{0}' member on the '{1}' type should be marked 'static' as '{1}' has the 'DynamicInterfaceImplementationAttribute' applied</source>
        <target state="translated">“{0}”成员(在“{1}”类型上)应标记为 “static”，因为“{1}”应用了 “DaynamicInterfaceImplementationAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticTitle">
        <source>Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'static'</source>
        <target state="translated">在具有 “DynamicInterfaceCastableImplementationAttribute” 的接口上定义的成员应为 “static”</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodReturnsPreviewTypeMessage">
        <source>'{0}' returns the preview type '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">“{0}”返回预览类型“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodReturnsPreviewTypeMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' returns the preview type '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3}.“{0}”返回预览类型“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesPreviewTypeAsParameterMessage">
        <source>'{0}' takes in a preview parameter of type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">“{0}”接受类型“{1}”的预览参数，并且需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesPreviewTypeAsParameterMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' takes in a preview parameter of type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3}.“{0}”接受类型“{1}”的预览参数，并且需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledDescription">
        <source>This method uses runtime marshalling even when runtime marshalling is disabled, which can cause unexpected behavior differences at runtime due to different expectations of a type's native layout.</source>
        <target state="translated">即使禁用运行时封送，此方法也使用运行时封送，这可能会由于类型的本机布局的不同期望导致在运行时出现意外的行为差异。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledMessage">
        <source>'{0}' uses runtime marshalling even when 'DisableRuntimeMarshallingAttribute' is applied. Use features like 'sizeof' and pointers directly to ensure accurate results.</source>
        <target state="translated">即使应用了 “DisableRuntimeMarshallingAttribute”，“{0}”也使用运行时封送。直接使用 “sizeof” 和指针等功能可确保结果准确。</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledTitle">
        <source>This method uses runtime marshalling even when the 'DisableRuntimeMarshallingAttribute' is applied</source>
        <target state="translated">即使应用了 “DisableRuntimeMarshallingAttribute”，此方法也会使用运行时封送</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttribute">
        <source>Miss HttpVerb attribute for action methods</source>
        <target state="translated">缺少操作方法的 HttpVerb 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeDescription">
        <source>All the methods that create, edit, delete, or otherwise modify data do so in the [HttpPost] overload of the method, which needs to be protected with the anti forgery attribute from request forgery. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</source>
        <target state="translated">创建、编辑、删除或以其他方式修改数据的所有方法都在方法的 [HttpPost] 重载中执行，这需要使用来自请求伪造的防伪造属性来保护。执行 GET 操作应是不具有任何副作用且不会修改永久性数据的安全操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeMessage">
        <source>Action method {0} needs to specify the HTTP request kind explicitly</source>
        <target state="translated">操作方法 {0} 需要显式指定 HTTP 请求类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesDescription">
        <source>Module initializers are intended to be used by application code to ensure an application's components are initialized before the application code begins executing. If library code declares a method with the 'ModuleInitializerAttribute', it can interfere with application initialization and also lead to limitations in that application's trimming abilities. Instead of using methods marked with 'ModuleInitializerAttribute', the library should expose methods that can be used to initialize any components within the library and allow the application to invoke the method during application initialization.</source>
        <target state="translated">模块初始化表达式旨在由应用程序代码用于确保在应用程序代码开始执行之前初始化应用程序的组件。如果库代码使用 “ModuleInitializer” 声明方法，则可能干扰应用程序初始化，并且还会导致限制该应用程序的剪裁功能。因此库不应使用标记为 “ModuleInitializerAttribute” 的方法，而应公开可用于初始化库中任何组件的方法，并允许应用程序在应用程序初始化期间调用该方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesMessage">
        <source>The 'ModuleInitializer' attribute is only intended to be used in application code or advanced source generator scenarios</source>
        <target state="translated">“ModuleInitializer” 属性仅用于应用程序代码或高级源生成器方案</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesTitle">
        <source>The 'ModuleInitializer' attribute should not be used in libraries</source>
        <target state="translated">不应在库中使用 “ModuleInitializer” 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">在不使用 SerializationBinder 的情况下对不受信任的数据进行反序列化，以限制反序列化对象图中的对象类型时，方法“{0}”不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure NetDataContractSerializer.Binder is set before deserializing</source>
        <target state="translated">请确保在反序列化之前设置 NetDataContractSerializer.Binder</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">在不使用 SerializationBinder 的情况下对不受信任的数据进行反序列化，以限制反序列化对象图中的对象类型时，方法“{0}”不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetTitle">
        <source>Do not deserialize without first setting NetDataContractSerializer.Binder</source>
        <target state="translated">在未设置 NetDataContractSerializer.Binder 的情况下，请不要反序列化</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect NetDataContractSerializer deserialization without a SerializationBinder set, then disable rule CA2310, and enable rules CA2311 and CA2312.</source>
        <target state="translated">反序列化不受信任的数据时，方法“{0}”不安全。如果需要在未设置 SerializationBinder 的情况下改为检测 NetDataContractSerializer 反序列化，则请禁用 CA2310 规则，并启用 CA2311 和 CA2312 规则。</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">对不受信任的数据进行反序列化时，方法“{0}”不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedTitle">
        <source>Do not use insecure deserializer NetDataContractSerializer</source>
        <target state="translated">请勿使用不安全的反序列化程序 NetDataContractSerializer</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">字符串应规范化为大写。有少量字符在转换为小写后不能转换回来。往返转换是指将字符从一个区域设置转换为按其他方式表示字符数据的另一区域设置，然后准确地从转换后的字符中检索到原始字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'</source>
        <target state="translated">在方法“{0}”中，将对“{1}”的调用替换为“{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">将字符串规范化为大写</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">对不受信任的数据进行反序列化时，方法“{0}”不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer ObjectStateFormatter</source>
        <target state="translated">请勿使用不安全的反序列化程序 ObjectStateFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="OverridesPreviewMethodMessage">
        <source>'{0}' overrides the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">“{0}”覆盖预览方法“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverridesPreviewMethodMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' overrides the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3}.“{0}”覆盖预览方法“{1}”，因此需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">公共类型中的公共方法或受保护的方法具有 System.Runtime.InteropServices.DllImportAttribute 属性(在 Visual Basic 中也由 Declare 关键字实现)。不应公开此类方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">P/Invoke 方法“{0}”应该是不可见的</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">P/Invokes 应该是不可见的</target>
        <note />
      </trans-unit>
      <trans-unit id="ParenthesisWithPlaceHolder">
        <source> ({0})</source>
        <target state="translated"> ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllPlatforms">
        <source>and all other platforms</source>
        <target state="translated">和其他所有平台</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and later, and all other platforms</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllVersions">
        <source>'{0}' all versions</source>
        <target state="translated">"{0}" 所有版本</target>
        <note>This call site is reachable on: 'Windows' all versions.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityDescription">
        <source>Using platform dependent API on a component makes the code no longer work across all platforms.</source>
        <target state="translated">在组件上使用依赖于平台的 API 会使代码无法用于所有平台。</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityFromVersionToVersion">
        <source>'{0}' from version {1} to {2}</source>
        <target state="translated">"{0}" 版本 {1} 到 {2}。</target>
        <note>'SupportedOnWindows1903UnsupportedOn2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityObsoletedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is obsoleted on: {1}.</source>
        <target state="translated">可在所有平台上访问此调用站点。"{0}" 在 {1} 上过时。</target>
        <note>This call site is reachable on all platforms. 'OboletedOnMacOS()' is obsoleted on: 'macos'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityObsoletedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is obsoleted on: {1}.</source>
        <target state="translated">此调用站点可在以下位置访问:{2}。“{0}”在以下位置过时:{1}。</target>
        <note>This call site is reachable on 'macos', 'linux'. 'OboletedOnMacOS()' is obsoleted on: 'macos'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is only supported on: {1}.</source>
        <target state="translated">可在所有平台上访问此调用站点。"{0}" 仅在 {1} 上受支持。</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindowsAndBrowser()' is only supported on: 'windows', 'browser' .</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">可在 {2} 上访问此调用站点。"{0}" 仅在 {1} 上受支持。</target>
        <note>This call site is reachable on: 'windows' all versions.'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsUnreachableMessage">
        <source>This call site is unreachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">无法在 {2} 上访问此调用站点。"{0}" 仅在 {1} 上受支持。</target>
        <note>This call site is unreachable on: 'browser'. 'SupportedOnWindowsAndBrowser()' is only supported on: 'browser', 'windows'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is supported on: {1}.</source>
        <target state="translated">可在所有平台上访问此调用站点。"{0}" 在 {1} 上受支持。</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindows1903UnsupportedFrom2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is supported on: {1}.</source>
        <target state="translated">可在 {2} 上访问此调用站点。"{0}" 在 {1} 上受支持。</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and before. 'UnsupportedOnWindowsSupportedOn1903()' is supported on: 'windows' 10.0.1903 and later.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityTitle">
        <source>Validate platform compatibility</source>
        <target state="translated">验证平台兼容性</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is unsupported on: {1}.</source>
        <target state="translated">可在所有平台上访问此调用站点。"{0}" 在 {1} 上不受支持。</target>
        <note>This call site is reachable on all platforms. 'UnsupportedOnWindows()' is unsupported on: 'windows'</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is unsupported on: {1}.</source>
        <target state="translated">可在 {2} 上访问此调用站点。"{0}" 在 {1} 上不受支持。</target>
        <note>This call site is reachable on: 'windows', 'browser'. 'UnsupportedOnBrowser()' is unsupported on: 'browser'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndBefore">
        <source>'{0}' {1} and before</source>
        <target state="translated">"{0}" {1} 及之前版本</target>
        <note>'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndLater">
        <source>'{0}' {1} and later</source>
        <target state="translated">"{0}" {1} 及更高版本</target>
        <note>'SupportedOnWindows10()' is only supported on: 'windows' 10.0 and later.</note>
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphDescription">
        <source>Review code that processes untrusted deserialized data for handling of unexpected reference cycles. An unexpected reference cycle should not cause the code to enter an infinite loop. Otherwise, an unexpected reference cycle can allow an attacker to DOS or exhaust the memory of the process when deserializing untrusted data.</source>
        <target state="translated">查看处理不受信任的反序列化数据(为了处理意外引用循环)的代码。意外引用循环不应导致代码进入无限循环。否则，当反序列化不受信任的数据时，意外的引用循环可能导致攻击者 DOS 或耗尽进程的内存。</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">{0} 参与潜在的引用周期</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphTitle">
        <source>Potential reference cycle in deserialized object graph</source>
        <target state="translated">反序列化对象图中的潜在引用循环</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringCodefixTitle">
        <source>Replace 'Substring' with 'AsSpan'</source>
        <target state="translated">将 “Substring” 替换为 “AsSpan”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringDescription">
        <source>'AsSpan' is more efficient than 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost.</source>
        <target state="needs-review-translation">“AsSpan” 比 “Substring” 效率更高。“Substring” 执行 O(n)字符串复制，而 “AsSpan” 不执行且具有固定成本。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringMessage">
        <source>Prefer 'AsSpan' over 'Substring' when span-based overloads are available</source>
        <target state="translated">当基于跨度的重载可用时，首选 “AsSpan” 而不是 “Substring”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringTitle">
        <source>Prefer 'AsSpan' over 'Substring'</source>
        <target state="translated">首选 “AsSpan” 而不是 “Substring”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderDescription">
        <source>'StringBuilder.Append(char)' is more efficient than 'StringBuilder.Append(string)' when the string is a single character. When calling 'Append' with a constant, prefer using a constant char rather than a constant string containing one character.</source>
        <target state="translated">当字符串是单个字符时，"StringBuilder.Append(char)" 比 "StringBuilder.Append(string)" 更高效。使用常量调用 "Append" 时，请首选使用常量字符，而不是包含一个字符的常量字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderMessage">
        <source>Use 'StringBuilder.Append(char)' instead of 'StringBuilder.Append(string)' when the input is a constant unit string</source>
        <target state="translated">当输入是常量单位字符串时，请使用 "StringBuilder.Append(char)" 而不是 "StringBuilder.Append(string)"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderTitle">
        <source>Consider using 'StringBuilder.Append(char)' when applicable</source>
        <target state="translated">若适用，请考虑使用 "StringBuilder.Append(char)"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferCountOverAnyCodeFixTitle">
        <source>Use 'Count' check instead of 'Any()'</source>
        <target state="translated">使用 'Count' 检查而不是 'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferCountOverAnyMessage">
        <source>Prefer comparing 'Count' to 0 rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">更喜欢将 'Count' 与 0 进行比较，而不是使用 'Any()'，这既是为了清楚明了，也是为了提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyCodeFixTitle">
        <source>Use 'ContainsKey'</source>
        <target state="translated">使用 “ContainsKey”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyDescription">
        <source>'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations.</source>
        <target state="translated">“ContainsKey” 通常是 O(1)，而 “Keys.Contains” 在某些情况下可能是 O(n)。此外，许多字典实现会延迟地初始化 Keys 集合，以减少分配。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyMessage">
        <source>Prefer 'ContainsKey' over 'Keys.Contains' for dictionary type '{0}'</source>
        <target state="translated">对于字典类型“{0}”，首选 “ContainsKey” 而不是 “Keys.Contains”。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsMethodsTitle">
        <source>Prefer Dictionary.Contains methods</source>
        <target state="translated">首选 Dictionary.Contains 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueCodeFixTitle">
        <source>Use 'ContainsValue'</source>
        <target state="translated">使用 “ContainsValue”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueDescription">
        <source>Many dictionary implementations lazily initialize the Values collection. To avoid unnecessary allocations, prefer 'ContainsValue' over 'Values.Contains'.</source>
        <target state="translated">许多字典实现延迟初始化 Values 集合。为了避免不必要的分配，首选 “ContainsValue” 而不是 “Values.Contains”。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueMessage">
        <source>Prefer 'ContainsValue' over 'Values.Contains' for dictionary type '{0}'</source>
        <target state="translated">对于字典类型“{0}”，首选 “ContainsValue” 而不是 “Values.Contains”。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddDescription">
        <source>Prefer a 'TryAdd' call over an 'Add' call guarded by a 'ContainsKey' check. 'TryAdd' behaves the same as 'Add', except that when the specified key already exists, it returns 'false' instead of throwing an exception.</source>
        <target state="translated">首选 "TryAdd" 调用而不是由 "ContainsKey" 检查保护的 "Add" 调用。"TryAdd" 的行为与 "Add" 相同，但当指定的密钥已存在时，它返回 "false" 而不是引发异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddMessage">
        <source>To avoid double lookup, call 'TryAdd' instead of calling 'Add' with a 'ContainsKey' guard</source>
        <target state="translated">为了避免重复查找，请调用 "TryAdd"，而不是调用带有 "ContainsKey" 保护的 "Add"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddTitle">
        <source>Prefer the 'IDictionary.TryAdd(TKey, TValue)' method</source>
        <target state="translated">首选 "IDictionary.TryAdd(TKey, TValue)" 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddValueCodeFixTitle">
        <source>Use 'TryAdd(TKey, TValue)'</source>
        <target state="translated">使用 "TryAdd(TKey, TValue)"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueCodeFixTitle">
        <source>Use 'TryGetValue(TKey, out TValue)'</source>
        <target state="translated">使用 “TryGetValue(TKey, out TValue)”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueDescription">
        <source>Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check. 'ContainsKey' and the indexer both would lookup the key under the hood, so using 'TryGetValue' removes the extra lookup.</source>
        <target state="translated">首选 “TryGetValue” 调用，而不是通过 “ContainsKey” 检查保护的字典索引器访问。“ContainsKey” 和索引器都会查找位于底层的密钥，因此使用 “TryGetValue” 会删除额外的查找。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueMessage">
        <source>Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check to avoid double lookup</source>
        <target state="translated">首选 “TryGetValue” 调用，而不是由 “ContainsKey” 检查保护的字典索引器访问，以避免双重查找</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueTitle">
        <source>Prefer the 'IDictionary.TryGetValue(TKey, out TValue)' method</source>
        <target state="translated">首选 “IDictionary.TryGetValue(TKey, out TValue)” 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataCodefixTitle">
        <source>Replace with 'HashData' method</source>
        <target state="translated">替换为“HashData”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerDescription">
        <source>It is more efficient to use the static 'HashData' method over creating and managing a HashAlgorithm instance to call 'ComputeHash'.</source>
        <target state="translated">相比创建并管理 HashAlgorithm 实例来调用“ComputeHash”，使用静态“HashData”方法更高效。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerMessage">
        <source>Prefer static '{0}.HashData' method over 'ComputeHash'</source>
        <target state="translated">首选静态“{0}.HashData”而不是的“ComputeHash”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerTitle">
        <source>Prefer static 'HashData' method over 'ComputeHash'</source>
        <target state="translated">首选静态“HashData”而不是的“ComputeHash”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverAnyCodeFixTitle">
        <source>Use 'IsEmpty' check instead of 'Any()'</source>
        <target state="translated">使用 'IsEmpty' 检查而不是'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverAnyMessage">
        <source>Prefer an 'IsEmpty' check rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">首选 'IsEmpty'检查，而不是使用 'Any()'，这既是为了清楚明了，也是为了提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountDescription">
        <source>For determining whether the object contains or not any items, prefer using 'IsEmpty' property rather than retrieving the number of items from the 'Count' property and comparing it to 0 or 1.</source>
        <target state="translated">若要确定对象是否包含项，最好使用 "IsEmpty" 属性，而不是从 "Count" 属性检索项的数目并将其与 0 或 1 进行比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountMessage">
        <source>Prefer 'IsEmpty' over 'Count' to determine whether the object is empty</source>
        <target state="translated">最好使用 "IsEmpty" (而不是 "Count")来确定对象是否为空</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountTitle">
        <source>Prefer IsEmpty over Count</source>
        <target state="translated">最好使用 "IsEmpty" (而不是 "Count")</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthCountIsEmptyOverAnyDescription">
        <source>Prefer using 'IsEmpty', 'Count' or 'Length' properties whichever available, rather than calling 'Enumerable.Any()'. The intent is clearer and it is more performant than using 'Enumerable.Any()' extension method.</source>
        <target state="translated">首选使用可用的 'IsEmpty'、'Count' 或 'Length' 属性，而不是调用 'Enumerable.Any()'。意向更清晰，其性能高于使用 'Enumerable.Any() 扩展方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthCountIsEmptyOverAnyTitle">
        <source>Avoid using 'Enumerable.Any()' extension method</source>
        <target state="translated">避免使用 'Enumerable.Any()' 扩展方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthOverAnyCodeFixTitle">
        <source>Use 'Length' check instead of 'Any()'</source>
        <target state="translated">使用 'Length' 检查而非 'Any()'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthOverAnyMessage">
        <source>Prefer comparing 'Length' to 0 rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">为了清楚起见和提高性能，首选将 'Length'与 0 进行比较，而不是使用 'Any()'。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsDescription">
        <source>'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument. Prefer calling the memory based overloads, which are more efficient.</source>
        <target state="translated">"Stream" 有一个将 "Memory&lt;Byte&gt;" 作为第一个参数的 "ReadAsync" 重载和一个将 "Memory&lt;Byte&gt;" 作为第一个参数的 "WriteAsync" 重载。首选调用基于内存的重载，它们的效率更高。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsMessage">
        <source>Change the '{0}' method call to use the '{1}' overload</source>
        <target state="translated">请将“{0}”方法调用更改为使用“{1}”重载</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsTitle">
        <source>Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</source>
        <target state="translated">对于 "ReadAsync" 和 "WriteAsync"，首选基于内存的重载</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfCodeFixTitle">
        <source>Replace with 'string.Contains'</source>
        <target state="translated">替换为 "string.Contains"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfDescription">
        <source>Calls to 'string.IndexOf' where the result is used to check for the presence/absence of a substring can be replaced by 'string.Contains'.</source>
        <target state="translated">如果结果用于检查是否存在/缺少子字符串，对 "string.IndexOf" 的调用可替换为对 "string.Contains" 的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfMessage">
        <source>Use 'string.Contains' instead of 'string.IndexOf' to improve readability</source>
        <target state="translated">使用 "string.Contains" 而不是 "string.IndexOf" 来提高可读性</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfTitle">
        <source>Consider using 'string.Contains' instead of 'string.IndexOf'</source>
        <target state="translated">请考虑使用 "string.Contains" 而不是 "string.IndexOf"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsDescription">
        <source>StringBuilder.Append and StringBuilder.Insert provide overloads for multiple types beyond System.String.  When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</source>
        <target state="translated">StringBuilder.Append 和 StringBuilder.Insert 为 System.String 之外的多种类型提供重载。在可能情况下，尽量使用强类型重载而非使用 ToString() 和基于字符串的重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsMessage">
        <source>Remove the ToString call in order to use a strongly-typed StringBuilder overload</source>
        <target state="translated">删除 ToString 调用以使用强类型 StringBuilder 重载</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsRemoveToString">
        <source>Remove the ToString call</source>
        <target state="translated">删除 ToString 调用</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsTitle">
        <source>Prefer strongly-typed Append and Insert method overloads on StringBuilder</source>
        <target state="translated">最好使用 StringBuilder 的强类型 Append 和 Insert 方法重载</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesConversionNotThrowMessage">
        <source>Starting with .NET 7 the explicit conversion '{0}' will not throw when overflowing in an unchecked context. Wrap the expression with a 'checked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">从 .NET 7 开始，在未选中上下文中溢出时，显式转换“{0}”将不会引发。使用“已选中”语句包装表达式以还原 .NET 6 行为。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesConversionThrowsMessage">
        <source>Starting with .NET 7 the explicit conversion '{0}' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">从 .NET 7 开始，在已选中上下文中溢出时，显式转换“{0}”将会引发。使用“未选中”语句包装表达式以还原 .NET 6 行为。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesDescription">
        <source>Some built-in operators added in .NET 7 behave differently when overflowing than did the corresponding user-defined operators in .NET 6 and earlier versions. Some operators that previously threw in an unchecked context now don't throw unless wrapped within a checked context. Also, some operators that did not previously throw in a checked context now throw unless wrapped in an unchecked context.</source>
        <target state="translated">在 .NET 7 中添加的某些内置运算符在溢出时的行为与 .NET 6 和早期版本中相应的用户定义运算符的行为不同。之前在未检查的上下文中引发的一些运算符现在只有在经检查的上下文中被包装时才会引发。此外，一些之前在经检查的上下文中不引发的运算符现在会引发，除非在未检查的上下文中被包装。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesOperatorThrowsMessage">
        <source>Starting with .NET 7 the operator '{0}' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">从 .NET 7 开始，运算符“{0}”将在选中上下文中溢出时引发。使用“未选中”语句包装表达式以还原 .NET 6 行为。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesTitle">
        <source>Prevent behavioral change</source>
        <target state="translated">防止行为变更</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagDescription">
        <source>'Enum.HasFlag' method expects the 'enum' argument to be of the same 'enum' type as the instance on which the method is invoked and that this 'enum' is marked with 'System.FlagsAttribute'. If these are different 'enum' types, an unhandled exception will be thrown at runtime. If the 'enum' type is not marked with 'System.FlagsAttribute' the call will always return 'false' at runtime.</source>
        <target state="translated">"Enum.HasFlag" 方法要求 "enum" 参数与调用该方法的实例具有相同的 "enum" 类型，并且此 "enum" 用 "System.FlagsAttribute" 标记。如果它们是不同的 "enum" 类型，则在运行时将引发未经处理的异常。如果 "enum" 类型未使用 "System.FlagsAttribute" 进行标记，则调用在运行时将始终返回 "false"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagMessageDifferentType">
        <source>The argument type, '{0}', must be the same as the enum type '{1}'</source>
        <target state="translated">参数类型“{0}”必须与枚举类型“{1}”相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagTitle">
        <source>Provide correct 'enum' argument to 'Enum.HasFlag'</source>
        <target state="translated">向 "Enum.HasFlag" 提供正确的 "enum" 参数</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">传递到 System.String.Format 的 format 参数不包含与各对象参数相对应的格式项，反之亦然。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsInvalidFormatMessage">
        <source>The format argument is not a valid format string</source>
        <target state="new">The format argument is not a valid format string</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">为格式化方法提供正确的参数</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">为格式化方法提供正确的参数</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyDescription">
        <source>The property 'MaxResponseHeadersLength' is measured in kilobytes, not in bytes. That mean the provided value will be multiplied by 1024, the result might be too high than your intended value.</source>
        <target state="new">The property 'MaxResponseHeadersLength' is measured in kilobytes, not in bytes. That mean the provided value will be multiplied by 1024, the result might be too high than your intended value.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyMessage">
        <source>Make sure the value '{0}' is provided correctly. This value is measured in kilobytes not bytes.</source>
        <target state="new">Make sure the value '{0}' is provided correctly. This value is measured in kilobytes not bytes.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyTitle">
        <source>Set 'MaxResponseHeadersLength' properly</source>
        <target state="new">Set 'MaxResponseHeadersLength' properly</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorDescription">
        <source>Providing a parameterless constructor that is as visible as the containing type for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions.</source>
        <target state="translated">提供与派生自 “System.Runtime.InteropServices.SafeHandle” 的类型的包含类型一样可见的无参数构造函数可改进源生成的互操作解决方案的性能和使用情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorMessage">
        <source>Provide a parameterless constructor that is as visible as the containing type for the '{0}' type that is derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="translated">提供与派生自 “System.Runtime.InteropServices.SafeHandle” 的“{0}”类型的包含类型一样可见的无参数构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorTitle">
        <source>Provide a parameterless constructor that is as visible as the containing type for concrete types derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="translated">提供与派生自 “System.Runtime.InteropServices.SafeHandle” 的具体类型的包含类型一样可见的无参数构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesDescription">
        <source>To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods.</source>
        <target state="translated">若要提高性能，请在子类化“Stream”时重写基于内存的异步方法。然后，根据基于内存的方法实现基于数组的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesMessage">
        <source>'{0}' overrides array-based '{1}' but does not override memory-based '{2}'. Consider overriding memory-based '{2}' to improve performance.</source>
        <target state="translated">“{0}”重写基于数组的“{1}”，但不会重写基于内存的“{2}”，请考虑重写基于内存的“{2}”以提高性能。</target>
        <note>0 = type that subclasses Stream directly, 1 = array-based method, 2 = memory-based method</note>
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesTitle">
        <source>Provide memory-based overrides of async methods when subclassing 'Stream'</source>
        <target state="translated">在子类化 “Stream” 时提供异步方法的基于内存的重写</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons when using 'CompareTo', because they lead to an allocation. Instead, use 'StringComparer' to perform case-insensitive comparisons. Switching to using 'StringComparer' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'.</source>
        <target state="needs-review-translation">避免在使用 "CompareTo" 时调用"ToLower"、"ToUpper"、"ToLowerInvariant" 和 "ToUpperInvariant" 来执行不区分大小写的字符串比较，因为它们会导致分配。请使用 "StringComparer" 执行不区分大小写的比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerMessage">
        <source>Prefer using 'StringComparer' to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'</source>
        <target state="needs-review-translation">首选使用“StringComparer”执行不区分大小写的比较</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerStringComparisonCodeFixTitle">
        <source>Use the 'string.{0}(string, StringComparison)' overload</source>
        <target state="needs-review-translation">使用 "string.{0}(string, StringComparison)" 重载</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons because they lead to an allocation. Instead, prefer calling the method overloads of 'Contains', 'IndexOf' and 'StartsWith' that take a 'StringComparison' enum value to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</source>
        <target state="new">Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons because they lead to an allocation. Instead, prefer calling the method overloads of 'Contains', 'IndexOf' and 'StartsWith' that take a 'StringComparison' enum value to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonMessage">
        <source>Prefer the string comparison method overload of '{0}' that takes a 'StringComparison' enum value to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</source>
        <target state="new">Prefer the string comparison method overload of '{0}' that takes a 'StringComparison' enum value to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonTitle">
        <source>Use the 'StringComparison' method overloads to perform case-insensitive string comparisons</source>
        <target state="needs-review-translation">首选 "StringComparison" 方法重载来执行不区分大小写的字符串比较</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsCodeFixTitle">
        <source>Use 'string.Equals(string, StringComparison)'</source>
        <target state="needs-review-translation">使用 "string.Equals(string, StringComparison)"</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons, as in 'string.ToLower() == string.ToLower()', because they lead to an allocation. Instead, use 'string.Equals(string, StringComparison)' to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</source>
        <target state="needs-review-translation">就像在 "string.ToLower() == string.ToLower()" 中那样，避免调用 "ToLower"、"ToUpper"、"ToLowerInvariant" 和 "ToUpperInvariant" 来执行不区分大小写的字符串比较，因为它们会导致分配。请使用 "string.Equals(string, StringComparison)" 执行不区分大小写的比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsMessage">
        <source>Prefer using 'string.Equals(string, StringComparison)' to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</source>
        <target state="needs-review-translation">首选使用 "string.Equals(string, StringComparison)" 来执行不区分大小写的比较</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantCall">
        <source>Remove redundant call</source>
        <target state="translated">删除冗余的调用</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantGuardCallCodeFixTitle">
        <source>Remove unnecessary call</source>
        <target state="translated">删除不必要调用</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplaceStringLiteralWithCharLiteralCodeActionTitle">
        <source>Replace string literal with char literal</source>
        <target state="translated">将字符串字面量替换为字符型文本</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesMessage">
        <source>Potential DLL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在的 DLL 注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesTitle">
        <source>Review code for DLL injection vulnerabilities</source>
        <target state="translated">查看 DLL 注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesMessage">
        <source>Potential file path injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在的文件路径注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesTitle">
        <source>Review code for file path injection vulnerabilities</source>
        <target state="translated">查看文件路径注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesMessage">
        <source>Potential information disclosure vulnerability was found where '{0}' in method '{1}' may contain unintended information from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在信息泄露漏洞，其中方法“{1}”中的“{0}”可能包含方法“{3}”中“{2}”的意外信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesTitle">
        <source>Review code for information disclosure vulnerabilities</source>
        <target state="translated">查看信息泄露漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesMessage">
        <source>Potential LDAP injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在 LDAP 注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesTitle">
        <source>Review code for LDAP injection vulnerabilities</source>
        <target state="translated">查看 LDAP 注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesMessage">
        <source>Potential open redirect vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在开放重定向漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesTitle">
        <source>Review code for open redirect vulnerabilities</source>
        <target state="translated">查看开放重定向漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesMessage">
        <source>Potential process command injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在进程命令注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesTitle">
        <source>Review code for process command injection vulnerabilities</source>
        <target state="translated">查看进程命令注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesMessage">
        <source>Potential regex injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在正则表达式注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesTitle">
        <source>Review code for regex injection vulnerabilities</source>
        <target state="translated">查看正则表达式注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesMessage">
        <source>Potential SQL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在 SQL 注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesTitle">
        <source>Review code for SQL injection vulnerabilities</source>
        <target state="translated">检查 SQL 注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesMessage">
        <source>Potential XPath injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在 XPath 注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesTitle">
        <source>Review code for XPath injection vulnerabilities</source>
        <target state="translated">查看 XPath 注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesMessage">
        <source>Potential XAML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在 XAML 注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesTitle">
        <source>Review code for XAML injection vulnerabilities</source>
        <target state="translated">查看 XAML 注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesMessage">
        <source>Potential XML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在 XML 注入漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesTitle">
        <source>Review code for XML injection vulnerabilities</source>
        <target state="translated">查看 XML 注入漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesMessage">
        <source>Potential cross-site scripting (XSS) vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">找到了潜在跨站点脚本(XSS)漏洞，其中方法“{1}”中的“{0}”可能会受到方法“{3}”中“{2}”的用户控制数据的污染。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesTitle">
        <source>Review code for XSS vulnerabilities</source>
        <target state="translated">检查 XSS 漏洞的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesDescription">
        <source>SQL queries that directly use user input can be vulnerable to SQL injection attacks. Review this SQL query for potential vulnerabilities, and consider using a parameterized SQL query.</source>
        <target state="translated">直接使用用户输入的 SQL 查询可能容易受到 SQL 注入攻击。查看此 SQL 查询以查找潜在漏洞，请考虑使用参数化 SQL 查询。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesMessageNoNonLiterals">
        <source>Review if the query string passed to '{0}' in '{1}', accepts any user input</source>
        <target state="translated">查看传递给“{1}”中的“{0}”的查询字符串是否接受任何用户输入</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesTitle">
        <source>Review SQL queries for security vulnerabilities</source>
        <target state="translated">检查 SQL 查询是否存在安全漏洞</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesCodeFixTitle">
        <source>Seal class</source>
        <target state="translated">密封类</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesDescription">
        <source>When a type is not accessible outside its assembly and has no subtypes within its containing assembly, it can be safely sealed. Sealing types can improve performance.</source>
        <target state="translated">当某类型在其程序集外部不可访问且其包含程序集中没有子类型时，可以安全地密封该类型。密封类型可以提高性能。</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesMessage">
        <source>Type '{0}' can be sealed because it has no subtypes in its containing assembly and is not externally visible</source>
        <target state="translated">类型“{0}”可以密封，因为它的包含程序集中没有子类型，并且在外部不可见</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesTitle">
        <source>Seal internal types</source>
        <target state="translated">密封内部类型</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookie">
        <source>Set HttpOnly to true for HttpCookie</source>
        <target state="translated">将 HttpCookie 的 HttpOnly 设置为 true</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieDescription">
        <source>As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies.</source>
        <target state="translated">作为深度防御措施，请确保将安全敏感的 HTTP cookie 标记为 HttpOnly。这表示 Web 浏览器应禁止脚本访问 cookie。注入的恶意脚本是窃取 cookie 的常用方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieMessage">
        <source>HttpCookie.HttpOnly is set to false or not set at all when using an HttpCookie. Ensure security sensitive cookies are marked as HttpOnly to prevent malicious scripts from stealing the cookies</source>
        <target state="translated">使用 HttpCookie 时，HttpCookie.HttpOnly 被设置为 false 或根本不设置。请确保安全敏感的 cookie 标记为 HttpOnly，以防止恶意脚本窃取 cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">针对派生自 Page 的类设置 ViewStateUserKey</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">设置 ViewStateUserKey 属性可帮助防止对应用程序的攻击，方法是允许为单个用户的视图状态变量分配标识符，使他们不能使用该变量来生成攻击。否则，会出现跨站点请求伪造漏洞。</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The class {0} derived from System.Web.UI.Page does not set the ViewStateUserKey property in the OnInit method or Page_Init method</source>
        <target state="translated">从 ViewStateUserKey 派生的 {0} 类不能在 OnInit 方法或 Page_Init 方法中设置属性</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperDescription">
        <source>Specify culture to help avoid accidental implicit dependency on current culture. Using an invariant version yields consistent results regardless of the culture of an application.</source>
        <target state="translated">指定区域性以帮助避免对当前区域性的意外隐式依赖。无论应用程序的区域性如何，使用固定版本都会生成一致的结果。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperMessage">
        <source>Specify a culture or use an invariant version to avoid implicit dependency on current culture</source>
        <target state="translated">指定区域性或使用固定版本以避免对当前区域性的隐式依赖</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperTitle">
        <source>Specify a culture or use an invariant version</source>
        <target state="translated">指定区域性或使用固定版本</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">某方法或构造函数调用的成员有一个接受 System.Globalization.CultureInfo 参数的重载，但该方法或构造函数没有调用接受 CultureInfo 参数的重载。如果未提供 CultureInfo 或 System.IFormatProvider 对象，则重载成员提供的默认值可能不会在所有区域设置中产生想要的效果。如果要向用户显示结果，请指定 "CultureInfo.CurrentCulture" 作为 "CultureInfo" 参数。或者，如果软件将存储和访问此结果(例如，当将此结果保留到磁盘或数据库中时)，则指定 "CultureInfo.InvariantCulture"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">“{0}”的行为可能因当前用户的区域设置而异。请将“{1}”中的此调用替换为对“{2}”的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">指定 CultureInfo</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCurrentCulture">
        <source>Specify current culture</source>
        <target state="translated">指定当前区域性</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">某方法或构造函数调用的一个或多个成员具有接受 System.IFormatProvider 参数的重载，但该方法或构造函数没有调用接受 IFormatProvider 参数的重载。如果未提供 System.Globalization.CultureInfo 或 System.IFormatProvider 对象，则重载成员提供的默认值可能不会在所有区域设置中产生想要的效果。如果要基于输入/输出向用户显示结果，请指定 "CultureInfo.CurrentCulture" 作为 "IFormatProvider" 参数。或者，如果软件将存储和访问此结果(例如，从磁盘/数据库加载此结果以及将它保留到磁盘/数据库中时)，则指定 "CultureInfo.InvariantCulture"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">“{0}”的行为可能因当前用户的区域设置而异。请将“{1}”中的此调用替换为对“{2}”的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">“{0}”的行为可能因当前用户的区域设置而异。请将“{1}”中的此调用替换为对“{2}”的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderOptional">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Provide a value for the 'IFormatProvider' argument.</source>
        <target state="translated">“{0}”的行为可能因当前用户的区域设置而异。为 “IFormatProvider” 参数提供值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">“{0}”将“{1}”作为 "IFormatProvider" 参数传递给“{2}”。此属性返回一个区域性，但它不适合格式化方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">“{0}”将“{1}”作为 "IFormatProvider" 参数传递给“{2}”。此属性返回一个区域性，但它不适合格式化方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">指定 IFormatProvider</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">平台调用成员允许部分受信任的调用方，具有字符串参数，且不显式封送字符串。这可能导致潜在的安全漏洞。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">指定对 P/Invoke 字符串参数进行封送处理</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. It is recommended to use the overload with StringComparison parameter for clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">字符串比较运算使用不设置 StringComparison 参数的方法重载。为了阐明意图，建议将重载与 StringComparison 参数一起使用。如果要向用户显示结果(例如，在对某个项列表进行排序以便在列表框中显示时)，请指定 "StringComparison.CurrentCulture" 或 "StringComparison.CurrentCultureIgnoreCase" 作为 "StringComparison" 参数。如果比较不区分大小写的标识符(例如文件路径、环境变量或注册表项和值)，则指定 "StringComparison.OrdinalIgnoreCase"。如果比较区分大小写的标识符，则指定 "StringComparison.Ordinal"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Message">
        <source>'{0}' has a method overload that takes a 'StringComparison' parameter. Replace this call in '{1}' with a call to '{2}' for clarity of intent.</source>
        <target state="translated">“{0}”具有采用 "StringComparison" 参数的方法重载。为了阐明意图，请将“{1}”中的此调用替换为对“{2}”的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Title">
        <source>Specify StringComparison for clarity</source>
        <target state="translated">为了清晰起见，请指定 StringComparison</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter, hence its behavior could vary based on the current user's locale settings. It is strongly recommended to use the overload with StringComparison parameter for correctness and clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">字符串比较运算使用不设置 StringComparison 参数的方法重载，因此它的行为可能因当前用户的区域设置而异。为了确保正确并阐明意图，强烈建议将重载与 StringComparison 参数一起使用。如果要向用户显示结果(例如，在对某个项列表进行排序以便在列表框中显示时)，请指定 "StringComparison.CurrentCulture" 或 "StringComparison.CurrentCultureIgnoreCase" 作为 "StringComparison" 参数。如果比较不区分大小写的标识符(例如文件路径、环境变量或注册表项和值)，则指定 "StringComparison.OrdinalIgnoreCase"。如果比较区分大小写的标识符，则指定 "StringComparison.Ordinal"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Message">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">“{0}”的行为可能因当前用户的区域设置而异。请将“{1}”中的此调用替换为对“{2}”的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Title">
        <source>Specify StringComparison for correctness</source>
        <target state="translated">为了确保正确，请指定 StringComparison</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticAndAbstractRequiresPreviewFeatures">
        <source>Using both 'static' and 'abstract' modifiers requires opting into preview features. See https://aka.ms/dotnet-warnings/preview-features for more information.</source>
        <target state="translated">同时使用 “static” 和 “abstract” 修饰符需要选择加入预览功能。有关详细信息，请参阅 https://aka.ms/dotnet-warnings/preview-features。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">相比于使用 Equals，使用 String.Length 属性或 String.IsNullOrEmpty 方法比较字符串的速度要快得多。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check</source>
        <target state="translated">使用 "string.Length" 属性或 "string.IsNullOrEmpty" 方法而不是 Equality 检查来测试是否有空字符串</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">使用字符串长度测试是否有空字符串</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">此表达式针对 Single.Nan 或 Double.Nan 测试某个值。使用 Single.IsNan(Single) 或 Double.IsNan(Double) 来测试值。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">正确测试 NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">正确测试 NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineDescription">
        <source>'ThreadStatic' fields should be initialized lazily on use, not with inline initialization nor explicitly in a static constructor, which would only initialize the field on the thread that runs the type's static constructor.</source>
        <target state="translated">“ThreadStatic” 字段应在使用时延迟初始化，不应使用内联初始化，也不应在静态构造函数中显式初始化，这只会初始化县城上运行该类型的静态构造函数的字段。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineMessage">
        <source>'ThreadStatic' fields should not use inline initialization</source>
        <target state="translated">“ThreadStatic” 字段不应使用内联初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineTitle">
        <source>Improper 'ThreadStatic' field initialization</source>
        <target state="translated">“ThreadStatic” 字段初始化不正确</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldDescription">
        <source>'ThreadStatic' only affects static fields. When applied to instance fields, it has no impact on behavior.</source>
        <target state="translated">“ThreadStatic” 仅影响静态字段。应用于实例字段时，它不会影响行为。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldMessage">
        <source>Ensure 'ThreadStatic' is only used with static fields</source>
        <target state="translated">确保 “ThreadStatic” 仅用于静态字段</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldTitle">
        <source>'ThreadStatic' only affects static fields</source>
        <target state="translated">“ThreadStatic” 仅影响静态字段</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentExceptionThrowHelperTitle">
        <source>Use ArgumentException throw helper</source>
        <target state="translated">使用 ArgumentException 引发帮助程序</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentNullExceptionThrowHelperTitle">
        <source>Use ArgumentNullException throw helper</source>
        <target state="translated">使用 ArgumentNullException 引发帮助程序</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentOutOfRangeExceptionThrowHelperTitle">
        <source>Use ArgumentOutOfRangeException throw helper</source>
        <target state="translated">使用 ArgumentOutOfRangeException 引发帮助程序</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">使用 Array.Empty</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is often unwanted when it is implicitly used as a Span or Memory value. Use the AsSpan method to avoid the copy.</source>
        <target state="translated">数组值的基于范围的索引器生成数组所请求部分的副本。此副本在隐式用作 Span 或 Memory 值时常常是不需要的。使用 AsSpan 方法可避免此副本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerMessage">
        <source>Use '{0}' instead of the '{1}'-based indexer on '{2}' to avoid creating unnecessary data copies</source>
        <target state="translated">请使用 "{0}" 代替 "{2}" 上的基于 "{1}" 的索引器，以避免创建不必要的数据副本</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAStringCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on a string</source>
        <target state="translated">对字符串使用“{0}”而不是基于范围的索引器</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAnArrayCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on an array</source>
        <target state="translated">对数组使用“{0}”而不是基于范围的索引器</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerTitle">
        <source>Use AsSpan or AsMemory instead of Range-based indexers when appropriate</source>
        <target state="translated">适当时，使用 AsSpan 或 AsMemory，而不是基于范围的索引器</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfStringRangeIndexerDescription">
        <source>The Range-based indexer on string values produces a copy of requested portion of the string. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">字符串值基于范围的索引器生成字符串的请求部分的副本。此副本在隐式用作 ReadOnlySpan 或 ReadOnlyMemory 值时常常是不需要的。使用 AsSpan 方法可避免使用不必要的副本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanReadOnlyInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">数组值的基于范围的索引器生成数组所请求部分的副本。此副本在隐式用作 ReadOnlySpan 或 ReadOnlyMemory 值时常常是不需要的。使用 AsSpan 方法可避免使用不必要的副本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextDescription">
        <source>When inside a Task-returning method, use the async version of methods, if they exist.</source>
        <target state="translated">在返回 Task 的方法中时，使用方法的异步版本(如果存在)。</target>
        <note>{Locked="Task"}</note>
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextMessage">
        <source>'{0}' synchronously blocks. Await '{1}' instead.</source>
        <target state="translated">“{0}”同步阻止。改为等待“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextMessage_NoAlternative">
        <source>'{0}' synchronously blocks. Use await instead.</source>
        <target state="translated">“{0}”同步阻止。请改用 await。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextTitle">
        <source>Call async methods when in an async method</source>
        <target state="translated">当在异步方法中时，调用异步方法</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryToken">
        <source>Use antiforgery tokens in ASP.NET Core MVC controllers</source>
        <target state="translated">在 ASP.NET Core MVC 控制器中使用防伪造令牌</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenDescription">
        <source>Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</source>
        <target state="translated">在未验证防伪造令牌的情况下处理 POST、PUT、PATCH 或 DELETE 请求可能易受跨站点请求伪造攻击。跨站点请求伪造攻击可将来自已通过身份验证的用户的恶意请求发送到 ASP.NET Core MVC 控制器。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenMessage">
        <source>Method {0} handles a {1} request without performing antiforgery token validation. You also need to ensure that your HTML form sends an antiforgery token.</source>
        <target state="translated">方法 {0} 在不执行防伪造令牌验证的情况下处理 {1} 请求。你还需要确保 HTML 窗体发送防伪造令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedCodeFixTitle">
        <source>Replace with 'CancellationToken.ThrowIfCancellationRequested'</source>
        <target state="translated">替换为 “CancellationToken.ThrowIfCancellationRequested”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedDescription">
        <source>'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has.</source>
        <target state="translated">“ThrowIfCancellationRequested” 自动检查是否已取消令牌，如果已取消，则引发 “OperationCanceledException”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedMessage">
        <source>Use 'ThrowIfCancellationRequested' instead of checking 'IsCancellationRequested' and throwing 'OperationCanceledException'</source>
        <target state="translated">使用 “ThrowIfCancellationRequested”，而不是检查 “IsCancellationRequested” 并引发 “OperationCanceledException”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedTitle">
        <source>Use 'ThrowIfCancellationRequested'</source>
        <target state="translated">使用 “ThrowIfCancellationRequested”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatDescription">
        <source>Cache and use a 'CompositeFormat' instance as the argument to this formatting operation, rather than passing in the original format string. This reduces the cost of the formatting operation.</source>
        <target state="translated">缓存并使用 "CompositeFormat" 实例作为此格式化操作的参数，而不是传入原始格式字符串。这会降低格式化操作的成本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatMessage">
        <source>Cache a 'CompositeFormat' for repeated use in this formatting operation</source>
        <target state="translated">缓存 "CompositeFormat" 以在此格式化操作中重复使用</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatTitle">
        <source>Use 'CompositeFormat'</source>
        <target state="translated">使用 "CompositeFormat"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeDescription">
        <source>Using concrete types avoids virtual or interface call overhead and enables inlining.</source>
        <target state="translated">使用具体类型可避免虚拟或接口调用开销，并启用内联。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForFieldMessage">
        <source>Change type of field '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">将字段“{0}”的类型从“{1}”更改为“{2}”，以提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForLocalMessage">
        <source>Change type of variable '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">将变量“{0}”的类型从“{1}”更改为“{2}”，以提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForMethodReturnMessage">
        <source>Change return type of method '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">将方法“{0}”的返回类型从“{1}”更改为“{2}”以提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForParameterMessage">
        <source>Change type of parameter '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">将参数“{0}”的类型从“{1}”更改为“{2}”以提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForPropertyMessage">
        <source>Change type of property '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">将属性 '{0}' 的类型从 '{1}'更改为 '{2}'，以提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeTitle">
        <source>Use concrete types when possible for improved performance</source>
        <target state="translated">尽可能使用具体类型以提高性能</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="translated">使用容器级别访问策略</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="translated">未指定访问策略标识符，这使得令牌不可撤消。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS.</source>
        <target state="translated">如果可能，请考虑使用 Azure 基于角色的访问控制，而不是共享访问签名(SAS)。如果仍需使用 SAS，请在创建 SAS 时使用容器级别访问策略。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttribute">
        <source>Use DefaultDllImportSearchPaths attribute for P/Invokes</source>
        <target state="translated">对 P/Invoke 使用 DefaultDllImportSearchPaths 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeDescription">
        <source>By default, P/Invokes using DllImportAttribute probe a number of directories, including the current working directory for the library to load. This can be a security issue for certain applications, leading to DLL hijacking.</source>
        <target state="translated">默认情况下，使用 DllImportAttribute 探测的 P/Invoke 包含许多目录，包括要加载的库的当前工作目录。对于某些应用程序，这可能是一个安全问题，它会导致 DLL 劫持。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeMessage">
        <source>The method {0} didn't use DefaultDllImportSearchPaths attribute for P/Invokes.</source>
        <target state="translated">方法 {0} 未对 P/Invoke 使用 DefaultDllImportSearchPaths 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDisabledMarshallingEquivalentCodeFix">
        <source>Use equivalent code that works when marshalling is disabled</source>
        <target state="translated">使用在禁用封送时起作用的等效代码</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdDescription">
        <source>'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'.</source>
        <target state="translated">“Environment.CurrentManagedThreadId” 比 “Thread.CurrentThread.ManagedThreadId” 更加简单快速。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdFix">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="translated">使用 “Environment.CurrentManagedThreadId”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdMessage">
        <source>Use 'Environment.CurrentManagedThreadId' instead of 'Thread.CurrentThread.ManagedThreadId'</source>
        <target state="translated">使用 “Environment.CurrentManagedThreadId” 而不是 “Thread.CurrentThread.ManagedThreadId”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdTitle">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="translated">使用 “Environment.CurrentManagedThreadId”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdDescription">
        <source>'Environment.ProcessId' is simpler and faster than 'Process.GetCurrentProcess().Id'.</source>
        <target state="translated">"Environment.ProcessId" 比 "Process.GetCurrentProcess().Id" 更简单且速度更快。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdFix">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">使用 "Environment.ProcessId"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdMessage">
        <source>Use 'Environment.ProcessId' instead of 'Process.GetCurrentProcess().Id'</source>
        <target state="translated">使用 "Environment.ProcessId" 而不是 "Process.GetCurrentProcess().Id"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdTitle">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">使用 "Environment.ProcessId"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathDescription">
        <source>'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'.</source>
        <target state="translated">“Environment.ProcessPath” 比 “Process.GetCurrentProcess().MainModule.FileName” 更为简单快速。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathFix">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="translated">使用 “Environment.ProcessPath”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathMessage">
        <source>Use 'Environment.ProcessPath' instead of 'Process.GetCurrentProcess().MainModule.FileName'</source>
        <target state="translated">使用 “Environment.ProcessPath” 而不是 “Process.GetCurrentProcess().MainModule.FileName”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathTitle">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="translated">使用 “Environment.ProcessPath”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIndexer">
        <source>Use indexer</source>
        <target state="translated">使用索引器</target>
        <note />
      </trans-unit>
      <trans-unit id="UseInvariantVersion">
        <source>Use an invariant version</source>
        <target state="translated">使用固定版本</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">已定义操作系统调用方法，且具有等效功能的方法位于 .NET Framework 类库中。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">使用 Win32 API 的托管等效项</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">使用 Win32 API 的托管等效项</target>
        <note />
      </trans-unit>
      <trans-unit id="UseObjectDisposedExceptionThrowHelperTitle">
        <source>Use ObjectDisposedException throw helper</source>
        <target state="translated">使用 ObjectDisposedException 引发帮助程序</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">非语义的字符串比较运算没有将 StringComparison 参数设置为 Ordinal 或 OrdinalIgnoreCase。通过将参数显式设置为 StringComparison.Ordinal 或 StringComparison.OrdinalIgnoreCase，通常可提高代码的速度、准确率和可靠性。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal string comparison</source>
        <target state="translated">使用序数字符串比较</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableDescription">
        <source>Enumerable.Count() potentially enumerates the sequence while a Length/Count property is a direct access.</source>
        <target state="translated">Enumerable.Count() 可能枚举序列，而 Length/Count 属性是直接访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableMessage">
        <source>Use the "{0}" property instead of Enumerable.Count()</source>
        <target state="translated">请使用 "{0}" 属性而不是 Enumerable.Count()</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableTitle">
        <source>Use Length/Count property instead of Count() when available</source>
        <target state="translated">在可用时使用 Length/Count 属性而不是 Count()</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest-Shamir-Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="translated">设置具有足够密钥大小的 Rivest-Shamir-Adleman (RSA)算法</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="translated">在使用的密钥大小太小时，加密算法容易遭到暴力破解攻击。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">非对称加密算法 {0} 的密钥大小小于 2048 位。请转而切换到至少具有 2048 位密钥大小的 RSA、ECDH 或者 ECDSA 算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesCodeFixTitle">
        <source>Use 'SearchValues'</source>
        <target state="new">Use 'SearchValues'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesDescription">
        <source>Using a cached 'SearchValues' instance is more efficient than passing values to 'IndexOfAny'/'ContainsAny' directly.</source>
        <target state="new">Using a cached 'SearchValues' instance is more efficient than passing values to 'IndexOfAny'/'ContainsAny' directly.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesMessage">
        <source>Use a cached 'SearchValues' instance for improved searching performance</source>
        <target state="new">Use a cached 'SearchValues' instance for improved searching performance</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesTitle">
        <source>Use a cached 'SearchValues' instance</source>
        <target state="new">Use a cached 'SearchValues' instance</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="translated">通过 HTTPS 提供的应用程序必须使用安全 Cookie。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">使用 SharedAccessProtocol HttpsOnly</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">HTTPS 对网络流量加密。请使用 HttpsOnly (而不是 HttpOrHttps)确保网络流量始终加密，从而帮助防止敏感数据泄露。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly.</source>
        <target state="translated">如果可能，请考虑使用 Azure 基于角色的访问控制，而不是共享访问签名(SAS)。如果仍需使用 SAS，请指定 SharedAccessProtocol.HttpsOnly。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatCodeFixTitle">
        <source>Use 'AsSpan' with 'string.Concat'</source>
        <target state="translated">将 “AsSpan” 与 “string.Concat” 配合使用</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatDescription">
        <source>It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator.</source>
        <target state="translated">使用 “AsSpan” 和 “string.Concat” 效率高于使用 “Substring” 和串联运算符。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatMessage">
        <source>Use span-based 'string.Concat' and 'AsSpan' instead of 'Substring'</source>
        <target state="translated">使用基于跨度的 “string.Concat” 和 “AsSpan” 而不是 “Substring”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatTitle">
        <source>Use span-based 'string.Concat'</source>
        <target state="translated">使用基于跨度的 “string.Concat”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillCodeFixTitle">
        <source>Use 'Clear()'</source>
        <target state="translated">使用“Clear()”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillDescription">
        <source>It is more efficient to use 'Clear', instead of 'Fill' with default value.</source>
        <target state="translated">使用“清除”(而不是具有默认值的“填充”)效率更高。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillMessage">
        <source>Prefer 'Span&lt;T&gt;.Clear()' instead of 'Span&lt;T&gt;.Fill(default)'</source>
        <target state="translated">首选“Span&lt;T&gt;.Clear()”而不是“Span&lt;T&gt;.Fill(default)”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillTitle">
        <source>Prefer 'Clear' over 'Fill'</source>
        <target state="translated">首选“清除”而不是“填充”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFixTitle">
        <source>Use 'StartsWith'</source>
        <target state="translated">使用 "StartsWith"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroDescription">
        <source>It is both clearer and faster to use 'StartsWith' instead of comparing the result of 'IndexOf' to zero.</source>
        <target state="translated">相较于将 "IndexOf" 的结果与零进行比较，使用 "StartsWith" 既更清晰又更快。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroMessage">
        <source>Use 'StartsWith' instead of comparing the result of 'IndexOf' to 0</source>
        <target state="translated">使用 "StartsWith"，而不是将 "IndexOf" 的结果与 0 进行比较</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroTitle">
        <source>Use 'StartsWith' instead of 'IndexOf'</source>
        <target state="translated">使用 "StartsWith" 而不是 "IndexOf"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersDescription">
        <source>'string.Contains(char)' is available as a better performing overload for single char lookup.</source>
        <target state="translated">“string.Contains(char)” 可用作用于单个字符查找的性能更好的重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.Contains(char)' instead of 'string.Contains(string)' when searching for a single character</source>
        <target state="translated">在搜索单个字符时使用 “string.Contains(char)” 而不是 “string.Contain(string)”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersTitle">
        <source>Use char literal for a single character lookup</source>
        <target state="translated">将字符型文本用于单个字符查找</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareCodeFixTitle">
        <source>Use 'string.Equals'</source>
        <target state="translated">使用 “string.Equals”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareDescription">
        <source>It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero.</source>
        <target state="translated">使用 “string.Equals” 更清晰还可能更快速，而不是将 “string.Compare” 的结果与零进行比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareMessage">
        <source>Use 'string.Equals' instead of comparing the result of 'string.Compare' to 0</source>
        <target state="translated">使用 “string.Equals”，而不是将 “string.Compare” 的结果与 0 进行比较</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareTitle">
        <source>Use 'string.Equals'</source>
        <target state="translated">使用 “string.Equals”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersDescription">
        <source>The char overload is a better performing overload than a string with a single char.</source>
        <target state="translated">与具有单个字符的字符串相比，字符重载的性能更好。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.{0}(char)' instead of 'string.{0}(string)' when you have a string with a single char</source>
        <target state="translated">当字符串具有单个字符时，请使用 "string.{0}(char)" 而不是 "string.{0}(string)"。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersTitle">
        <source>Use char overload</source>
        <target state="translated">使用字符重载</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperDescription">
        <source>Throw helpers are simpler and more efficient than an if block constructing a new exception instance.</source>
        <target state="translated">在构造新的异常实例方面，引发帮助程序比 if 块更简单、更高效。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperFix">
        <source>Use '{0}.{1}'</source>
        <target state="translated">使用 "{0}.{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperMessage">
        <source>Use '{0}.{1}' instead of explicitly throwing a new exception instance</source>
        <target state="translated">使用 "{0}.{1}"，而不是显式引发新的异常实例</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringDescription">
        <source>Platform compatibility analyzer requires a valid platform name and version.</source>
        <target state="translated">平台兼容性分析器需要有效的平台名称和版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringInvalidVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Use a version with 2{2} parts for this platform.</source>
        <target state="translated">版本“{0}”对于平台“{1}”无效。请为此平台使用包含 2{2} 部分的版本。</target>
        <note>Version '7' is not valid for platform 'windows'. Use a version with 2-4 parts for this platform.</note>
      </trans-unit>
      <trans-unit id="UseValidPlatformStringNoVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Do not use versions for this platform.</source>
        <target state="translated">版本“{0}”对于平台“{1}”无效。请勿对此平台使用版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringTitle">
        <source>Use valid platform string</source>
        <target state="translated">使用有效的平台字符串</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringUnknownPlatform">
        <source>The platform '{0}' is not a known platform name</source>
        <target state="translated">平台“{0}”不是已知的平台名称</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyDescription">
        <source>ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</source>
        <target state="translated">应直接等待从成员调用返回的 ValueTask。尝试多次使用 ValueTask 或在已知完成前直接访问结果可能导致异常或损坏。 忽略此类 ValueTask 很可能表示存在功能 bug，可能会降低性能。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_AccessingIncompleteResult">
        <source>ValueTask instances should not have their result directly accessed unless the instance has already completed. Unlike Tasks, calling Result or GetAwaiter().GetResult() on a ValueTask is not guaranteed to block until the operation completes. If you can't simply await the instance, consider first checking its IsCompleted property (or asserting it's true if you know that to be the case).</source>
        <target state="translated">ValueTask 实例不应让其结果可直接访问，除非该实例已完成。与任务不同，对 ValueTask 调用 Result 或 GetAwaiter().GetResult() 不能保证在操作完成前保持阻止。如果不能仅仅等待该实例，请考虑首先检查其 IsCompleted 属性(如果你知道是这种情况，则断言为 true)。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_DoubleConsumption">
        <source>ValueTask instances should only be consumed once, such as via an await. Consuming the same ValueTask instance multiple times can result in exceptions and data corruption.</source>
        <target state="translated">ValueTask 实例应只使用一次，例如通过 await。多次使用同一个 ValueTask 实例会导致异常和数据损坏。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_General">
        <source>ValueTask instances returned from method calls should be directly awaited, returned, or passed as an argument to another method call. Other usage, such as storing an instance into a local or a field, is likely an indication of a bug, as ValueTask instances must only ever be consumed once.</source>
        <target state="translated">从方法调用返回的 ValueTask 实例应直接等待、返回或作为参数传递给另一个方法调用。其他用法(例如，将实例存储到本地或字段中)可能表示存在 bug，因为 ValueTask 实例必须只使用一次。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_Unconsumed">
        <source>ValueTask instances returned from method calls should always be used, typically awaited. Not doing so often represents a functional bug, but even if it doesn't, it can result in degraded performance if the target method pools objects for use with ValueTasks.</source>
        <target state="translated">从方法调用返回的 ValueTask 实例应始终被使用(通常被等待)。如果不是这样，那么通常表示存在功能性 bug，但即使不存在功能性 bug，如果目标方法池对象与 ValueTask 一起使用，可能导致性能下降。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyTitle">
        <source>Use ValueTasks correctly</source>
        <target state="translated">正确使用 ValueTask</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">从不受信任的数据处理 XML 可能会加载危险的外部引用，这应该通过使用带有安全解析程序的 XmlReader 或禁用 DTD 处理来限制。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader for 'DataSet.ReadXml()'</source>
        <target state="translated">将 XmlReader 用于 "DataSet.ReadXml()"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader for 'XmlSerializer.Deserialize()'</source>
        <target state="translated">将 XmlReader 用于 "XmlSerializer.Deserialize()"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader for 'XmlSchema.Read()'</source>
        <target state="translated">将 XmlReader 用于 "XmlSchema.Read()"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader for XmlValidatingReader constructor</source>
        <target state="translated">将 XmlReader 用于 XmlValidatingReader 构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader for XPathDocument constructor</source>
        <target state="translated">将 XmlReader 用于 XPathDocument 构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the '{0}.{1}' method is potentially unsafe. It may enable Document Type Definition (DTD) which can be vulnerable to denial of service attacks, or might use an XmlResolver which can be vulnerable to information disclosure. Use an overload that takes a XmlReader instance instead, with DTD processing disabled and no XmlResolver.</source>
        <target state="translated">重载“{0}.{1}”方法可能不安全。这样做可能会启用文档类型定义(DTD)，DTD 可能会遭到拒绝服务攻击，这样做也可能会使用 XmlResolver，这可能会导致信息泄露。请改用采用 XmlReader 实例的重载，禁用 DTD 处理且没有 XmlResolver。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsesPreviewTypeParameterMessage">
        <source>'{0}' uses the preview type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">“{0}”使用预览类型“{1}”，并且需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsesPreviewTypeParameterMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' uses the preview type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3}.“{0}”使用预览类型“{1}”，并且需要选择加入预览功能。有关详细信息，请参阅 {2}。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
