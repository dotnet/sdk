<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../MicrosoftNetCoreAnalyzersResources.resx">
    <body>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">Dodaj atrybut „NonSerialized” do tego pola.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">Dodaj atrybut Serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherMode">
        <source>Review cipher mode usage with cryptography experts</source>
        <target state="translated">Przejrzyj użycie trybu szyfrowania wspólnie z ekspertami od kryptografii</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These cipher modes might be vulnerable to attacks. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">Te tryby szyfrowania mogą być podatne na ataki. Rozważ użycie zalecanych trybów (CBC, CTS).</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>Review the usage of cipher mode '{0}' with cryptography experts. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">Przejrzyj użycie trybu szyfrowania „{0}” wspólnie z ekspertami od kryptografii. Rozważ użycie zalecanych trybów (CBC, CTS).</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">Analiza parametru literału ciągu atrybutu pod kątem adresu URL, identyfikatora GUID lub wersji nie powiodła się.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'</source>
        <target state="translated">W konstruktorze typu „{0}” zmień wartość argumentu „{1}” (aktualnie „{2}”) na wartość, którą można poprawnie przeanalizować jako „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'</source>
        <target state="translated">W konstruktorze typu „{0}” zmień wartość argumentu „{1}” (aktualnie pusty ciąg — "") na wartość, którą można poprawnie przeanalizować jako „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">Analiza literałów ciągu atrybutu powinna kończyć się powodzeniem</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidConstArraysCodeFixTitle">
        <source>Extract to static readonly field</source>
        <target state="translated">Wyodrębnij do statycznego pola tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidConstArraysDescription">
        <source>Constant arrays passed as arguments are not reused when called repeatedly, which implies a new array is created each time. Consider extracting them to 'static readonly' fields to improve performance if the passed array is not mutated within the called method.</source>
        <target state="translated">Stałe macierze przekazywane jako argumenty nie są ponownie wykorzystywane podczas wielokrotnego wywoływania, co oznacza, że za każdym razem tworzona jest nowa macierz. Rozważ wyodrębnienie ich do pól 'static readonly', aby poprawić wydajność, jeśli przekazana macierz nie zostanie zmutowana w wywołanej metodzie.</target>
        <note>{Locked="static readonly"}</note>
      </trans-unit>
      <trans-unit id="AvoidConstArraysMessage">
        <source>Prefer 'static readonly' fields over constant array arguments if the called method is called repeatedly and is not mutating the passed array</source>
        <target state="translated">Preferowanie pól 'static readonly' zamiast stałych argumentów macierzy, jeśli wywoływana metoda jest wywoływana wielokrotnie i nie mutuje przekazanej macierzy .</target>
        <note>{Locked="static readonly"}</note>
      </trans-unit>
      <trans-unit id="AvoidConstArraysTitle">
        <source>Avoid constant arrays as arguments</source>
        <target state="translated">Unikaj tablic stałych jako argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingDescription">
        <source>In many situations, logging is disabled or set to a log level that results in an unnecessary evaluation for this argument.</source>
        <target state="translated">W wielu sytuacjach rejestrowanie jest wyłączone lub ustawione na poziom dziennika, co powoduje niepotrzebną ocenę tego argumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingMessage">
        <source>Evaluation of this argument may be expensive and unnecessary if logging is disabled</source>
        <target state="translated">Ocena tego argumentu może być kosztowna i niepotrzebna, jeśli rejestrowanie jest wyłączone</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingTitle">
        <source>Avoid potentially expensive logging</source>
        <target state="translated">Unikaj potencjalnie kosztownego rejestrowania</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsDescription">
        <source>Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead. Single use 'JsonSerializerOptions' instances can substantially degrade the performance of your application.</source>
        <target state="translated">Unikaj tworzenia nowego wystąpienia „JsonSerializerOptions” dla każdej operacji serializacji. Zamiast tego buforuj i ponownie wykorzystuj wystąpienia. Jednorazowe użycie wystąpienia „JsonSerializerOptions” może znacznie obniżyć wydajność aplikacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsMessage">
        <source>Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead.</source>
        <target state="translated">Unikaj tworzenia nowego wystąpienia „JsonSerializerOptions” dla każdej operacji serializacji. Zamiast tego buforuj i ponownie używaj wystąpień.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsTitle">
        <source>Cache and reuse 'JsonSerializerOptions' instances</source>
        <target state="translated">Buforuj i ponownie używaj wystąpień „JsonSerializerOptions”</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersDescription">
        <source>Marshalling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshalling operation.</source>
        <target state="translated">Marshalling elementu „StringBuilder” zawsze tworzy natywną kopię buforu, co powoduje powstanie wielu alokacji dla jednej operacji marshallingu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersMessage">
        <source>Avoid 'StringBuilder' parameters for P/Invokes. Consider using a character buffer instead.</source>
        <target state="translated">Unikaj parametrów „StringBuilder” dla elementów P/Invoke. Zamiast tego rozważ użycie bufora znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersTitle">
        <source>Avoid 'StringBuilder' parameters for P/Invokes</source>
        <target state="translated">Unikaj parametrów „StringBuilder” dla elementów P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadCodeFixTitle">
        <source>Use 'Stream.ReadExactly'</source>
        <target state="translated">Użyj elementu „Stream.ReadExactly”</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadDescription">
        <source>A call to 'Stream.Read' may return fewer bytes than requested, resulting in unreliable code if the return value is not checked.</source>
        <target state="translated">Wywołanie „Stream.Read” może zwrócić mniej bajtów niż żądano, powodując niewiarygodny kod, jeśli wartość zwracana nie jest zaznaczona.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadMessage">
        <source>Avoid inexact read with '{0}'</source>
        <target state="translated">Unikaj niedokładnego odczytu za pomocą „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadTitle">
        <source>Avoid inexact read with 'Stream.Read'</source>
        <target state="translated">Unikaj niedokładnego odczytu za pomocą „Stream.Read”</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">Biblioteka klas programu .NET Framework udostępnia metody umożliwiające pobieranie atrybutów niestandardowych. Domyślnie te metody przeszukują hierarchię dziedziczenia atrybutów. Zapieczętowanie atrybutu eliminuje potrzebę przeszukiwania hierarchii dziedziczenia i może podwyższyć wydajność.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Unikaj niezapieczętowanych atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Unikaj niezapieczętowanych atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">Unikaj niepotrzebnego alokowania tablic o długości zero.  Zamiast tego użyj elementu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations</source>
        <target state="translated">Unikaj alokowania tablic o długości zero</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">Metoda „{0}” nie jest bezpieczna podczas deserializowania niezaufanych danych bez użycia elementu SerializationBinder w celu ograniczenia typu obiektów w zdeserializowanym grafie obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</source>
        <target state="translated">Upewnij się, że właściwość BinaryFormatter.Binder jest ustawiona przed wywołaniem metody BinaryFormatter.Deserialize</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">Metoda „{0}” nie jest bezpieczna podczas deserializowania niezaufanych danych bez użycia elementu SerializationBinder w celu ograniczenia typu obiektów w zdeserializowanym grafie obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetTitle">
        <source>Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</source>
        <target state="translated">Nie wywołuj metody BinaryFormatter.Deserialize bez uprzedniego ustawienia właściwości BinaryFormatter.Binder</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect BinaryFormatter deserialization without a SerializationBinder set, then disable rule CA2300, and enable rules CA2301 and CA2302.</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializowania niezaufanych danych. Aby zamiast tego wykryć deserializację klasy BinaryFormatter bez ustawionego elementu SerializationBinder, wyłącz regułę CA2300 i włącz reguły CA2301 i CA2302.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializacji niezaufanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer BinaryFormatter</source>
        <target state="translated">Nie używaj niezabezpieczonego deserializatora BinaryFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyDescription">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.</source>
        <target state="translated">Element „Buffer.BlockCopy” oczekuje, że liczba bajtów zostanie skopiowana dla argumentu „count”. Użycie elementu „Array.Length” może nie odpowiadać liczbie bajtów, które należy skopiować.</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyLengthMessage">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.</source>
        <target state="translated">Element „Buffer.BlockCopy” oczekuje, że liczba bajtów zostanie skopiowana dla argumentu „count”. Użycie elementu „Array.Length” może nie odpowiadać liczbie bajtów, które należy skopiować.</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyLengthTitle">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument</source>
        <target state="translated">Element „Buffer.BlockCopy” oczekuje skopiowania liczby bajtów dla argumentu „count”</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).</source>
        <target state="translated">Implementacja metody Dispose nie wywołuje metody GC.SuppressFinalize lub metoda niebędąca implementacją metody Dispose wywołuje metodę GC.SuppressFinalize lub metoda wywołuje metodę GC.SuppressFinalize i przekazuje coś innego niż obiekt this (Me w języku Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">Zmień wywołanie {0} na wywołanie {1}. Zapobiega to konieczności ponownego implementowania interfejsu „IDisposable” przez typy pochodne wprowadzające finalizator.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">Zmień wywołanie {0} na wywołanie {1}. Zapobiega to niepotrzebnemu finalizowaniu obiektu po jego likwidacji i wyjściu poza zakres.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">Obiekt {0} wywołuje metodę {1} dla obiektu innego niż on sam. Zmień wywołanie, tak aby zamiast tego był przekazywany obiekt „this” („Me” w języku Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">Metoda {0} wywołuje metodę {1}, która zazwyczaj jest wywoływana tylko w ramach implementacji metody „IDisposable.Dispose”. Więcej informacji zawiera opis wzorca IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">Metoda Dispose powinna wywoływać metodę SuppressFinalize</target>
        <note />
      </trans-unit>
      <trans-unit id="CommaSeparator">
        <source>, </source>
        <target state="translated">, </target>
        <note>Separator used for separating list of platform names: {API} is only supported on: {‘windows’, ‘browser’, ‘linux’}</note>
      </trans-unit>
      <trans-unit id="ConstantExpectedApplicationDescription">
        <source>ConstantExpected attribute is not applied correctly on the parameter.</source>
        <target state="translated">Atrybut ConstantExpected nie jest poprawnie stosowany do parametru.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedApplicationTitle">
        <source>Incorrect usage of ConstantExpected attribute</source>
        <target state="translated">Nieprawidłowe użycie atrybutu ConstantExpected</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedAttributExpectedMessage">
        <source>The ConstantExpected attribute is required for the parameter due to the parent method annotation</source>
        <target state="translated">Atrybut ConstantExpected jest wymagany dla parametru z powodu adnotacji metody nadrzędnej</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedIncompatibleConstantTypeMessage">
        <source>The '{0}' value is not compatible with parameter type of '{1}'</source>
        <target state="translated">Wartość „{0}” jest niezgodna z typem parametru „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvalidBoundsMessage">
        <source>The '{0}' value does not fit within the parameter value bounds of '{1}' to '{2}'</source>
        <target state="translated">Wartość „{0}” nie mieści się w granicach wartości parametru od „{1}” do „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvalidMessage">
        <source>The constant is not of the same '{0}' type as the parameter</source>
        <target state="translated">Stała nie jest tego samego typu „{0}” co parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvertedRangeMessage">
        <source>The Min and Max values are inverted</source>
        <target state="translated">Wartości Min i Max są odwrócone</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedNotConstantMessage">
        <source>The argument should be a constant for optimal performance</source>
        <target state="translated">Argument powinien być stałą w celu uzyskania optymalnej wydajności</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedNotSupportedMessage">
        <source>The '{0}' type is not supported for ConstantExpected attribute</source>
        <target state="translated">Typ „{0}” nie jest obsługiwany dla atrybutu ConstantExpected</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedOutOfBoundsMessage">
        <source>The constant does not fit within the value bounds of '{0}' to '{1}'</source>
        <target state="translated">Stała nie mieści się w granicach wartości od „{0}” do „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedUsageDescription">
        <source>The parameter expects a constant for optimal performance.</source>
        <target state="translated">Parametr oczekuje stałej w celu uzyskania optymalnej wydajności.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedUsageTitle">
        <source>A constant is expected for the parameter</source>
        <target state="translated">Oczekiwano stałej dla parametru</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">Deserializowanie obiektu {0} podczas deserializacji niezaufanych danych wejściowych nie jest bezpieczne. Element „{1}” jest elementem {0} lub pochodzi od niego</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type found in deserializable object graph</source>
        <target state="translated">W wykresie obiektu, który można deserializować, znaleziono niebezpieczny typ DataSet lub DataTable</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}. Ensure that the auto-generated type is never deserialized with untrusted data.</source>
        <target state="translated">Deserializowanie obiektu {0} podczas deserializacji niezaufanych danych wejściowych za pomocą serializatora opartego na elemencie IFormatter nie jest bezpieczne. Element „{1}” jest elementem {0} lub pochodzi od niego. Upewnij się, że automatycznie wygenerowany typ nie jest nigdy deserializowany za pomocą niezaufanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in auto-generated serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">Niebezpieczny element DataSet lub DataTable w automatycznie wygenerowanym typie, który można serializować, może być podatny na zagrożenia polegające na zdalnym wykonaniu kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">Deserializowanie obiektu {0} podczas deserializacji niezaufanych danych wejściowych nie jest bezpieczne. Element „{1}” jest elementem {0} lub pochodzi od niego</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks</source>
        <target state="translated">Niebezpieczny element DataSet lub DataTable w zdeserializowanym wykresie obiektu może być narażony na ataki polegające na zdalnym wykonaniu kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}.</source>
        <target state="translated">Deserializowanie obiektu {0} podczas deserializacji niezaufanych danych wejściowych przy użyciu serializatora opartego na interfejsie IFormatter nie jest bezpieczne. Element „{1}” jest elementem {0} lub pochodzi od niego.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">Niebezpieczny element DataSet lub DataTable w typie, który można serializować, może być narażony na ataki polegające na zdalnym wykonaniu kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">Deserializowanie obiektu {0} podczas deserializacji niezaufanych danych wejściowych nie jest bezpieczne. Element „{1}” jest elementem {0} lub pochodzi od niego</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type</source>
        <target state="translated">Niebezpieczny element DataSet lub DataTable w typie, który można serializować</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">Deserializowanie obiektu {0} podczas deserializacji niezaufanych danych wejściowych nie jest bezpieczne. Element „{1}” jest elementem {0} lub pochodzi od niego</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type in web deserializable object graph</source>
        <target state="translated">W internetowym wykresie obiektu, który można deserializować, znaleziono niebezpieczny typ DataSet lub DataTable</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data. Make sure that auto-generated class containing the '{0}' call is not deserialized with untrusted data.</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializacji niezaufanych danych. Upewnij się, że automatycznie wygenerowana klasa zawierająca wywołanie „{0}” nie jest deserializowana za pomocą niezaufanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedTitle">
        <source>Ensure auto-generated class containing DataSet.ReadXml() is not used with untrusted data</source>
        <target state="translated">Upewnij się, że automatycznie wygenerowana klasa zawierająca element DataSet.ReadXml() nie jest używana w połączeniu z niezaufanymi danymi</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializacji niezaufanych danych</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlTitle">
        <source>Do not use DataSet.ReadXml() with untrusted data</source>
        <target state="translated">Nie używaj elementu DataSet.ReadXml() z niezaufanymi danymi</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializacji niezaufanych danych</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlTitle">
        <source>Do not use DataTable.ReadXml() with untrusted data</source>
        <target state="translated">Nie używaj elementu DataTable.ReadXml() z niezaufanymi danymi</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheck">
        <source>HttpClients should enable certificate revocation list checks</source>
        <target state="translated">Klienci HttpClients powinni włączyć sprawdzanie listy odwołania certyfikatów</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheckMessage">
        <source>HttpClient is created without enabling CheckCertificateRevocationList</source>
        <target state="translated">Program HttpClient jest tworzony bez włączania właściwości CheckCertificateRevocationList</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="translated">Nie dodawaj certyfikatów do magazynu głównego</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="translated">Dodanie certyfikatów do zaufanych certyfikatów głównych systemu operacyjnego zwiększa ryzyko niepoprawnego uwierzytelniania nieuprawnionego certyfikatu</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIV">
        <source>Do not use CreateEncryptor with non-default IV</source>
        <target state="translated">Nie używaj metody CreateEncryptor w wektorem inicjowania innym niż domyślny</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIVMessage">
        <source>Symmetric encryption uses non-default initialization vector, which could be potentially repeatable</source>
        <target state="translated">Szyfrowanie symetryczne używa wektora inicjowania innego niż domyślny, który potencjalnie może być powtarzalny</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">Użyj bezpiecznych plików cookie na platformie ASP.NET Core</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">Ustaw wartość CookieOptions.Secure = true podczas ustawiania pliku cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCount">
        <source>Do Not Use Weak Key Derivation Function With Insufficient Iteration Count</source>
        <target state="translated">Nie używaj funkcji wyprowadzania klucza słabego z niewystarczającą liczbą iteracji</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCountMessage">
        <source>Use at least {0} iterations when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">Użyj co najmniej {0} iteracji przy wyprowadzaniu klucza kryptograficznego z hasła. Domyślnie wartość IterationCount dla klasy Rfc2898DeriveByte to tylko 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsDescription">
        <source>Older protocol versions of Transport Layer Security (TLS) are less secure than TLS 1.2 and TLS 1.3, and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk.</source>
        <target state="translated">Starsze wersje protokołu Transport Layer Security (TLS) są mniej bezpieczne niż TLS 1.2 i TLS 1.3 i mogą być bardziej podatne na luki w zabezpieczeniach. Aby zminimalizować ryzyko, unikaj używania starszych wersji protokołu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsMessage">
        <source>Transport Layer Security protocol version '{0}' is deprecated.  Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">Wersja protokołu Transport Layer Security „{0}” jest przestarzała. Użyj opcji „Brak”, aby umożliwić systemowi operacyjnemu wybranie wersji.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsTitle">
        <source>Do not use deprecated SslProtocols values</source>
        <target state="translated">Nie używaj przestarzałych wartości SslProtocols</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivesFromPreviewClassMessage">
        <source>'{0}' derives from preview class '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">„{0}” jest elementem pochodnym klasy w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivesFromPreviewClassMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' derives from preview class '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} „{0}” jest elementem pochodnym klasy w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesDescription">
        <source>An assembly has to opt into preview features before using them.</source>
        <target state="translated">Zestaw musi wyrazić zgodę na korzystanie z funkcji w wersji zapoznawczej przed ich użyciem.</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesMessage">
        <source>Using '{0}' requires opting into preview features. See {1} for more information.</source>
        <target state="translated">Korzystanie z „{0}” wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesMessageWithCustomMessagePlaceholder">
        <source>{2} Using '{0}' requires opting into preview features. See {1} for more information.</source>
        <target state="translated">{2} Korzystanie z „{0}” wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesTitle">
        <source>This API requires opting into preview features</source>
        <target state="translated">Ten interfejs API wymaga zgody na funkcje w wersji zapoznawczej</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">Typ zawierający implementację interfejsu System.IDisposable deklaruje pola, których typy także zawierają implementację interfejsu IDisposable. Metoda Dispose pola nie jest wywoływana przez metodę Dispose typu deklarującego. Aby naprawić naruszenie tej reguły, wywołaj metodę Dispose dla pól, których typy zawierają implementację interfejsu IDisposable, jeśli odpowiadasz za przydzielanie i zwalnianie niezarządzanych zasobów wstrzymywanych przez pole.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>'{0}' contains field '{1}' that is of IDisposable type '{2}', but it is never disposed. Change the Dispose method on '{0}' to call Close or Dispose on this field.</source>
        <target state="translated">Element „{0}” zawiera pole „{1}” z interfejsem IDisposable typu „{2}”, ale nie jest nigdy likwidowany. Zmień metodę Dispose w elemencie „{0}”, aby wywołać metodę Close lub Dispose dla tego pola.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">Pola możliwe do likwidacji powinny zostać zlikwidowane</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">Typ implementujący interfejs System.IDisposable i zawierający pole sugerujące użycie zasobów niezarządzanych nie implementuje finalizatora w sposób określony przez metodę Object.Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">Typy możliwe do likwidacji powinny deklarować finalizator</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">Typy możliwe do likwidacji powinny deklarować finalizator</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.</source>
        <target state="translated">Typ, który implementuje interfejs System.IDisposable, dziedziczy po typie, który również implementuje interfejs IDisposable. Metoda Dispose typu dziedziczącego nie wywołuje metody Dispose typu nadrzędnego. Aby naprawić naruszenie tej reguły, wywołaj element base.Dispose w swojej metodzie Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Ensure that method '{0}' calls '{1}' in all possible control flow paths</source>
        <target state="translated">Upewnij się, że metoda „{0}” wywołuje element „{1}” we wszystkich możliwych ścieżkach przepływu sterowania</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose methods should call base class dispose</source>
        <target state="translated">Metody Dispose powinny wywoływać metodę Dispose klasy bazowej</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</source>
        <target state="translated">Jeśli możliwy do likwidacji obiekt nie zostanie jawnie zlikwidowany, zanim wszystkie odwołania do niego będą poza zakresem, obiekt zostanie zlikwidowany w nieokreślonym czasie, gdy moduł odzyskiwania pamięci uruchomi finalizatora obiektu. Ponieważ może wystąpić zdarzenie wyjątku, które uniemożliwi uruchomienie finalizatora obiektu, obiekt powinien zamiast tego zostać jawnie zlikwidowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">Użyj zalecanego wzorca dispose, aby upewnić się, że obiekt utworzony przez „{0}” jest likwidowany we wszystkich ścieżkach. Jeśli to możliwe, opakuj tworzenie w instrukcji „using” lub deklaracji „using”. W przeciwnym razie użyj wzorca try-finally, z dedykowaną zmienną lokalną zadeklarowaną przed regionem try i bezwarunkowym wywołaniem metody Dispose dla wartości innej niż null w regionie „finally”, na przykład „x?.Dispose()”. Jeśli obiekt jest jawnie likwidowany w regionie try lub własność dispose jest przenoszona do innego obiektu lub metody, przypisz wartość „null” do zmiennej lokalnej zaraz po takiej operacji, aby zapobiec podwójnemu wywołaniu dispose w regionie „finally”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all exception paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">Użyj zalecanego wzorca dispose, aby upewnić się, że obiekt utworzony przez „{0}” jest likwidowany we wszystkich ścieżkach wyjątków. Jeśli to możliwe, opakuj tworzenie w instrukcji „using” lub deklaracji „using”. W przeciwnym razie użyj wzorca try-finally, z dedykowaną zmienną lokalną zadeklarowaną przed regionem try i bezwarunkowym wywołaniem metody Dispose dla wartości innej niż null w regionie „finally”, na przykład „x?.Dispose()”. Jeśli obiekt jest jawnie likwidowany w regionie try lub własność dispose jest przenoszona do innego obiektu lub metody, przypisz wartość „null” do zmiennej lokalnej zaraz po takiej operacji, aby zapobiec podwójnemu wywołaniu dispose w regionie „finally”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedMessage">
        <source>Call System.IDisposable.Dispose on object created by '{0}' before all references to it are out of scope</source>
        <target state="translated">Wywołaj metodę System.IDisposable.Dispose dla obiektu utworzonego przez element „{0}”, zanim wszystkie odwołania do niego będą poza zakresem</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage">
        <source>Object created by '{0}' is not disposed along all exception paths. Call System.IDisposable.Dispose on the object before all references to it are out of scope.</source>
        <target state="translated">Obiekt utworzony przez metodę „{0}” nie jest likwidowany we wszystkich ścieżkach wyjątków. Wywołaj metodę System.IDisposable.Dispose dla obiektu, zanim wszystkie odwołania do niego będą poza zakresem.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose objects before losing scope</source>
        <target state="translated">Likwiduj obiekty przed utratą zakresu</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPath">
        <source>Do Not Add Archive Item's Path To The Target File System Path</source>
        <target state="translated">Nie dodawaj ścieżki elementu archiwum do docelowej ścieżki systemu plików</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription">
        <source>When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</source>
        <target state="translated">Podczas wyodrębniania plików z archiwum i używania ścieżki elementu archiwum sprawdź, czy ścieżka jest bezpieczna. Ścieżka archiwum może być ścieżką względną i może prowadzić do dostępu do systemu plików poza oczekiwaną ścieżką docelową systemu plików, doprowadzając do złośliwej zmiany konfiguracji i zdalnego wykonania kodu za pomocą techniki „podłóż i zaczekaj”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage">
        <source>When creating path for '{0} in method {1}' from relative archive item path to extract file and the source is an untrusted zip archive, make sure to sanitize relative archive item path '{2} in method {3}'</source>
        <target state="translated">Jeśli tworzona jest ścieżka dla „{0} w metodzie {1}” ze ścieżki względnej elementu archiwum w celu wyodrębnienia pliku, a źródło jest niezaufanym archiwum zip, upewnij się, że ścieżka względna elementu archiwum „{2} w metodzie {3}” jest oczyszczona.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">Nie dodawaj schematu przez adres URL</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">To przeciążenie metody XmlSchemaCollection.Add wewnętrznie umożliwia przetwarzanie elementu DTD w używanym wystąpieniu obiektu odczytującego XML i używa elementu UrlResolver do rozpoznawania zewnętrznych jednostek XML. Wynikiem jest ujawnienie informacji. 	Zawartość systemu plików lub udziałów sieciowych w przypadku maszynowego przetwarzania elementu XML może być narażona na atak. Ponadto atakujący może użyć tego jako wektora ataku DoS.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">To przeciążenie metody Add jest potencjalnie niebezpieczne, ponieważ może spowodować powstanie niebezpiecznych odwołań zewnętrznych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesDescription">
        <source>By setting critical TokenValidationParameter validation delegates to true, important authentication safeguards are disabled which can lead to tokens from any issuer or expired tokens being wrongly validated.</source>
        <target state="translated">Poprzez ustawienie krytycznych delegowań walidacji TokenValidationParameter na wartość true nastąpi wyłączenie ważnych zabezpieczeń uwierzytelniania, co może spowodować nieprawidłową walidację tokenów od dowolnego wystawcy lub wygasłych tokenów.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesMessage">
        <source>The {0} is set to a function that is always returning true. By setting the validation delegate, you are overriding default validation and by always returning true, this validation is completely disabled.</source>
        <target state="translated">{0} jest ustawiana na funkcję, która zawsze zwraca wartość true. Ustawienie delegowania walidacji spowoduje zastąpienie domyślnych ustawień walidacji i zwracanie wartości true, a ta walidacja zostanie całkowicie wyłączona.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesTitle">
        <source>Do not always skip token validation in delegates</source>
        <target state="translated">Nigdy nie pomijaj walidacji tokenów w delegacjach</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">Niezabezpieczona deserializacja to luka w zabezpieczeniach, która występuje, gdy niezaufane dane są używane w przypadku nadużywania logiki aplikacji, przeprowadzania ataku typu „odmowa usługi” (DoS), a nawet wykonywania kodu umownego w trakcie deserializacji. Złośliwi użytkownicy często mogą nadużywać tych funkcji deserializacji, gdy aplikacja deserializuje niezaufane dane, które są kontrolowane przez te funkcje. W szczególności może ona wywoływać niebezpieczne metody w procesie deserializacji. Skuteczne ataki typu „niezabezpieczona deserializacja” mogą pozwolić osobie atakującej na przeprowadzanie ataków, takich jak ataki DoS, pomijanie uwierzytelniania i zdalne wykonywanie kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class '{0}', method '{1}' can directly or indirectly call dangerous method '{2}'</source>
        <target state="translated">Podczas deserializacji wystąpienia klasy „{0}” metoda „{1}” może bezpośrednio lub pośrednio wywoływać niebezpieczną metodę „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationTitle">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">Nie wywołuj niebezpiecznych metod w deserializacji</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesDescription">
        <source>Enumerable.Cast&lt;T&gt; and Enumerable.OfType&lt;T&gt; require compatible types to function expectedly.  
The generic cast (IL 'unbox.any') used by the sequence returned by Enumerable.Cast&lt;T&gt; will throw InvalidCastException at runtime on elements of the types specified.  
The generic type check (C# 'is' operator/IL 'isinst') used by Enumerable.OfType&lt;T&gt; will never succeed with elements of types specified, resulting in an empty sequence.  
Widening and user defined conversions are not supported with generic types.</source>
        <target state="translated">Elementy Enumerable.Cast&lt;T&gt; i Enumerable.OfType&lt;T&gt; wymagają oczekiwanych zgodnych typów.  
Rzutowanie ogólne (IL „unbox.any”) używane przez sekwencję zwracaną przez element Enumerable.Cast&lt;T&gt; zgłosi wyjątek InvalidCastException w środowisku uruchomieniowym dla elementów określonych typów.  
Sprawdzanie typu ogólnego (operator „is” języka C# /IL „isinst”) używane przez element Enumerable.OfType&lt;T&gt; nigdy nie powiedzie się z określonymi elementami typów, co spowoduje powstanie pustej sekwencji.  
Konwersje poszerzane i zdefiniowane przez użytkownika nie są obsługiwane w przypadku typów ogólnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageCast">
        <source>Type '{0}' is incompatible with type '{1}' and cast attempts will throw InvalidCastException at runtime</source>
        <target state="translated">Typ „{0}” jest niezgodny z typem „{1}”, a próby rzutowania zgłoszą wyjątek InvalidCastException w środowisku uruchomieniowym</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageOfType">
        <source>This call will always result in an empty sequence because type '{0}' is incompatible with type '{1}'</source>
        <target state="translated">To wywołanie zawsze spowoduje powstanie pustej sekwencji, ponieważ typ „{0}” jest niezgodny z typem „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesTitle">
        <source>Do not call Enumerable.Cast&lt;T&gt; or Enumerable.OfType&lt;T&gt; with incompatible types</source>
        <target state="translated">Nie wywołuj metody Enumerable.Cast&lt;T&gt; ani Enumerable.OfType&lt;T&gt; z niezgodnymi typami</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueMessage">
        <source>Do not call {0} on an {1} value</source>
        <target state="translated">Nie wywołuj elementu {0} dla wartości {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueTitle">
        <source>Do not call ToImmutableCollection on an ImmutableCollection value</source>
        <target state="translated">Nie wywołuj elementu ToImmutableCollection dla wartości ImmutableCollection</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToDefaultMessage">
        <source>Comparing a span to 'default' might not do what you intended, make the code more explicit by checking 'IsEmpty'</source>
        <target state="translated">Porównanie rozpiętości do wartości „domyślne” może nie przynieść zamierzonego efektu, dlatego zwiększ jawność kodu, sprawdzając pozycję „IsEmpty”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullIsEmptyCodeFixTitle">
        <source>Use 'IsEmpty'</source>
        <target state="translated">Użyj elementu „IsEmpty”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullMessage">
        <source>Comparing a span to 'null' might be redundant, the 'null' literal will be implicitly converted to a 'Span&lt;T&gt;.Empty'</source>
        <target state="translated">Porównanie zakresu z wartością „null”może być nadmiarowe, literał „null” zostanie niejawnie przekonwertowany na literał „Span&lt;T&gt;.Empty”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullOrDefaultDescription">
        <source>Comparing a span to 'null' or 'default' might not do what you intended. 'default' and the 'null' literal are implicitly converted to 'Span&lt;T&gt;.Empty'. Remove the redundant comparison or make the code more explicit by using 'IsEmpty'.</source>
        <target state="translated">Porównanie zakresu z wartością „null” lub „domyślne” może nie działać zgodnie z oczekiwaniami. Literał „domyślne” i literał „null” są niejawnie konwertowane na wartość „Span&lt;T&gt;.Empty”. Usuń nadmiarowe porównanie lub zwiększ jawność kodu, używając elementu „IsEmpty”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullOrDefaultTitle">
        <source>Do not compare Span&lt;T&gt; to 'null' or 'default'</source>
        <target state="translated">Nie porównuj wartości Span&lt;T&gt; z wartością „null” lub „domyślne”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsDescription">
        <source>TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.  Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</source>
        <target state="translated">Element TaskCompletionSource ma konstruktory przyjmujące opcje TaskCreationOptions, które kontrolują podstawowe zadanie, oraz konstruktory, które przyjmują stan obiektu przechowywany w zadaniu. Przypadkowe przekazanie opcji TaskContinuationOptions zamiast opcji TaskCreationOptions spowoduje, że wywołanie potraktuje opcje jako stan.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsFix">
        <source>Replace TaskContinuationOptions with TaskCreationOptions.</source>
        <target state="translated">Zamień opcje TaskContinuationOptions na opcje TaskCreationOptions.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsMessage">
        <source>Argument contains TaskContinuationsOptions enum instead of TaskCreationOptions enum</source>
        <target state="translated">Argument zawiera wyliczenie opcji TaskContinuationsOptions zamiast wyliczenia opcji TaskCreationOptions</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsTitle">
        <source>Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</source>
        <target state="translated">Argument przekazany do konstruktora TaskCompletionSource musi być wyliczeniem opcji TaskCreationOptions, a nie wyliczeniem opcji TaskContinuationOptions</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerDescription">
        <source>Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear.</source>
        <target state="translated">Nie twórz zadań, o ile nie używasz jednego z przeciążeń, które akceptuje klasę TaskScheduler. Domyślne zachowanie to określanie harmonogramu przy użyciu metody TaskScheduler.Current, co może prowadzić do blokad. Użyj metody TaskScheduler.Default, aby określić harmonogram w puli wątków, lub jawnie przekaż metodę TaskScheduler.Current, aby wyraźnie wskazać zamiary.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerMessage">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">Nie twórz zadań bez przekazania klasy TaskScheduler</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerTitle">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">Nie twórz zadań bez przekazania klasy TaskScheduler</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerDescription">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;.</source>
        <target state="translated">Dodanie finalizatora do typu pochodzącego od typu MemoryManager&lt;T&gt; może umożliwić zwalnianie pamięci, gdy jest ona nadal używana przez typ Span&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerMessage">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;</source>
        <target state="translated">Dodanie finalizatora do typu pochodzącego od typu MemoryManager&lt;T&gt; może umożliwić zwalnianie pamięci, gdy jest ona nadal używana przez typ Span&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerTitle">
        <source>Do not define finalizers for types derived from MemoryManager&lt;T&gt;</source>
        <target state="translated">Nie definiuj finalizatorów dla typów pochodzących od typu MemoryManager&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">Nie należy wyłączać walidacji certyfikatów</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">Certyfikat może pomóc uwierzytelnić tożsamość serwera. Klienci powinni weryfikować certyfikat serwera, aby upewnić się, że żądania są wysyłane do odpowiedniego serwera. Jeśli element ServerCertificateValidationCallback zawsze zwraca wartość „true”, walidacja każdego certyfikatu zakończy się powodzeniem.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">Właściwość zestawu ServerCertificateValidationCallback została ustawiona na funkcję, która akceptuje dowolny certyfikat serwera, zawsze zwracając wartość true. Upewnij się, że certyfikaty serwera zostały walidowane, aby zweryfikować tożsamość serwera odbierającego żądania.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">Nie wyłączaj sprawdzania nagłówka HTTP</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">Sprawdzanie nagłówka HTTP umożliwia kodowanie znaków powrotu karetki i nowego wiersza, \r i \n, które znajdują się w nagłówkach odpowiedzi. To kodowanie może pomóc uniknąć ataków polegających na wstrzyknięciu kodu, które wykorzystują aplikację przekazującą niezaufane dane zawarte w nagłówku.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">Nie wyłączaj sprawdzania nagłówków HTTP</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHttpClientCRLCheckDescription">
        <source>Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid.</source>
        <target state="translated">Używanie programu HttpClient bez udostępnienia procedury obsługi specyficznej dla platformy (WinHttpHandler, CurlHandler lub HttpClientHandler), gdzie właściwość CheckCertificateRevocationList jest ustawiona na wartość true, zezwoli na akceptowanie odwołanych certyfikatów jako prawidłowe przez ten program.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">Nie wyłączaj weryfikacji żądań</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">Weryfikacja żądań to funkcja platformy ASP.NET, która sprawdza żądania HTTP i określa, czy zawierają potencjalnie niebezpieczną zawartość. To sprawdzenie zapewnia dodatkową ochronę przed znacznikami lub kodem w ciągu zapytania adresu URL, plikach cookie lub przesłanych wartościach formularza, które mogły zostać dodane w złośliwym celu. Ogólnie jest to pożądana funkcja i powinna pozostać włączona, aby zapewnić ochronę w głębi systemu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">Element {0} ma wyłączoną weryfikację żądań</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">Nie należy wyłączać użycia silnej kryptografii w pakiecie SChannel</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommended to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">Zaczynając od programu .NET Framework 4.6, klasy System.Net.ServicePointManager i System.Net.Security.SslStream są zalecane do użycia dla nowych protokołów. W starych występują słabości protokołu i nie są one obsługiwane. Ustawienie wartości true dla parametru Switch.System.Net.DontEnableSchUseStrongCrypto spowoduje użycie starego i słabego sprawdzania kryptograficznego oraz rezygnację z migracji protokołu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">Metoda {0} wyłącza protokół TLS 1.2 i włącza protokół SSLv3</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksDescription">
        <source>Token validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation.</source>
        <target state="translated">Sprawdzanie walidacji tokenu zagwarantuje, że podczas weryfikowania tokenów wszystkie aspekty zostaną poddane analizie i zweryfikowane. Wyłączenie walidacji może spowodować powstanie luk w zabezpieczeniach, umożliwiając niezaufanym tokenom przechodzenie przez proces walidacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksMessage">
        <source>TokenValidationParameters.{0} should not be set to false as it disables important validation</source>
        <target state="translated">TokenValidationParameters. {0} nie należy ustawiać na wartość false, ponieważ spowoduje to wyłączenie ważnych weryfikacji</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksTitle">
        <source>Do not disable token validation checks</source>
        <target state="translated">Nie wyłączaj sprawdzania walidacji tokenów</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsMessage">
        <source>Do not set Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols to true.  Setting this switch limits Windows Communication Framework (WCF) to using Transport Layer Security (TLS) 1.0, which is insecure and obsolete.</source>
        <target state="translated">Nie ustawiaj parametru Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols na wartość true. Ustawienie tego przełącznika ogranicza platformę Windows Communication Framework (WCF) do korzystania z protokołu Transport Layer Security (TLS) 1.0, który jest niezabezpieczony i przestarzały.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsTitle">
        <source>Do not disable ServicePointManagerSecurityProtocols</source>
        <target state="translated">Nie wyłączaj protokołów ServicePointManagerSecurityProtocols</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyDescription">
        <source>Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'. The former already checks whether the key exists, and will not throw if it does not.</source>
        <target state="translated">Nie należy chronić elementu \"Dictionary.Remove(key)\" za pomocą elementu \"Dictionary.ContainsKey(key)\". Pierwszy element sprawdza, czy klucz istnieje i nie generuje go w przypadku jego braku.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyMessage">
        <source>Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'</source>
        <target state="translated">Nie należy chronić elementu \"Dictionary.Remove(key)\" za pomocą elementu \"Dictionary.ContainsKey(key)\"</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyTitle">
        <source>Unnecessary call to 'Dictionary.ContainsKey(key)'</source>
        <target state="translated">Niepotrzebne wywołanie metody \"Dictionary.ContainsKey(key)\"</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsDescription">
        <source>Do not guard 'Add(item)' or 'Remove(item)' with 'Contains(item)' for the set. The former two already check whether the item exists and will return if it was added or removed.</source>
        <target state="translated">Nie chroń elementów „Add(item)” ani „Remove(item)” za pomocą elementu „Contains(item)” dla zestawu. Dwa poprzednie już sprawdzają, czy element istnieje, i zwrócą informację, czy został on dodany lub usunięty.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsMessage">
        <source>Do not guard '{0}' with '{1}'</source>
        <target state="translated">Nie chroń elementu „{0}” za pomocą elementu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsTitle">
        <source>Unnecessary call to 'Contains(item)'</source>
        <target state="translated">Niepotrzebne wywołanie elementu „Contains(item)”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificate">
        <source>Do not hard-code certificate</source>
        <target state="translated">Nie zapisuj certyfikatu na stałe w kodzie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateDescription">
        <source>Hard-coded certificates in source code are vulnerable to being exploited.</source>
        <target state="translated">Certyfikaty zapisane na stałe w kodzie źródłowym są podatne na wykorzystanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded certificate from '{2}' in method '{3}'</source>
        <target state="translated">Znaleziono potencjalną lukę w zabezpieczeniach. Element „{0}” w metodzie „{1}” może zostać zanieczyszczony zapisanym na stałe w kodzie certyfikatem z elementu „{2}” w metodzie „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKey">
        <source>Do not hard-code encryption key</source>
        <target state="translated">Nie zapisuj klucza szyfrowania na stałe w kodzie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyDescription">
        <source>SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hard-coded value.</source>
        <target state="translated">Właściwość .Key elementu SymmetricAlgorithm lub parametr rgbKey metody nigdy nie powinny być wartością zapisaną na stałe w kodzie.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded key from '{2}' in method '{3}'</source>
        <target state="translated">Znaleziono potencjalną lukę w zabezpieczeniach. Element „{0}” w metodzie „{1}” może zostać zanieczyszczony zapisanym na stałe w kodzie kluczem z elementu „{2}” w metodzie „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="translated">Domyślnie magazyn certyfikatów Zaufanych głównych urzędów certyfikacji jest skonfigurowany przy użyciu zbioru publicznych urzędów certyfikacji, który spełniają wymagania programu certyfikatów głównych firmy Microsoft. Ponieważ wszystkie Zaufane główne urzędy certyfikacji mogą wystawiać certyfikaty dla dowolnej domeny, osoba atakująca może wybrać słaby lub wymuszony urząd certyfikacji zainstalowany przez Ciebie, aby zainicjować atak — a jeden narażony na ataki, złośliwy lub wymuszony urząd certyfikacji osłabia bezpieczeństwo całego systemu. Co gorsza, tego typu ataki, w łatwy sposób mogą nawet zostać niezauważone.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">Obiekt ma słabą tożsamość, gdy jest bezpośrednio dostępny przez granice domeny aplikacji. Wątek próbujący założyć blokadę na obiekt o słabej tożsamości może zostać zablokowany przez drugi wątek w innej domenie aplikacji, który założył blokadę na ten sam obiekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Nie blokuj obiektów o słabej tożsamości</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Nie blokuj obiektów o słabej tożsamości</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersDescription">
        <source>A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.</source>
        <target state="translated">Metoda przekazuje literał ciągu jako parametr do konstruktora lub metody w bibliotece klas programu .NET Framework i ten ciąg powinien być możliwy do zlokalizowania. Aby naprawić naruszenie tej reguły, zastąp literał ciągu ciągiem pobranym za pomocą wystąpienia klasy ResourceManager.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersMessage">
        <source>Method '{0}' passes a literal string as parameter '{1}' of a call to '{2}'. Retrieve the following string(s) from a resource table instead: "{3}".</source>
        <target state="translated">Metoda {0} przekazuje ciąg literału jako parametr „{1}” wywołania elementu {2}. Zamiast tego pobierz następujące ciągi z tabeli zasobów: „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersTitle">
        <source>Do not pass literals as localized parameters</source>
        <target state="translated">Nie przekazuj literałów jako zlokalizowanych parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullCodeFixTitle">
        <source>Remove superfluous 'ArgumentNullException.ThrowIfNull' call</source>
        <target state="translated">Usuń zbędne wywołanie „ArgumentNullException.ThrowIfNull”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullDescription">
        <source>'ArgumentNullException.ThrowIfNull' throws when the passed argument is 'null'. Certain constructs like non-nullable structs, 'nameof()' and 'new' expressions are known to never be null, so 'ArgumentNullException.ThrowIfNull' will never throw.</source>
        <target state="translated">Element „ArgumentNullException.ThrowIfNull” zgłasza, gdy przekazany argument ma wartość „null”. Niektóre konstrukcje, takie jak struktury nie dopuszczające wartości null, wyrażenia „nameof()” i „nowy”, nigdy nie mają wartości null, więc metoda „ArgumentNullException.ThrowIfNull” nigdy nie będzie zgłaszać.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullMessage">
        <source>Calling 'ArgumentNullException.ThrowIfNull' and passing a non-nullable value is a no-op</source>
        <target state="translated">Wywołanie metody „ArgumentNullException.ThrowIfNull” i przekazanie wartości dopuszczającej wartość null jest operacją bezskuteczną</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullTitle">
        <source>Do not pass a non-nullable value to 'ArgumentNullException.ThrowIfNull'</source>
        <target state="translated">Nie przekazuj wartości nie dopuszczającej wartość null do elementu „ArgumentNullException.ThrowIfNull”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullCodeFixTitle">
        <source>Replace the 'ArgumentNullException.ThrowIfNull' call with a conditional</source>
        <target state="translated">Zastąp wywołanie „ArgumentNullException.ThrowIfNull” wywołaniem warunkowym</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullDescription">
        <source>'ArgumentNullException.ThrowIfNull' accepts an 'object', so passing a nullable struct may cause the value to be boxed.</source>
        <target state="translated">Element „ArgumentNullException.ThrowIfNull” akceptuje element „obiekt”, więc przekazanie struktury dopuszczającej wartość null może spowodować, że wartość zostanie zablokowana.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullMessage">
        <source>Passing a nullable struct to 'ArgumentNullException.ThrowIfNull' may cause boxing</source>
        <target state="translated">Przekazanie struktury dopuszczającej wartość null do elementu „ArgumentNullException.ThrowIfNull” może spowodować konwersję boxing</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullTitle">
        <source>Do not pass a nullable struct to 'ArgumentNullException.ThrowIfNull'</source>
        <target state="translated">Nie przekazuj struktury dopuszczającej wartość null do elementu „ArgumentNullException.ThrowIfNull”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">Wyjątek typu, który nie jest wystarczająco specyficzny lub został zastrzeżony przez środowisko uruchomieniowe, nie powinien być nigdy zgłaszany przez kod użytkownika. Utrudnia to wykrycie i zdebugowanie pierwotnego błędu. Jeśli to wystąpienie wyjątku może zostać zgłoszone, użyj innego typu wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime</source>
        <target state="translated">Typ wyjątku {0} został zastrzeżony przez środowisko uruchomieniowe</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific</source>
        <target state="translated">Typ wyjątku {0} nie jest wystarczająco specyficzny</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">Nie zgłaszaj wyjątków zastrzeżonych typów</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">Nie serializuj typów z polami wskaźników</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">Wskaźniki nie są „bezpieczne pod względem typu” w tym sensie, że nie można zagwarantować poprawności pamięci, którą wskazują. W związu z tym serializowanie typów z polami wskaźnika jest niebezpieczne, ponieważ może umożliwić atakującemu kontrolowanie wskaźnika.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type</source>
        <target state="translated">Pole wskaźnika {0} w typie przeznaczonym do serializacji</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">Nie korzystaj z sygnatury dostępu współdzielonego konta</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">Sygnatury dostępu współdzielonego (SAS) są istotną częścią modelu zabezpieczeń każdej aplikacji korzystającej z usługi Azure Storage. Powinny one zapewniać ograniczone i bezpieczne uprawnienia do konta magazynu klientom, którzy nie mają klucza konta. Wszystkie operacje dostępne za pośrednictwem sygnatury dostępu współdzielonego usługi są także dostępne za pośrednictwem sygnatury dostępu współdzielonego konta, co oznacza, że sygnatura dostępu współdzielonego konta daje zbyt szerokie uprawnienia. Dlatego zaleca się, aby korzystać z sygnatury dostępu współdzielonego usługi do ostrożniejszego delegowania dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">Użyj sygnatury dostępu współdzielonego usługi zamiast sygnatury dostępu współdzielonego konta w celu uzyskania szczegółowej kontroli dostępu i zasad dostępu na poziomie kontenera</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">Nie używaj złamanych algorytmów kryptograficznych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">Możliwe jest przeprowadzenie ataku umożliwiającego obliczeniowe złamanie tego algorytmu. Pozwala to atakującym na złamanie kryptograficznych gwarancji, jakie powinien zapewniać. W zależności od typu i zastosowania tego algorytmu kryptograficznego może to umożliwić atakującemu odczytanie zaszyfrowanych wiadomości, ingerowanie w zaszyfrowane wiadomości, fałszowanie podpisów cyfrowych, ingerowanie w mieszaną zawartość lub inne naruszenie systemu kryptograficznego opartego na tym algorytmie. Zastąp użycia szyfrowane algorytmem AES (akceptowane są algorytmy AES-256, AES-192 i AES-128) z kluczem o długości równej lub większej niż 128 bitów. Zastąp użycia mieszane funkcją skrótu z rodziny SHA-2, taką jak SHA512, SHA384 lub SHA256. Zastąp użycia podpisu cyfrowego certyfikatem RSA z kluczem o długości równej lub większej niż 2048 bitów lub certyfikatem ECDSA z kluczem o długości równej lub większej niż 256 bitów.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">Element {0} używa złamanych algorytmów kryptograficznych {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingDescription">
        <source>The ConfigureAwaitOptions.SuppressThrowing option is only supported with the non-generic Task, not a Task&lt;TResult&gt;.  To use it with a Task&lt;TResult&gt;, first cast to the base Task.</source>
        <target state="translated">Metoda ConfigureAwaitOptions.SuppressThrowing jest obsługiwana tylko z zadaniem niegenerycznym, a nie zadaniem &lt;TResult&gt;.  Aby użyć ją z zadaniem &lt;TResult&gt;, najpierw rzutuj na zadanie podstawowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingMessage">
        <source>The ConfigureAwaitOptions.SuppressThrowing option is only supported with the non-generic Task</source>
        <target state="translated">Metoda ConfigureAwaitOptions.SuppressThrowing jest obsługiwana tylko z zadaniem niegenerycznym</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingTitle">
        <source>Do not use ConfigureAwaitOptions.SuppressThrowing with Task&lt;TResult&gt;</source>
        <target state="translated">Nie używaj metody ConfigureAwaitOptions.SuppressThrowing z zadaniem&lt;TResult&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedDescription">
        <source>For non-empty collections, CountAsync() and LongCountAsync() enumerate the entire sequence, while AnyAsync() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">W przypadku niepustych kolekcji funkcje CountAsync() i LongCountAsync() wyliczają całą sekwencję, podczas gdy funkcja AnyAsync() zatrzymuje się na pierwszym elemencie lub pierwszym elemencie, który spełnia warunek.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedMessage">
        <source>{0}() is used where AnyAsync() could be used instead to improve performance</source>
        <target state="translated">Funkcja {0}() jest używana w miejscach, w których można użyć funkcji AnyAsync() w celu zwiększenia wydajności</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedTitle">
        <source>Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used</source>
        <target state="translated">Nie używaj funkcji CountAsync() ani LongCountAsync(), gdy można użyć funkcji AnyAsync()</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedDescription">
        <source>For non-empty collections, Count() and LongCount() enumerate the entire sequence, while Any() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">W przypadku niepustych kolekcji funkcje Count() i LongCount() wyliczają całą sekwencję, podczas gdy funkcja Any() zatrzymuje się na pierwszym elemencie lub pierwszym elemencie, który spełnia warunek.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedMessage">
        <source>{0}() is used where Any() could be used instead to improve performance</source>
        <target state="translated">Funkcja {0}() jest używana w miejscach, w których można użyć funkcji Any() w celu zwiększenia wydajności</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedTitle">
        <source>Do not use Count() or LongCount() when Any() can be used</source>
        <target state="translated">Nie używaj funkcji Count() ani LongCount(), gdy można użyć funkcji Any()</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCreateEncryptorWithNonDefaultIVDescription">
        <source>Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</source>
        <target state="translated">Szyfrowanie symetryczne powinno zawsze używać wektora inicjowania, który nie jest powtarzalny, aby zapobiec atakom słownikowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="translated">Nie używaj algorytmu Digital Signature Algorithm (DSA)</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="translated">Algorytm DSA jest zbyt słaby, aby go użyć.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">Algorytm szyfrowania asymetrycznego {0} jest słaby. Przełącz się na algorytm RSA z kluczem o rozmiarze co najmniej 2048, algorytm ECDH lub algorytm ECDSA.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">Nie używaj przestarzałych protokołów zabezpieczeń</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">Używanie przestarzałego protokołu zabezpieczeń zamiast domyślnego ustawienia systemowego jest ryzykowne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">Zakodowane korzystanie z przestarzałego protokołu zabezpieczeń {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsDescription">
        <source>The property 'StreamReader.EndOfStream' can cause unintended synchronous blocking when no data is buffered. Instead, use 'StreamReader.ReadLineAsync' directly, which returns 'null' when reaching the end of the stream.</source>
        <target state="translated">Właściwość „StreamReader.EndOfStream” może powodować niezamierzone blokowanie synchroniczne, gdy żadne dane nie są buforowane. Zamiast tego użyj właściwości „StreamReader.ReadLineAsync” bezpośrednio, która zwraca wartość „null” po osiągnięciu końca strumienia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsMessage">
        <source>Do not use '{0}' in an async method</source>
        <target state="translated">Nie używaj elementu „{0}” w metodzie asynchronicznej</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsTitle">
        <source>Do not use 'StreamReader.EndOfStream' in async methods</source>
        <target state="translated">Nie używaj właściwości „StreamReader.EndOfStream” w metodach asynchronicznych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">Tę kolekcję można zaindeksować bezpośrednio. Użycie w tym miejscu kodu LINQ powoduje niepotrzebne alokacje i obciążenie procesora CPU.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly.</source>
        <target state="translated">Nie używaj metod typu Enumerable dla kolekcji indeksowalnych. Zamiast tego użyj kolekcji bezpośrednio.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections</source>
        <target state="translated">Nie używaj metod typu Enumerable dla kolekcji indeksowalnych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomness">
        <source>Do not use insecure randomness</source>
        <target state="translated">Nie używaj niezabezpieczonej losowości</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessDescription">
        <source>Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated. Use a cryptographically strong random number generator if an unpredictable value is required, or ensure that weak pseudo-random numbers aren't used in a security-sensitive manner.</source>
        <target state="translated">Użycie kryptograficznie słabego generatora liczb pseudolosowych może umożliwić osobie atakującej przewidzenie, jaka wartość wpływająca na zabezpieczenia zostanie wygenerowana. Użyj kryptograficznie silnego generatora liczb losowych, jeśli jest wymagana wartość niemożliwa do przewidzenia, lub upewnij się, że liczby pseudolosowe nie są używane w przypadku wartości wpływających na zabezpieczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessMessage">
        <source>{0} is an insecure random number generator. Use cryptographically secure random number generators when randomness is required for security.</source>
        <target state="translated">{0} to niezabezpieczony generator liczb losowych. Użyj kryptograficznie zabezpieczonego generatora liczb losowych, gdy losowość jest wymagana ze względów bezpieczeństwa.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">Nie używaj przestarzałej funkcji wyprowadzenia klucza</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">Wyprowadzenie klucza oparte na haśle powinno używać funkcji PBKDF2 z algorytmem SHA-2. Unikaj używania klasy PasswordDeriveBytes, ponieważ generuje ona klucz PBKDF1. Unikaj używania klasy Rfc2898DeriveBytes.CryptDeriveKey, ponieważ nie używa ona liczby iteracji ani wartości zaburzającej.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">Wywołanie przestarzałej funkcji wyprowadzania klucza {0}.{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersDescription">
        <source>String parameters passed by value with the 'OutAttribute' can destabilize the runtime if the string is an interned string.</source>
        <target state="translated">Parametry ciągu przekazywane przez wartość przy użyciu elementu „OutAttribute” mogą destabilizować środowisko uruchomieniowe, jeśli ciąg jest ciągiem internalizowanym.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersMessage">
        <source>Do not use the 'OutAttribute' for string parameter '{0}' which is passed by value. If marshalling of modified data back to the caller is required, use the 'out' keyword to pass the string by reference instead.</source>
        <target state="translated">Nie używaj elementu „OutAttribute” dla parametru ciągu „{0}”, który jest przekazywany przez wartość. Jeśli jest wymagane kierowanie zmodyfikowanych danych z powrotem do obiektu wywołującego, użyj słowa kluczowego „out”, aby zamiast tego przekazać ciąg przez odwołanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersTitle">
        <source>Do not use 'OutAttribute' on string parameters for P/Invokes</source>
        <target state="translated">Nie używaj elementu „OutAttribute” w przypadku parametrów ciągu dla elementów P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesComparerMessage">
        <source>Do not pass an argument with value type '{0}' to the 'Equals' method on 'ReferenceEqualityComparer'. Due to value boxing, this call to 'Equals' can return an unexpected result. Consider using 'EqualityComparer' instead, or pass reference type arguments if you intend to use 'ReferenceEqualityComparer'.</source>
        <target state="translated">Nie przekazuj argumentu o typie wartości „{0}” do metody „Equals” w elemencie „ReferenceEqualityComparer”. Ze względu na boxing wartości to wywołanie „Equals” może zwrócić nieoczekiwany wynik. Zamiast tego rozważ użycie elementu „EqualityComparer” lub przekaż argumenty typu odwołania, jeśli zamierzasz użyć elementu „ReferenceEqualityComparer”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesDescription">
        <source>Value type typed arguments are uniquely boxed for each call to this method, therefore the result can be unexpected.</source>
        <target state="translated">Argumenty wpisane w typie wartości są unikatowo blokowane dla każdego wywołania tej metody, dlatego wynik może być nieoczekiwany.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesMethodMessage">
        <source>Do not pass an argument with value type '{0}' to 'ReferenceEquals'. Due to value boxing, this call to 'ReferenceEquals' can return an unexpected result. Consider using 'Equals' instead, or pass reference type arguments if you intend to use 'ReferenceEquals'.</source>
        <target state="translated">Nie przekazuj argumentu o typie wartości „{0}” do elementu „ReferenceEquals”. Ze względu na boxing wartości to wywołanie elementu „ReferenceEquals” może zwrócić nieoczekiwany wynik. Zamiast tego rozważ użycie elementu „Equals” lub przekaż argumenty typu odwołania, jeśli zamierzasz użyć elementu „ReferenceEquals”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesTitle">
        <source>Do not use ReferenceEquals with value types</source>
        <target state="translated">Nie używaj metody ReferenceEquals z typami wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsDescription">
        <source>Stack space allocated by a stackalloc is only released at the end of the current method's invocation.  Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</source>
        <target state="translated">Miejsce na stosie przydzielone przy użyciu słowa kluczowego stackalloc jest zwalniane jedynie na końcu wywołania bieżącej metody. Użycie go w pętli może spowodować nieograniczone powiększanie stosu i, ostatecznie, warunki przepełnienia stosu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsMessage">
        <source>Potential stack overflow. Move the stackalloc out of the loop.</source>
        <target state="translated">Potencjalne przepełnienie stosu. Przenieś słowo kluczowe stackalloc z pętli.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsTitle">
        <source>Do not use stackalloc in loops</source>
        <target state="translated">Nie używaj słowa kluczowego stackalloc w pętlach</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseThreadVolatileReadWriteCodeFixTitle">
        <source>Replace obsolete call</source>
        <target state="translated">Zamień przestarzałe wywołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">Działania okresowe wykonywane z dużą częstotliwością utrzymują zajętość procesora CPU i wpływają na czasomierze bezczynności funkcji oszczędzania energii, które powodują wyłączanie ekranu i dysków twardych.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Nie używaj czasomierzy, które uniemożliwiają zmiany stanu zasilania</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Nie używaj czasomierzy, które uniemożliwiają zmiany stanu zasilania</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPath">
        <source>Do not use unsafe DllImportSearchPath value</source>
        <target state="translated">Nie używaj niebezpiecznej wartości DllImportSearchPath</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathDescription">
        <source>There could be a malicious DLL in the default DLL search directories. Or, depending on where your application is run from, there could be a malicious DLL in the application's directory. Use a DllImportSearchPath value that specifies an explicit search path instead. The DllImportSearchPath flags that this rule looks for can be configured in .editorconfig.</source>
        <target state="translated">W domyślnych katalogach wyszukiwania bibliotek DLL może znajdować się złośliwa biblioteka DLL albo, w zależności od tego, z jakiej lokalizacji jest uruchamiana aplikacja, złośliwa biblioteka DLL może znajdować się w katalogu aplikacji. W zastępstwie użyj wartości DllImportSearchPath, która określa jawną ścieżkę wyszukiwania. Flagi DllImportSearchPath, które wyszukuje ta reguła, można skonfigurować w pliku .editorconfig.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathMessage">
        <source>Use of unsafe DllImportSearchPath value {0}</source>
        <target state="translated">Użycie niebezpiecznej wartości DllImportSearchPath {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskDescription">
        <source>Using 'WaitAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="translated">Użycie wywołania „WaitAll” z pojedynczym zadaniem może spowodować utratę wydajności, pojawienie się parametru await lub zwrócenie zadania.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskFix">
        <source>Replace 'WaitAll' with single 'Wait'</source>
        <target state="translated">Zastąp wywołanie „WaitAll” pojedynczym wywołaniem „Wait”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskTitle">
        <source>Do not use 'WaitAll' with a single task</source>
        <target state="translated">Nie używaj wywołania „WaitAll” z pojedynczym zadaniem</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">Nie używaj słabych algorytmów kryptograficznych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">Algorytmy kryptograficzne pogarszają się z upływem czasu, ponieważ ataki stają się coraz bardziej zaawansowane, a atakujący zyskują dostęp do większej ilości zasobów obliczeniowych. W zależności od typu i zastosowania tego algorytmu kryptograficznego dalsze osłabianie siły kryptograficznej algorytmu może umożliwić atakującemu odczytanie zaszyfrowanych wiadomości, ingerowanie w zaszyfrowane wiadomości, fałszowanie podpisów cyfrowych, ingerowanie w mieszaną zawartość lub inne naruszenie systemu kryptograficznego opartego na tym algorytmie. Zastąp użycia szyfrowane algorytmem AES (akceptowane są algorytmy AES-256, AES-192 i AES-128) z kluczem o długości równej lub większej niż 128 bitów. Zastąp użycia mieszane funkcją skrótu z rodziny SHA-2, taką jak SHA-2 512, SHA-2 384 lub SHA-2 256.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">Element {0} używa słabych algorytmów kryptograficznych {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Ensure Key Derivation Function algorithm is sufficiently strong</source>
        <target state="translated">Upewnij się, że algorytm funkcji wyprowadzania klucza jest dostatecznie silny</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="translated">Niektóre implementacje klasy Rfc2898DeriveBytes umożliwiają określenie algorytmu wyznaczania wartości skrótu w parametrze konstruktora lub jego zastąpienie we właściwości HashAlgorithm. Jeśli algorytm wyznaczania wartości skrótu istnieje, powinien być to SHA-256 lub wyższy.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} might be using a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password.</source>
        <target state="translated">Element {0} prawdopodobnie używa słabego algorytmu wyznaczania wartości skrótu. Aby utworzyć silny klucz na podstawie hasła, użyj algorytmu SHA256, SHA384 lub SHA512.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFInsufficientIterationCountDescription">
        <source>When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).</source>
        <target state="translated">Wyprowadzając klucze kryptograficzne z danych wejściowych wprowadzonych przez użytkownika, takich jak hasło, użyj wystarczającej liczby iteracji (co najmniej 100 tys.).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskDescription">
        <source>Using 'WhenAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="translated">Użycie wywołania „WhenAll” z pojedynczym zadaniem może spowodować utratę wydajności, pojawienie się parametru await lub zwrócenie zadania.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskFix">
        <source>Replace 'WhenAll' call with argument</source>
        <target state="translated">Zastąp wywołanie „WhenAll” argumentem</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskTitle">
        <source>Do not use 'WhenAll' with a single task</source>
        <target state="translated">Nie używaj wywołania „WhenAll” z pojedynczym zadaniem</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">Nie używaj klasy XslTransform</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">Nie używaj klasy XslTransform. Nie ogranicza to potencjalnie niebezpiecznych odwołań zewnętrznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedDescription">
        <source>Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic.</source>
        <target state="translated">Udostępnienie funkcjonalnego atrybutu „DynamicInterfaceCastableImplementationAttribute” wymaga funkcji Domyślne składowe interfejsu, która nie jest obsługiwana w języku Visual Basic.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedMessage">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="translated">Udostępnianie interfejsu „DynamicInterfaceCastableImplementation” w języku Visual Basic nie jest obsługiwane</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedTitle">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="translated">Udostępnianie interfejsu „DynamicInterfaceCastableImplementation” w języku Visual Basic nie jest obsługiwane</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledDescription">
        <source>Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.</source>
        <target state="translated">Użycie funkcji, które wymagają kierowania środowiska uruchomieniowego, gdy kierowanie środowiska uruchomieniowego jest wyłączone, spowoduje wyjątki środowiska uruchomieniowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageAutoLayoutTypes">
        <source>Types with '[StructLayout(LayoutKind.Auto)]' require runtime marshalling to be enabled</source>
        <target state="translated">Typy z elementem „[StructLayout(LayoutKind.Auto)]“ wymagają włączenia kierowania środowiska uruchomieniowego</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageByRefParameters">
        <source>By-ref parameters require runtime marshalling to be enabled</source>
        <target state="translated">Parametry by-ref wymagają włączenia kierowania środowiska uruchomieniowego</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageDelegateUsage">
        <source>Delegates with managed types as parameters or the return type require runtime marshalling to be enabled in the assembly where the delegate is defined</source>
        <target state="translated">Pełnomocnicy z typami zarządzanymi jako parametrami lub zwracanym typem wymagają włączenia kierowania środowiska uruchomieniowego w zestawie, w którym zdefiniowano pełnomocnika.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageHResultSwapping">
        <source>HResult-swapping requires runtime marshalling to be enabled</source>
        <target state="translated">Zamiana HResult wymaga włączenia kierowania środowiska uruchomieniowego</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageLCIDConversionAttribute">
        <source>Using 'LCIDConversionAttribute' requires runtime marshalling to be enabled</source>
        <target state="translated">Użycie atrybutu „LCIDConversionAttribute“ wymaga włączenia kierowania środowiska uruchomieniowego</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageManagedParameterOrReturnTypes">
        <source>Managed parameter or return types require runtime marshalling to be enabled</source>
        <target state="translated">Typy parametrów zarządzanych lub zwracanych wymagają włączenia kierowania środowiska uruchomieniowego</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageSetLastError">
        <source>Setting SetLastError to 'true' requires runtime marshalling to be enabled</source>
        <target state="translated">Ustawienie wartości SetLastError na wartość „True“ wymaga włączenia kierowania środowiska uruchomieniowego</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageVarargPInvokes">
        <source>Varadic P/Invoke signatures require runtime marshalling to be enabled</source>
        <target state="translated">Sygnatury Varadic P/Invoke wymagają włączenia kierowania środowiska uruchomieniowego</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledTitle">
        <source>Property, type, or attribute requires runtime marshalling</source>
        <target state="translated">Właściwość, typ lub atrybut wymaga kierowania środowiska uruchomieniowego</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldIsPreviewTypeMessage">
        <source>'{0}''s type contains the preview type '{1}' and requires opting into preview features. See {2} for more information.</source>
        <target state="translated">Typ elementu „{0}” zawiera typ w wersji zapoznawczej „{1}” i wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldIsPreviewTypeMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}''s type contains the preview type '{1}' and requires opting into preview features. See {2} for more information.</source>
        <target state="translated">{3} „{0}” — typ tego elementu zawiera typ w wersji zapoznawczej „{1}” i wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsDescription">
        <source>Forward the 'CancellationToken' parameter to methods to ensure the operation cancellation notifications gets properly propagated, or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token.</source>
        <target state="translated">Prześlij dalej parametr „CancellationToken” do metod, aby upewnić się, że powiadomienia o anulowaniu operacji zostaną prawidłowo rozpropagowane, lub przekaż element „CancellationToken.None” jawnie, aby wskazać celowe niepropagowanie tokenu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsMessage">
        <source>Forward the '{0}' parameter to the '{1}' method or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token</source>
        <target state="translated">Prześlij dalej parametr „{0}” do metody „{1}” lub przekaż element „CancellationToken.None” jawnie, aby wskazać celowe niepropagowanie tokenu</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsTitle">
        <source>Forward the 'CancellationToken' parameter to methods</source>
        <target state="translated">Prześlij dalej parametr „CancellationToken” do metod</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="translated">Unikaj kodowania na stałe wartości SecurityProtocolType {0} i zamiast tego użyj wartości SecurityProtocolType.SystemDefault, aby umożliwić systemowi operacyjnemu wybranie najlepszego protokołu Transport Layer Security do użycia.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="translated">Unikaj kodowania na stałe wartości SecurityProtocolType</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsDescription">
        <source>Current Transport Layer Security protocol versions may become deprecated if vulnerabilities are found. Avoid hardcoding SslProtocols values to keep your application secure. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">Bieżące wersje protokołu Transport Layer Security mogą zostać uznane za przestarzałe w przypadku znalezienia luk w zabezpieczeniach. Unikaj kodowania na stałe wartości SslProtocols, aby zachować bezpieczeństwo aplikacji. Użyj opcji „Brak”, aby umożliwić systemowi operacyjnemu wybranie wersji.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsMessage">
        <source>Avoid hardcoding SslProtocols '{0}' to ensure your application remains secure in the future. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">Unikaj kodowania na stałe wartości SslProtocols „{0}”, aby zapewnić bezpieczeństwo aplikacji w przyszłości. Użyj opcji „Brak”, aby umożliwić systemowi operacyjnemu wybranie wersji.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsTitle">
        <source>Avoid hardcoded SslProtocols values</source>
        <target state="translated">Unikaj kodowania na stałe wartości SslProtocols</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyDescription">
        <source>Generic math interfaces require the derived type itself to be used for the self recurring type parameter.</source>
        <target state="translated">Ogólne interfejsy matematyczne wymagają, aby sam typ pochodny był używany dla parametru typu cyklicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyMessage">
        <source>The '{0}' requires the '{1}' type parameter to be filled with the derived type '{2}'</source>
        <target state="translated">Element „{0}” wymaga wypełnienia parametru typu „{1}” typem pochodnym „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyTitle">
        <source>Use correct type parameter</source>
        <target state="translated">Użyj poprawnego parametru typu</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementInterfacesOnDynamicCastableImplementation">
        <source>Implement inherited interfaces</source>
        <target state="translated">Implementuj interfejsy dziedziczone</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewInterfaceMessage">
        <source>'{0}' implements the preview interface '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">„{0}” ma zaimplementowany interfejs w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewInterfaceMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' implements the preview interface '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} „{0}” ma zaimplementowany interfejs w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewMethodMessage">
        <source>'{0}' implements the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">„{0}” ma zaimplementowaną metodę w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewMethodMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' implements the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} „{0}” ma zaimplementowaną metodę w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Typ referencyjny deklaruje jawny konstruktor statyczny. Aby naprawić naruszenie tej reguły, zainicjuj wszystkie dane statyczne podczas ich deklarowania i usuń konstruktor statyczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">Zainicjuj pola statyczne typu referencyjnego w deklaracji pól</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">Zainicjuj wszystkie pola statyczne typu „{0}” w ramach ich deklaracji i usuń jawny konstruktor statyczny</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Typ wartości deklaruje jawny konstruktor statyczny. Aby naprawić naruszenie tej reguły, zainicjuj wszystkie dane statyczne podczas ich deklarowania i usuń konstruktor statyczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">Zainicjuj pola statyczne typu wartości w deklaracji pól</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyChangeToTwoArgumentCodeFixTitle">
        <source>Change to call the two argument constructor, pass null for the message.</source>
        <target state="translated">Zmień, aby wywołać konstruktora z dwoma argumentami i przekazać wartość null dla komunikatu.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">Wywołano domyślny (bezparametrowy) konstruktor typu wyjątku ArgumentException lub typu pochodzącego od niego albo przekazano niepoprawny argument ciągu do konstruktora parametryzowanego typu wyjątku ArgumentException lub typu pochodzącego od niego.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyFlipArgumentOrderCodeFixTitle">
        <source>Swap the arguments order</source>
        <target state="translated">Zamień kolejność argumentów</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">Metoda {0} przekazuje nazwę parametru „{1}” jako argument {2} do konstruktora {3}. Zastąp ten argument opisowym komunikatem i przekaż nazwę parametru na poprawnej pozycji.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">Metoda {0} przekazuje element „{1}” jako argument {2} do konstruktora {3}. Zastąp ten argument jedną z nazw parametrów metody. Zwróć uwagę na to, że podana nazwa parametru powinna mieć dokładnie taką samą pisownię jak deklaracja w metodzie.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter</source>
        <target state="translated">Wywołaj konstruktor {0}, który zawiera komunikat i/lub parametr paramName</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate argument exceptions correctly</source>
        <target state="translated">Utwórz poprawnie wystąpienia wyjątków argumentu</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationDescription">
        <source>Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise.</source>
        <target state="translated">Typy z atrybutem „DynamicInterfaceCastableImplementationAttribute” działają jako implementacja interfejsu dla typu, który implementuje typ „IDynamicInterfaceCastable”. W związku z tym musi dostarczać implementację wszystkich składowych zdefiniowanych w dziedziczonych interfejsach, ponieważ typ implementujący interfejs „IDynamicInterfaceCastable” nie udostępni ich w inny sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationMessage">
        <source>Type '{0}' has the 'DynamicInterfaceCastableImplementationAttribute' applied to it but does not provide an implementation of all interface members defined in inherited interfaces</source>
        <target state="translated">Typ „{0}” ma zastosowany atrybut „DynamicInterfaceCastableImplementationAttribute”, ale nie udostępnia implementacji wszystkich składowych interfejsu zdefiniowanych w dziedziczonych interfejsach</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationTitle">
        <source>All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface</source>
        <target state="translated">Wszystkie składowe zadeklarowane w interfejsach nadrzędnych muszą mieć implementację w interfejsie DynamicInterfaceCastableImplementation-attributed</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Ensure that the JavaScriptSerializer is initialized without a JavaScriptTypeResolver specified, or initialized with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">Metoda „{0}” nie jest bezpieczna podczas deserializacji niezaufanych danych za pomocą klasy JavaScriptSerializer zainicjowanej z klasą SimpleTypeResolver. Upewnij się, że klasa JavaScriptSerializer jest inicjowana bez określonej klasy JavaScriptTypeResolver lub inicjowana z klasą JavaScriptTypeResolver, która ogranicza typy obiektów w zdeserializowanym grafie obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverTitle">
        <source>Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</source>
        <target state="translated">Upewnij się, że klasa JavaScriptSerializer nie jest zainicjowana za pomocą klasy z SimpleTypeResolver przed wykonaniem deserializacji</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Initialize JavaScriptSerializer without a JavaScriptTypeResolver specified, or initialize with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">Metoda „{0}” nie jest bezpieczna podczas deserializacji niezaufanych danych za pomocą klasy JavaScriptSerializer zainicjowanej z klasą SimpleTypeResolver. Zainicjuj klasę JavaScriptSerializer bez określonej klasy JavaScriptTypeResolver lub zainicjuj ją z klasą JavaScriptTypeResolver, która ogranicza typy obiektów w zzdeserializowanym grafie obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverTitle">
        <source>Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</source>
        <target state="translated">Nie wykonuj deserializacji za pomocą klasy JavaScriptSerializer używającej klasy SimpleTypeResolver</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">Podczas deserializacji niezaufanych danych wejściowych zezwolenie na deserializację dowolnych typów jest mało bezpieczne. W przypadku deserializacji typu JsonSerializer użyj wartości TypeNameHandling.None lub, w przypadku wartości innych niż None, użyj elementu SerializationBinder w celu ograniczenia typów deserializowanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerTitle">
        <source>Do not deserialize with JsonSerializer using an insecure configuration</source>
        <target state="translated">Nie wykonuj deserializacji typu JsonSerializer przy użyciu niezabezpieczonej konfiguracji</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">Podczas deserializacji niezaufanych danych wejściowych zezwolenie na deserializację dowolnych typów jest mało bezpieczne. W przypadku korzystania z klasy JsonSerializerSettings użyj wartości TypeNameHandling.None lub, w przypadku wartości innych niż None, użyj elementu SerializationBinder w celu ograniczenia typów deserializowanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsTitle">
        <source>Do not use insecure JsonSerializerSettings</source>
        <target state="translated">Nie używaj niezabezpieczonej klasy JsonSerializerSettings</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">Podczas deserializacji niezaufanych danych wejściowych zezwolenie na deserializację dowolnych typów jest mało bezpieczne. W przypadku deserializacji typu JsonSerializer użyj wartości TypeNameHandling.None lub, w przypadku wartości innych niż None, użyj elementu SerializationBinder w celu ograniczenia typów deserializowanych.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerTitle">
        <source>Ensure that JsonSerializer has a secure configuration when deserializing</source>
        <target state="translated">Upewnij się, że element JsonSerializer ma bezpieczną konfigurację podczas deserializacji</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, ensure TypeNameHandling.None is specified, or for values other than None, ensure a SerializationBinder is specified to restrict deserialized types.</source>
        <target state="translated">Podczas deserializacji niezaufanych danych wejściowych zezwolenie na deserializację dowolnych typów jest niezabezpieczone. W przypadku korzystania z klasy JsonSerializerSettings upewnij się, że określono wartość TypeNameHandling.None lub, w przypadku wartości innych niż None, upewnij się, że określono element SerializationBinder, aby ograniczyć typy deserializowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsTitle">
        <source>Ensure that JsonSerializerSettings are secure</source>
        <target state="translated">Upewnij się, że klasa JsonSerializerSettings jest zabezpieczona</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingDescription">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.  If you need to instead detect Json.NET deserialization when a SerializationBinder isn't specified, then disable rule CA2326, and enable rules CA2327, CA2328, CA2329, and CA2330.</source>
        <target state="translated">Deserializacja danych JSON, gdy używana jest wartość TypeNameHandling inna niż None, może być niebezpieczna. Jeśli zamiast tego potrzebujesz wykrywać deserializację Json.NET, gdy nie jest określona wartość SerializationBinder, wyłącz regułę CA2326 i włącz reguły CA2327, CA2328, CA2329 i CA2330.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingMessage">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.</source>
        <target state="translated">Deserializacja danych JSON, gdy używana jest wartość TypeNameHandling inna niż None, może być niebezpieczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingTitle">
        <source>Do not use TypeNameHandling values other than None</source>
        <target state="translated">Nie używaj wartości TypeNameHandling innych niż None</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializacji niezaufanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer LosFormatter</source>
        <target state="translated">Nie używaj niezabezpieczonego deserializatora LosFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMethodDeclaredOnImplementationTypeStatic">
        <source>Convert to static method</source>
        <target state="translated">Konwertuj na metodę statyczną</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMethodDeclaredOnImplementationTypeStaticMayProduceInvalidCode">
        <source>Converting an instance method to a static method may produce invalid code</source>
        <target state="translated">Konwertowanie metody wystąpienia na metodę statyczną może spowodować wygenerowanie nieprawidłowego kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeParameterlessConstructorPublic">
        <source>Make the constructor that takes zero parameters 'public'</source>
        <target state="translated">Ustaw konstruktora publicznego, który przyjmuje zero parametrów jako „publiczny”</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">Wystąpienie pola typu, którego nie można serializować, jest zadeklarowane w typie, który można serializować.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">Pole {0} jest składową typu {1}, który można serializować, ale jest typu {2}, którego nie można serializować</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">Oznacz wszystkie pola nieprzeznaczone do serializacji</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageDescription">
        <source>The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set.</source>
        <target state="translated">Atrybut NeutralResourcesLanguage informuje obiekt ResourceManager o języku, którego użyto do wyświetlenia zasobów kultury neutralnej dla zestawu. Podwyższa to wydajność wyszukiwania pierwszego ładowanego zasobu i umożliwia zmniejszenie zestawu roboczego.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageMessage">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">Oznacz zestawy atrybutem NeutralResourcesLanguageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageTitle">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">Oznacz zestawy atrybutem NeutralResourcesLanguageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">Typ danych boolean ma wiele reprezentacji w kodzie niezarządzanym.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Dodaj atrybut MarshalAsAttribute do parametru {0} elementu P/Invoke {1}. Jeśli odpowiadającym parametrem niezarządzanym jest 4-bajtowy typ BOOL środowiska Win32, użyj wartości [MarshalAs(UnmanagedType.Bool)]. W przypadku 1-bajtowego typu bool języka C++ użyj wartości MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Dodaj atrybut MarshalAsAttribute do typu zwracanego elementu P/Invoke {0}. Jeśli odpowiadającym niezarządzanym typem zwracanym jest 4-bajtowy typ BOOL środowiska Win32, użyj wartości [MarshalAs(UnmanagedType.Bool)]. W przypadku 1-bajtowego typu bool języka C++ użyj wartości MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">Oznacz argumenty typu boolean elementu PInvoke argumentem MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">Aby typy mogły zostać rozpoznane przez środowiska uruchomieniowe w trakcie wykonania jako możliwe do serializacji, muszą być oznaczone atrybutem SerializableAttribute, nawet gdy typ używa niestandardowej procedury serializacji przez implementację interfejsu ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">Dodaj atrybut [Serializable] do typu {0}, ponieważ ten typ implementuje interfejs ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">Oznacz typy ISerializable atrybutem serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheck">
        <source>Ensure HttpClient certificate revocation list check is not disabled</source>
        <target state="translated">Upewnij się, że sprawdzenie listy odwołań certyfikatów programu HttpClient nie jest wyłączone</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheckMessage">
        <source>HttpClient may be created without enabling CheckCertificateRevocationList</source>
        <target state="translated">Program HttpClient może zostać utworzony bez włączania właściwości CheckCertificateRevocationList</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="translated">Upewnij się, że certyfikaty nie są dodawane do magazynu głównego</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="translated">Dodawanie certyfikatów do zaufanych certyfikatów głównych systemu operacyjnego nie jest bezpieczne. Upewnij się, że magazyn docelowy nie jest magazynem głównym.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIV">
        <source>Use CreateEncryptor with the default IV</source>
        <target state="translated">Użyj metody CreateEncryptor z domyślnym wektorem inicjowania</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIVMessage">
        <source>The non-default initialization vector, which can be potentially repeatable, is used in the encryption. Ensure use the default one.</source>
        <target state="translated">W szyfrowaniu jest używany wektor inicjowania inny niż domyślny, który może być powtarzalny. Upewnij się, że używasz domyślnego wektora inicjowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">Upewnij się, że używasz bezpiecznych plików cookie na platformie ASP.NET Core</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">Upewnij się, że podczas ustawiania pliku cookie wartość CookieOptions.Secure = true</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCount">
        <source>Ensure Sufficient Iteration Count When Using Weak Key Derivation Function</source>
        <target state="translated">Używając funkcji wyprowadzania klucza słabego, upewnij się, że istnieje wystarczająca liczba iteracji</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCountMessage">
        <source>Ensure that the iteration count is at least {0} when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">Wyprowadzając klucz kryptograficzny z hasła, upewnij się, że liczba iteracji to co najmniej {0}. Domyślnie wartość IterationCount dla klasy Rfc2898DeriveByte to tylko 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticDescription">
        <source>Since a type that implements 'IDynamicInterfaceCastable' may not implement a dynamic interface in metadata, calls to an instance interface member that is not an explicit implementation defined on this type are likely to fail at runtime. Mark new interface members 'static' to avoid runtime errors.</source>
        <target state="translated">Ponieważ typ implementujący interfejs „IDynamicInterfaceCastable” może nie implementować interfejsu dynamicznego w metadanych, wywołania do składowej interfejsu wystąpienia, który nie jest jawną implementacją zdefiniowaną w tym typie, mogą zakończyć się niepowodzeniem w czasie wykonywania. Oznacz nowe składowe interfejsu jako „statyczne”, aby uniknąć błędów środowiska uruchomieniowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticMessage">
        <source>The '{0}' member on the '{1}' type should be marked 'static' as '{1}' has the 'DynamicInterfaceImplementationAttribute' applied</source>
        <target state="translated">Składowa „{0}” w typie „{1}” powinna być oznaczony jako „statyczny”, ponieważ element „{1}” ma zastosowany atrybut „DynamicInterfaceImplementationAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticTitle">
        <source>Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'static'</source>
        <target state="translated">Składowe zdefiniowane w interfejsie z atrybutem „DynamicInterfaceCastableImplementationAttribute” powinny mieć wartość „statyczne”</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodReturnsPreviewTypeMessage">
        <source>'{0}' returns the preview type '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">„{0}” zwraca typ w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodReturnsPreviewTypeMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' returns the preview type '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} „{0}” zwraca typ w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesPreviewTypeAsParameterMessage">
        <source>'{0}' takes in a preview parameter of type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">„{0}” przyjmuje parametr w wersji zapoznawczej typu „{1}” i wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesPreviewTypeAsParameterMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' takes in a preview parameter of type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} „{0}” przyjmuje parametr w wersji zapoznawczej typu „{1}” i wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledDescription">
        <source>This method uses runtime marshalling even when runtime marshalling is disabled, which can cause unexpected behavior differences at runtime due to different expectations of a type's native layout.</source>
        <target state="translated">Ta metoda używa kierowania środowiska uruchomieniowego nawet wtedy, gdy kierowanie środowiska uruchomieniowego jest wyłączone, co może powodować nieoczekiwane różnice w zachowaniu środowiska uruchomieniowego ze względu na różne oczekiwania dotyczące układu natywnego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledMessage">
        <source>'{0}' uses runtime marshalling even when 'DisableRuntimeMarshallingAttribute' is applied. Use features like 'sizeof' and pointers directly to ensure accurate results.</source>
        <target state="translated">Element „{0}“ używa kierowania środowiska uruchomieniowego nawet wtedy, gdy jest zastosowany atrybut „DisableRuntimeMarsbezpieczeńingAttribute“. Użyj bezpośrednio funkcji, takich jak „sizeof“ i wskaźników, aby zapewnić dokładne wyniki.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledTitle">
        <source>This method uses runtime marshalling even when the 'DisableRuntimeMarshallingAttribute' is applied</source>
        <target state="translated">Ta metoda używa kierowania środowiska uruchomieniowego nawet wtedy, gdy jest stosowany atrybut „DisableRuntimeMarsbezpieczeńingAttribute“</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttribute">
        <source>Miss HttpVerb attribute for action methods</source>
        <target state="translated">Pomiń atrybut HttpVerb dla metod akcji</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeDescription">
        <source>All the methods that create, edit, delete, or otherwise modify data do so in the [HttpPost] overload of the method, which needs to be protected with the anti forgery attribute from request forgery. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</source>
        <target state="translated">Wszystkie metody, które tworzą, edytują, usuwają lub w inny sposób modyfikują dane, dokonują tego w przeciążeniu [HttpPost] metody, która musi być chroniona przy użyciu atrybutu zabezpieczającego przed fałszerstwem przez sfałszowanie żądania. Wykonanie operacji GET powinno być bezpieczną operacją, która nie ma żadnych efektów ubocznych i nie powoduje modyfikacji utrwalonych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeMessage">
        <source>Action method {0} needs to specify the HTTP request kind explicitly</source>
        <target state="translated">Metoda akcji {0} musi jawnie określać rodzaj żądania HTTP</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesDescription">
        <source>Module initializers are intended to be used by application code to ensure an application's components are initialized before the application code begins executing. If library code declares a method with the 'ModuleInitializerAttribute', it can interfere with application initialization and also lead to limitations in that application's trimming abilities. Instead of using methods marked with 'ModuleInitializerAttribute', the library should expose methods that can be used to initialize any components within the library and allow the application to invoke the method during application initialization.</source>
        <target state="translated">Inicjatory modułów są przeznaczone do użycia przez kod aplikacji w celu zapewnienia, że składniki aplikacji zostaną zainicjowane przed rozpoczęciem wykonywania kodu aplikacji. Jeśli kod biblioteki deklaruje metodę za pomocą atrybutu „ModuleInitializer”, może zakłócać inicjowanie aplikacji, a także prowadzić do ograniczeń w możliwościach przycinania tej aplikacji. Zamiast używać metod oznaczonych atrybutem „ModuleInitializer”, biblioteka powinna uwidaczniać metody, których można użyć do zainicjowania składników w bibliotece i umożliwienia aplikacji wywołania metody podczas inicjowania aplikacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesMessage">
        <source>The 'ModuleInitializer' attribute is only intended to be used in application code or advanced source generator scenarios</source>
        <target state="translated">Atrybut „ModuleInitializer” jest przeznaczony tylko do użycia w kodzie aplikacji lub w zaawansowanych scenariuszach generatora źródła</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesTitle">
        <source>The 'ModuleInitializer' attribute should not be used in libraries</source>
        <target state="translated">Atrybut „ModuleInitializer” nie powinien być używany w bibliotekach</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">Metoda „{0}” nie jest bezpieczna podczas deserializowania niezaufanych danych bez użycia elementu SerializationBinder w celu ograniczenia typu obiektów w zdeserializowanym grafie obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure NetDataContractSerializer.Binder is set before deserializing</source>
        <target state="translated">Upewnij się, że właściwość NetDataContractSerializer.Binder jest ustawiona przed deserializacją</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">Metoda „{0}” nie jest bezpieczna podczas deserializowania niezaufanych danych bez użycia elementu SerializationBinder w celu ograniczenia typu obiektów w zdeserializowanym grafie obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetTitle">
        <source>Do not deserialize without first setting NetDataContractSerializer.Binder</source>
        <target state="translated">Nie wykonuj deserializacji bez uprzedniego ustawienia właściwości NetDataContractSerializer.Binder</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect NetDataContractSerializer deserialization without a SerializationBinder set, then disable rule CA2310, and enable rules CA2311 and CA2312.</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializowania niezaufanych danych. Aby zamiast tego wykryć deserializację klasy NetDataContractSerializer bez ustawionego elementu SerializationBinder, wyłącz regułę CA2310 i włącz reguły CA2311 i CA2312.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializacji niezaufanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedTitle">
        <source>Do not use insecure deserializer NetDataContractSerializer</source>
        <target state="translated">Nie używaj niezabezpieczonego deserializatora NetDataContractSerializer</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">Ciągi powinny być znormalizowane do wielkich liter. Nie można wykonać dwustronnej konwersji dla małej grupy znaków podczas konwertowania na małe litery. Wykonanie dwustronnej konwersji oznacza tutaj przekonwertowanie znaków z jednych ustawień regionalnych na inne, które reprezentują dane w inny sposób, a następnie dokładne pobranie oryginalnych znaków z przekonwertowanych znaków.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'</source>
        <target state="translated">W metodzie „{0}” zastąp wywołanie metody „{1}” wywołaniem „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">Znormalizuj ciągi do wielkich liter</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">Metoda „{0}” jest niezabezpieczona podczas deserializacji niezaufanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer ObjectStateFormatter</source>
        <target state="translated">Nie używaj niezabezpieczonego deserializatora ObjectStateFormatter</target>
        <note />
      </trans-unit>
      <trans-unit id="OverridesPreviewMethodMessage">
        <source>'{0}' overrides the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">„{0}” przesłania metodę w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverridesPreviewMethodMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' overrides the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} „{0}” przesłania metodę w wersji zapoznawczej „{1}” i dlatego wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">Metoda publiczna lub chroniona w typie publicznym ma atrybut System.Runtime.InteropServices.DllImportAttribute (implementowany również przez słowo kluczowe Declare w języku Visual Basic). Takie metody nie powinny być ujawniane.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">Metoda P/Invoke {0} nie powinna być widoczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">Elementy P/Invoke nie powinny być widoczne</target>
        <note />
      </trans-unit>
      <trans-unit id="ParenthesisWithPlaceHolder">
        <source> ({0})</source>
        <target state="translated"> ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllPlatforms">
        <source>and all other platforms</source>
        <target state="translated">i wszystkie inne platformy</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and later, and all other platforms</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllVersions">
        <source>'{0}' all versions</source>
        <target state="translated">wszystkie wersje systemu „{0}”</target>
        <note>This call site is reachable on: 'Windows' all versions.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityDescription">
        <source>Using platform dependent API on a component makes the code no longer work across all platforms.</source>
        <target state="translated">Użycie w składniku interfejsu API zależnego od platformy powoduje, że kod nie działa na różnych platformach.</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityFromVersionToVersion">
        <source>'{0}' from version {1} to {2}</source>
        <target state="translated">system „{0}” w wersji od {1} do {2}</target>
        <note>'SupportedOnWindows1903UnsupportedOn2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityObsoletedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is obsoleted on: {1}.</source>
        <target state="translated">To miejsce wywołania jest osiągalne na wszystkich platformach. „{0}” jest przestarzałe na: {1}.</target>
        <note>This call site is reachable on all platforms. 'OboletedOnMacOS()' is obsoleted on: 'macos'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityObsoletedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is obsoleted on: {1}.</source>
        <target state="translated">To miejsce wywołania jest osiągalne na platformie: {2}. „{0}” jest przestarzałe na następujących platformach: {1}.</target>
        <note>This call site is reachable on 'macos', 'linux'. 'OboletedOnMacOS()' is obsoleted on: 'macos'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is only supported on: {1}.</source>
        <target state="translated">To miejsce wywołania jest osiągalne na wszystkich platformach. Metoda „{0}” jest obsługiwana tylko na następujących platformach: {1}.</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindowsAndBrowser()' is only supported on: 'windows', 'browser' .</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">To miejsce wywołania jest osiągalne na platformie: {2}. Metoda „{0}” jest obsługiwana tylko na następujących platformach: {1}.</target>
        <note>This call site is reachable on: 'windows' all versions.'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsUnreachableMessage">
        <source>This call site is unreachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">To miejsce wywołania jest nieosiągalne na platformie: {2}. Metoda „{0}” jest obsługiwana tylko na następujących platformach: {1}.</target>
        <note>This call site is unreachable on: 'browser'. 'SupportedOnWindowsAndBrowser()' is only supported on: 'browser', 'windows'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is supported on: {1}.</source>
        <target state="translated">To miejsce wywołania jest osiągalne na wszystkich platformach. Metoda „{0}” jest obsługiwana na następujących platformach: {1}.</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindows1903UnsupportedFrom2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is supported on: {1}.</source>
        <target state="translated">To miejsce wywołania jest osiągalne na platformie: {2}. Metoda „{0}” jest obsługiwana na następujących platformach: {1}.</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and before. 'UnsupportedOnWindowsSupportedOn1903()' is supported on: 'windows' 10.0.1903 and later.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityTitle">
        <source>Validate platform compatibility</source>
        <target state="translated">Walidacja zgodności z platformą</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is unsupported on: {1}.</source>
        <target state="translated">To miejsce wywołania jest osiągalne na wszystkich platformach. Metoda „{0}” nie jest obsługiwana na następujących platformach: {1}.</target>
        <note>This call site is reachable on all platforms. 'UnsupportedOnWindows()' is unsupported on: 'windows'</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is unsupported on: {1}.</source>
        <target state="translated">To miejsce wywołania jest osiągalne na platformie: {2}. Metoda „{0}” nie jest obsługiwana na następujących platformach: {1}.</target>
        <note>This call site is reachable on: 'windows', 'browser'. 'UnsupportedOnBrowser()' is unsupported on: 'browser'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndBefore">
        <source>'{0}' {1} and before</source>
        <target state="translated">system „{0}” w wersji {1} lub wcześniejszej</target>
        <note>'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndLater">
        <source>'{0}' {1} and later</source>
        <target state="translated">system „{0}” w wersji {1} lub nowszej</target>
        <note>'SupportedOnWindows10()' is only supported on: 'windows' 10.0 and later.</note>
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphDescription">
        <source>Review code that processes untrusted deserialized data for handling of unexpected reference cycles. An unexpected reference cycle should not cause the code to enter an infinite loop. Otherwise, an unexpected reference cycle can allow an attacker to DOS or exhaust the memory of the process when deserializing untrusted data.</source>
        <target state="translated">Przejrzyj kod, który przetwarza zdeserializowane niezaufane dane, pod kątem obsługi nieoczekiwanych cykli odwołań. Nieoczekiwany cykl odwołań nie powinien powodować wejścia kodu w nieskończoną pętlę. W przeciwnym razie nieoczekiwany cykl odwołań może pozwolić osobie atakującej na przeprowadzenie ataku DoS lub wyczerpanie pamięci procesu podczas deserializacji niezaufanych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">Element {0} należy do potencjalnego cyklu odwołań</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphTitle">
        <source>Potential reference cycle in deserialized object graph</source>
        <target state="translated">Potencjalny cykl odwołań w deserializowanym grafie obiektów</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringCodefixTitle">
        <source>Replace 'Substring' with 'AsSpan'</source>
        <target state="translated">Zamień ciąg „Substring” na „AsSpan”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringDescription">
        <source>'AsSpan' is more efficient than 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost.</source>
        <target state="translated">Ciąg „AsSpan” jest bardziej wydajny niż ciąg „Substring”. Ciąg „Substring” wykonuje kopię ciągu O(n), natomiast ciąg „AsSpan” nie wykonuje i ponadto ma stały koszt.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringMessage">
        <source>Prefer 'AsSpan' over 'Substring' when span-based overloads are available</source>
        <target state="translated">Preferuj ciąg „AsSpan” niż „Substring”, gdy są dostępne przeciążenia oparte na zakresie</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringTitle">
        <source>Prefer 'AsSpan' over 'Substring'</source>
        <target state="translated">Preferuj ciąg „AsSpan” niż „Substring”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderDescription">
        <source>'StringBuilder.Append(char)' is more efficient than 'StringBuilder.Append(string)' when the string is a single character. When calling 'Append' with a constant, prefer using a constant char rather than a constant string containing one character.</source>
        <target state="translated">Element „StringBuilder.Append(char)” jest bardziej wydajny niż element „StringBuilder.Append(string)”, gdy ciąg jest pojedynczym znakiem. W przypadku wywołania elementu „Append” ze stałą, preferuj użycie stałego znaku, a nie ciągu stałego zawierającego jeden znak.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderMessage">
        <source>Use 'StringBuilder.Append(char)' instead of 'StringBuilder.Append(string)' when the input is a constant unit string</source>
        <target state="translated">Użyj metody „StringBuilder.Append(char)” zamiast metody „StringBuilder.Append(string)”, gdy dane wejściowe są stałym ciągiem jednostki</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderTitle">
        <source>Consider using 'StringBuilder.Append(char)' when applicable</source>
        <target state="translated">Rozważ użycie elementu „StringBuilder.Append(char)”, jeśli ma to zastosowanie</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterCodeFixTitle">
        <source>Replace with 'Convert.{0}'</source>
        <target state="translated">Zamień na „Konwertuj.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterDescription">
        <source>Use 'Convert.ToHexString' or 'Convert.ToHexStringLower' when encoding bytes to a hexadecimal string representation. These methods are more efficient and allocation-friendly than using 'BitConverter.ToString' in combination with 'String.Replace' to replace dashes and 'String.ToLower'.</source>
        <target state="translated">Użyj wartości „Convert.ToHexString” lub „Convert.ToHexStringLower” podczas kodowania bajtów do reprezentacji ciągu szesnastkowego. Te metody są bardziej wydajne i przyjazne dla alokacji niż użycie elementu „BitConverter.ToString” w połączeniu z elementem „String.Replace” w celu zastąpienia łączników i ciągu „String.ToLower”.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterMessage">
        <source>Prefer '{0}' over call chains based on '{1}'</source>
        <target state="translated">Preferuj element „{0}” niż łańcuchy wywołań oparte na „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterTitle">
        <source>Prefer 'Convert.ToHexString' and 'Convert.ToHexStringLower' over call chains based on 'BitConverter.ToString'</source>
        <target state="translated">Preferuj wartości „Convert.ToHexString” i „Convert.ToHexStringLower” w stosunku do łańcuchów wywołań opartych na elemencie „BitConverter.ToString”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferCountOverAnyCodeFixTitle">
        <source>Use 'Count' check instead of 'Any()'</source>
        <target state="translated">Użyj sprawdzania „Count” zamiast „Any()”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferCountOverAnyMessage">
        <source>Prefer comparing 'Count' to 0 rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">Preferuj porównywanie wartości „Count” z wartością 0 zamiast użycia elementu „Any()”, zarówno w celu zapewnienia jednoznaczności, jak i wydajności</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyCodeFixTitle">
        <source>Use 'ContainsKey'</source>
        <target state="translated">Użyj elementu „ContainsKey”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyDescription">
        <source>'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations.</source>
        <target state="translated">Element „ContainsKey” ma zazwyczaj wartość O(1), a element „Keys.Contains” może w niektórych przypadkach mieć wartość O(n). Ponadto wiele implementacji słownika bardzo wolno inicjuje kolekcję kluczy, aby ograniczyć alokacje.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyMessage">
        <source>Prefer 'ContainsKey' over 'Keys.Contains' for dictionary type '{0}'</source>
        <target state="translated">Preferuj element „ContainsKey” niż „Keys.Contains” dla typu słownika „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsMethodsTitle">
        <source>Prefer Dictionary.Contains methods</source>
        <target state="translated">Preferuj metody Dictionary.Contains</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueCodeFixTitle">
        <source>Use 'ContainsValue'</source>
        <target state="translated">Użyj wartości „ContainsValue”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueDescription">
        <source>Many dictionary implementations lazily initialize the Values collection. To avoid unnecessary allocations, prefer 'ContainsValue' over 'Values.Contains'.</source>
        <target state="translated">Wiele implementacji słowników bardzo wolno inicjalizuje kolekcję Values. Aby uniknąć niepotrzebnych alokacji, preferuj wartość „ContainsValue” zamiast wartości „Values.Contains”.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueMessage">
        <source>Prefer 'ContainsValue' over 'Values.Contains' for dictionary type '{0}'</source>
        <target state="translated">Preferuj wartość „ContainsValue” niż wartość „Values.Contains” dla typu słownika „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddDescription">
        <source>Prefer a 'TryAdd' call over an 'Add' call guarded by a 'ContainsKey' check. 'TryAdd' behaves the same as 'Add', except that when the specified key already exists, it returns 'false' instead of throwing an exception.</source>
        <target state="translated">Preferuj wywołanie „TryAdd” zamiast wywołania „Add” chronionego przez sprawdzenie „ContainsKey”. Element „TryAdd” zachowuje się tak samo jak element „Add”, ale jeśli określony klucz już istnieje, zwraca wartość „false” zamiast zgłaszania wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddMessage">
        <source>To avoid double lookup, call 'TryAdd' instead of calling 'Add' with a 'ContainsKey' guard</source>
        <target state="translated">Aby uniknąć podwójnego wyszukiwania, wywołaj metodę „TryAdd” zamiast wywoływać metodę „Add” z funkcją „ContainsKey”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddTitle">
        <source>Prefer the 'IDictionary.TryAdd(TKey, TValue)' method</source>
        <target state="translated">Preferuj metodę „IDictionary.TryAdd(TKey, TValue)”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddValueCodeFixTitle">
        <source>Use 'TryAdd(TKey, TValue)'</source>
        <target state="translated">Użyj polecenia „TryAdd(TKey, TValue)”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueCodeFixTitle">
        <source>Use 'TryGetValue(TKey, out TValue)'</source>
        <target state="translated">Użyj polecenia „TryGetValue(TKey, out TValue)”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueDescription">
        <source>Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check. 'ContainsKey' and the indexer both would lookup the key under the hood, so using 'TryGetValue' removes the extra lookup.</source>
        <target state="translated">Preferuj wywołanie „TryGetValue” względem dostępu indeksatora słownika chronionego przez kontrolę „ContainsKey”. Element „ContainsKey” i indeksator wyszukają klucz pod maską, więc użycie polecenia „TryGetValue” spowoduje usunięcie dodatkowego wyszukiwania.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueMessage">
        <source>Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check to avoid double lookup</source>
        <target state="translated">Preferuj wywołanie „TryGetValue” względem dostępu indeksatora słownika chronionego przez kontrolę „ContainsKey”, aby uniknąć podwójnego wyszukiwania</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueTitle">
        <source>Prefer the 'IDictionary.TryGetValue(TKey, out TValue)' method</source>
        <target state="translated">Preferuj metodę „IDictionary.TryGetValue(TKey, out TValue)”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsCodeFixTitle">
        <source>Use generic overload</source>
        <target state="translated">Użyj ogólnego przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsDescription">
        <source>Using a generic overload is preferable to the 'System.Type' overload when the type is known, promoting cleaner and more type-safe code with improved compile-time checks.</source>
        <target state="translated">Użycie ogólnego przeciążenia jest lepsze niż przeciążenie „System.Type”, gdy typ jest znany, promując czystszy i bardziej bezpieczny kod z ulepszonymi kontrolami czasu kompilacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsMessage">
        <source>Prefer the generic overload '{0}' instead of '{1}'</source>
        <target state="translated">Preferuj ogólne przeciążenie „{0}” zamiast „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsTitle">
        <source>Prefer generic overload when type is known</source>
        <target state="translated">Preferuj ogólne przeciążenie, gdy typ jest znany</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataCodefixTitle">
        <source>Replace with 'HashData' method</source>
        <target state="translated">Zamień na metodę „HashData”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerDescription">
        <source>It is more efficient to use the static 'HashData' method over creating and managing a HashAlgorithm instance to call 'ComputeHash'.</source>
        <target state="translated">Korzystanie z metody statycznej „HashData” jest wydajniejsze niż tworzenie wystąpienia HashAlgorithm i zarządzanie nim w celu wywołania „ComputeHash”.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerMessage">
        <source>Prefer static '{0}.HashData' method over 'ComputeHash'</source>
        <target state="translated">Preferuj metodę statyczną „{0}.HashData”, nie „ComputeHash”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerTitle">
        <source>Prefer static 'HashData' method over 'ComputeHash'</source>
        <target state="translated">Preferuj metodę statyczną „HashData”, nie „ComputeHash”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverAnyCodeFixTitle">
        <source>Use 'IsEmpty' check instead of 'Any()'</source>
        <target state="translated">Użyj sprawdzania „IsEmpty” zamiast „Any()”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverAnyMessage">
        <source>Prefer an 'IsEmpty' check rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">Preferuj kontrolę „IsEmpty”, a nie „Any()”, zarówno w celu zapewnienia przejrzystości, jak i wydajności</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountDescription">
        <source>For determining whether the object contains or not any items, prefer using 'IsEmpty' property rather than retrieving the number of items from the 'Count' property and comparing it to 0 or 1.</source>
        <target state="translated">Aby określić, czy obiekt zawiera jakiekolwiek elementy, stosuj właściwość „IsEmpty” zamiast pobierać liczbę elementów z właściwości „Count” i porównywać ją z wartością 0 lub 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountMessage">
        <source>Prefer 'IsEmpty' over 'Count' to determine whether the object is empty</source>
        <target state="translated">Preferuj właściwość „IsEmpty” przed właściwością „Count” do określania, czy obiekt jest pusty</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountTitle">
        <source>Prefer IsEmpty over Count</source>
        <target state="translated">Preferuj właściwość IsEmpty przed Count</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthCountIsEmptyOverAnyDescription">
        <source>Prefer using 'IsEmpty', 'Count' or 'Length' properties whichever available, rather than calling 'Enumerable.Any()'. The intent is clearer and it is more performant than using 'Enumerable.Any()' extension method.</source>
        <target state="translated">Preferuj używanie właściwości „IsEmpty”, „Count” lub „Length” w zależności od dostępności, zamiast wywoływać metodę „Enumerable.Any()”. Intencja jest bardziej przejrzysta i wydajniejsza niż użycie metody rozszerzenia „Enumerable.Any()”.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthCountIsEmptyOverAnyTitle">
        <source>Avoid using 'Enumerable.Any()' extension method</source>
        <target state="translated">Unikaj używania metody rozszerzenia „Enumerable.Any()”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthOverAnyCodeFixTitle">
        <source>Use 'Length' check instead of 'Any()'</source>
        <target state="translated">Użyj sprawdzania „Length” zamiast „Any()”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthOverAnyMessage">
        <source>Prefer comparing 'Length' to 0 rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">Preferuj porównywanie wartości „Length” z wartością 0 zamiast używania elementu „Any()”, zarówno w celu zapewnienia przejrzystości, jak i wydajności</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsDescription">
        <source>'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument. Prefer calling the memory based overloads, which are more efficient.</source>
        <target state="translated">Element „Stream” ma przeciążenie „ReadAsync”, które przyjmuje „Memory&lt;Byte&gt;” jako pierwszy argument i przeciążenie „WriteAsync”, które przyjmuje „ReadOnlyMemory&lt;Byte&gt;” jako pierwszy argument. Preferuj wywoływanie przeciążeń opartych na pamięci, co jest bardziej wydajne.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsMessage">
        <source>Change the '{0}' method call to use the '{1}' overload</source>
        <target state="translated">Zmień wywołanie metody „{0}” tak, aby używało przeciążenia „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsTitle">
        <source>Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</source>
        <target state="translated">Preferuj „przeciążanie oparte na elemencie „Memory” dla elementów „ReadAsync” i „WriteAsync”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfCodeFixTitle">
        <source>Replace with 'string.Contains'</source>
        <target state="translated">Zamień na „string.Contains”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfDescription">
        <source>Calls to 'string.IndexOf' where the result is used to check for the presence/absence of a substring can be replaced by 'string.Contains'.</source>
        <target state="translated">Wywołania elementu „string.IndexOf”, w przypadku których wynik jest używany do sprawdzania obecności/nieobecności podciągu, mogą zostać zastąpione przez wyrażenie „string.Contains”.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfMessage">
        <source>Use 'string.Contains' instead of 'string.IndexOf' to improve readability</source>
        <target state="translated">Używaj metody „string.Contains” zamiast metody „string.IndexOf”, aby zwiększyć czytelność</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfTitle">
        <source>Consider using 'string.Contains' instead of 'string.IndexOf'</source>
        <target state="translated">Rozważ użycie metody „string.Contains” zamiast „string.IndexOf”</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsDescription">
        <source>StringBuilder.Append and StringBuilder.Insert provide overloads for multiple types beyond System.String.  When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</source>
        <target state="translated">Metody StringBuilder.Append i StringBuilder.Insert zapewniają przeciążenia dla wielu typów oprócz typu System.String. Jeśli to możliwe, preferuj silnie typizowane przeciążenia zamiast używania metody ToString() i przeciążenia opartego na ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsMessage">
        <source>Remove the ToString call in order to use a strongly-typed StringBuilder overload</source>
        <target state="translated">Usuń wywołanie metody ToString, aby użyć silnie typizowanego przeciążenia elementu StringBuilder</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsRemoveToString">
        <source>Remove the ToString call</source>
        <target state="translated">Usuń wywołanie metody ToString</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsTitle">
        <source>Prefer strongly-typed Append and Insert method overloads on StringBuilder</source>
        <target state="translated">Preferuj silnie typizowane metody Append i Insert w elemencie StringBuilder</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesConversionNotThrowMessage">
        <source>Starting with .NET 7 the explicit conversion '{0}' will not throw when overflowing in an unchecked context. Wrap the expression with a 'checked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">Począwszy od platformy .NET 7 jawna konwersja „{0}” nie będzie zgłaszać przepełnienia w niezaznaczonym kontekście. Opatrz wyrażenie za pomocą instrukcji „checked”, aby przywrócić zachowanie platformy .NET 6.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesConversionThrowsMessage">
        <source>Starting with .NET 7 the explicit conversion '{0}' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">Począwszy od platformy .NET 7 jawna konwersja „{0}” będzie zgłaszać przepełnienie w zaznaczonym kontekście. Opatrz wyrażenie za pomocą instrukcji „unchecked”, aby przywrócić zachowanie platformy .NET 6.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesDescription">
        <source>Some built-in operators added in .NET 7 behave differently when overflowing than did the corresponding user-defined operators in .NET 6 and earlier versions. Some operators that previously threw in an unchecked context now don't throw unless wrapped within a checked context. Also, some operators that did not previously throw in a checked context now throw unless wrapped in an unchecked context.</source>
        <target state="translated">Niektóre wbudowane operatory dodane w programie .NET 7 działają inaczej w przypadku przepełnienia niż odpowiednie operatory zdefiniowane przez użytkownika w programie .NET 6 i we wcześniejszych wersjach. Niektóre operatory, które wcześniej zgłosiły niezaznaczony kontekst, teraz ich nie zgłaszają, chyba że zostaną opakowane w zaznaczony kontekst. Ponadto niektóre operatory, które nie zgłosiły wcześniej zaznaczonego kontekstu, teraz zgłaszają wyjątek, chyba że jest zawinięty w niezaznaczony kontekst.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesOperatorThrowsMessage">
        <source>Starting with .NET 7 the operator '{0}' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">Począwszy od platformy .NET 7, operator „{0}” będzie zgłaszać przepełnienie w zaznaczonym kontekście. Opatrz wyrażenie za pomocą instrukcji „unchecked”, aby przywrócić zachowanie platformy .NET 6.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesTitle">
        <source>Prevent behavioral change</source>
        <target state="translated">Zapobiegaj zmianie zachowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagDescription">
        <source>'Enum.HasFlag' method expects the 'enum' argument to be of the same 'enum' type as the instance on which the method is invoked and that this 'enum' is marked with 'System.FlagsAttribute'. If these are different 'enum' types, an unhandled exception will be thrown at runtime. If the 'enum' type is not marked with 'System.FlagsAttribute' the call will always return 'false' at runtime.</source>
        <target state="translated">Metoda „Enum.HasFlag” oczekuje, że argument „enum” ma ten sam typ „enum” co wystąpienie, na którym wywołano metodę, i że ten element „enum” jest oznaczony elementem „System.FlagsAttribute”. Jeśli są to różne typy „enum”, w czasie wykonywania zostanie zgłoszony nieobsługiwany wyjątek. Jeśli typ „enum” nie jest oznaczony elementem „System.FlagsAttribute”, wywołanie będzie zawsze zwracać wartość „false” w czasie wykonywania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagMessageDifferentType">
        <source>The argument type, '{0}', must be the same as the enum type '{1}'</source>
        <target state="translated">Typ argumentu „{0}” musi być taki sam jak typ wyliczenia „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagTitle">
        <source>Provide correct 'enum' argument to 'Enum.HasFlag'</source>
        <target state="translated">Podaj poprawny argument „enum” dla elementu „Enum.HasFlag”</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">Argument formatu przekazywany do metody System.String.Format nie zawiera elementu formatu odpowiadającego każdemu argumentowi obiektu lub odwrotnie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsInvalidFormatMessage">
        <source>The format argument is not a valid format string</source>
        <target state="translated">Argument formatu nie jest prawidłowym ciągiem formatu</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Określ poprawne argumenty dla metod formatujących</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Określ poprawne argumenty dla metod formatujących</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyDescription">
        <source>The property 'MaxResponseHeadersLength' is measured in kilobytes, not in bytes. The provided value is multiplied by 1024, which might be greater than your intended maximum length.</source>
        <target state="translated">Właściwość „MaxResponseHeadersLength” jest mierzona w kilobajtach, a nie w bajtach. Podana wartość jest mnożona przez 1024, co może być wartością większą niż zamierzona maksymalna długość.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyMessage">
        <source>Make sure the value '{0}' is correct. This value is measured in kilobytes, not bytes.</source>
        <target state="translated">Upewnij się, że wartość „{0}” jest poprawna. Ta wartość jest mierzona w kilobajtach, a nie w bajtach.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyTitle">
        <source>Set 'MaxResponseHeadersLength' properly</source>
        <target state="translated">Ustaw poprawnie parametr „MaxResponseHeadersLength”</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorDescription">
        <source>Providing a parameterless constructor that is as visible as the containing type for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions.</source>
        <target state="translated">Udostępnienie konstruktora bez parametrów, który jest tak widoczny jak typ zawierający dla typu pochodzącego z elementu „System.Runtime.InteropServices.SafeHandle”, zapewnia lepszą wydajność i użycie dzięki wygenerowanym przez źródło rozwiązaniom międzyoperacyjnym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorMessage">
        <source>Provide a parameterless constructor that is as visible as the containing type for the '{0}' type that is derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="translated">Podaj konstruktora bez parametrów, który jest tak widoczny jak typ zawierający dla typu „{0}” pochodzącego z elementu „System.Runtime.InteropServices.SafeHandle”</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorTitle">
        <source>Provide a parameterless constructor that is as visible as the containing type for concrete types derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="translated">Podaj konstruktora bez parametrów, który jest tak widoczny jak typ zawierający dla konkretnych typów pochodzących z elementu „System.Runtime.InteropServices.SafeHandle”</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesDescription">
        <source>To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods.</source>
        <target state="translated">Aby zwiększyć wydajność, zastąp metody asynchroniczne oparte na pamięci podczas tworzenia podklasy „Stream”. Następnie zaimplementuj metody oparte na tablicy w zakresie metod opartych na pamięci.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesMessage">
        <source>'{0}' overrides array-based '{1}' but does not override memory-based '{2}'. Consider overriding memory-based '{2}' to improve performance.</source>
        <target state="translated">Metoda „{0}” przesłania metodę „{1}” opartą na tablicy, ale nie przesłania metody opartej na pamięci „{2}”. Rozważ zastąpienie metody opartej na pamięci „{2}”, aby zwiększyć wydajność.</target>
        <note>0 = type that subclasses Stream directly, 1 = array-based method, 2 = memory-based method</note>
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesTitle">
        <source>Provide memory-based overrides of async methods when subclassing 'Stream'</source>
        <target state="translated">Podaj oparte na pamięci przesłonięcia metod asynchronicznych podczas tworzenia podklasy „Stream”</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons when using 'CompareTo', because they lead to an allocation. Instead, use 'StringComparer' to perform case-insensitive comparisons. Switching to using 'StringComparer' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'.</source>
        <target state="translated">Unikaj wywoływania „ToLower”, „ToUpper”, „ToLowerInvariant” i „ToUpperInvariant” do wykonywania porównań ciągów bez uwzględniania wielkości liter podczas korzystania z „CompareTo”, ponieważ prowadzą one do alokacji. Zamiast tego użyj elementu „StringComparer”, aby wykonać porównania bez uwzględniania wielkości liter. Przełączenie się na używanie elementu „StringComparer” może spowodować subtelne zmiany w zachowaniu, dlatego ważne jest przeprowadzenie dokładnego testowania po zastosowaniu sugestii. Ponadto jeśli nie jest wymagane porównanie wrażliwe kulturowo, rozważ użycie metody „StringComparer.OrdinalIgnoreCase”.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerMessage">
        <source>Prefer using 'StringComparer' to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'</source>
        <target state="translated">Preferuj używanie elementu „StringComparer” do porównywania bez uwzględniania wielkości liter, ale pamiętaj, że może to spowodować subtelne zmiany w zachowaniu, więc upewnij się, że przeprowadzasz dokładne testy po zastosowaniu sugestii lub jeśli porównanie wrażliwe kulturowo nie jest wymagane, rozważ użycie „StringComparer.OrdinalIgnoreCase”.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerStringComparisonCodeFixTitle">
        <source>Use the 'string.{0}(string, StringComparison)' overload</source>
        <target state="translated">Użyj obciążenia „string.{0}(string, StringComparison)”</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons because they lead to an allocation. Instead, prefer calling the method overloads of 'Contains', 'IndexOf' and 'StartsWith' that take a 'StringComparison' enum value to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</source>
        <target state="translated">Unikaj wywoływania elementów „ToLower”, „ToUpper”, „ToLowerInvariant” i „ToUpperInvariant”, aby przeprowadzać porównania ciągów bez uwzględniania wielkości liter, ponieważ prowadzą do alokacji. Zamiast tego preferuj wywoływanie przeciążeń metod „Contains”, „IndexOf” i „StartsWith”, które przyjmują wartość wyliczenia „StringComparison”, aby wykonać porównania bez uwzględniania wielkości liter. Przełączenie się na użycie przeciążenia wykorzystującego element „StringComparison” może spowodować subtelne zmiany w zachowaniu, dlatego ważne jest przeprowadzenie dokładnego testowania po zastosowaniu sugestii. Ponadto jeśli nie jest wymagane porównanie wrażliwe kulturowo, rozważ użycie elementu „StringComparer.OrdinalIgnoreCase”.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonMessage">
        <source>Prefer the string comparison method overload of '{0}' that takes a 'StringComparison' enum value to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</source>
        <target state="translated">Preferuj przeciążenie metody porównywania ciągów „{0}”, która przyjmuje wartość wyliczenia „StringComparison”, aby wykonać porównanie bez uwzględniania wielkości liter, ale pamiętaj, że może to spowodować subtelne zmiany w zachowaniu, więc upewnij się, że przeprowadzasz dokładne testy po zastosowaniu sugestii, lub jeśli porównanie wrażliwe kulturowo nie jest wymagane, rozważ użycie elementu „StringComparer.OrdinalIgnoreCase”</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonTitle">
        <source>Use the 'StringComparison' method overloads to perform case-insensitive string comparisons</source>
        <target state="translated">Użyj przeciążenia metody „StringComparison”, aby wykonać porównanie ciągów bez uwzględniania wielkości liter.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsCodeFixTitle">
        <source>Use 'string.Equals(string, StringComparison)'</source>
        <target state="translated">Użyj ciągu „string.Equals(string, StringComparison)”</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons, as in 'string.ToLower() == string.ToLower()', because they lead to an allocation. Instead, use 'string.Equals(string, StringComparison)' to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</source>
        <target state="translated">Unikaj wywoływania elementów „ToLower”, „ToUpper”, „ToLowerInvariant” i „ToUpperInvariant”, aby wykonywać porównania ciągów bez uwzględniania wielkości liter, jak w przypadku „string”. ToLower() == ciąg. ToLower()”, ponieważ prowadzą do alokacji. Zamiast tego użyj „string.Equals(string, StringComparison)”, aby wykonać porównanie bez uwzględniania wielkości liter. Przełączenie się na użycie przeciążenia wykorzystującego element „StringComparison” może spowodować subtelne zmiany w zachowaniu, dlatego ważne jest przeprowadzenie dokładnego testowania po zastosowaniu sugestii. Ponadto jeśli nie jest wymagane porównanie wrażliwe kulturowo, rozważ użycie elementu „StringComparer.OrdinalIgnoreCase”.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsMessage">
        <source>Prefer using 'string.Equals(string, StringComparison)' to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</source>
        <target state="translated">Preferuj używanie ciągu „string.Equals(string, StringComparison)”, aby wykonać porównanie bez uwzględniania wielkości liter, ale pamiętaj, że może to spowodować subtelne zmiany w zachowaniu, więc upewnij się, że przeprowadzasz dokładne testy po zastosowaniu sugestii lub jeśli porównanie wrażliwe kulturowo nie jest wymagane, rozważ użycie elementu „StringComparer.OrdinalIgnoreCase”</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantCall">
        <source>Remove redundant call</source>
        <target state="translated">Usuń nadmiarowe wywołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantGuardCallCodeFixTitle">
        <source>Remove unnecessary call</source>
        <target state="translated">Usuń niepotrzebne wywołanie</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplaceStringLiteralWithCharLiteralCodeActionTitle">
        <source>Replace string literal with char literal</source>
        <target state="translated">Zamień literał ciągu na literał char</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesMessage">
        <source>Potential DLL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie biblioteki DLL, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesTitle">
        <source>Review code for DLL injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie biblioteki DLL</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesMessage">
        <source>Potential file path injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie ścieżki pliku, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesTitle">
        <source>Review code for file path injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie ścieżki pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesMessage">
        <source>Potential information disclosure vulnerability was found where '{0}' in method '{1}' may contain unintended information from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą ujawnienie informacji, gdzie element „{0}” w metodzie „{1}” może zawierać niezamierzone informacje z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesTitle">
        <source>Review code for information disclosure vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających ujawnienie informacji</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesMessage">
        <source>Potential LDAP injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie protokołu LDAP, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesTitle">
        <source>Review code for LDAP injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie protokołu LDAP</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesMessage">
        <source>Potential open redirect vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą istnienie otwartego przekierowania, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesTitle">
        <source>Review code for open redirect vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających otwarcie przekierowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesMessage">
        <source>Potential process command injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie polecenia procesu, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesTitle">
        <source>Review code for process command injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie polecenia procesu</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesMessage">
        <source>Potential regex injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie wyrażenia regularnego, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesTitle">
        <source>Review code for regex injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie wyrażenia regularnego</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesMessage">
        <source>Potential SQL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie kodu SQL, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesTitle">
        <source>Review code for SQL injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu SQL</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesMessage">
        <source>Potential XPath injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie wyrażenia XPath, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesTitle">
        <source>Review code for XPath injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie wyrażenia XPath</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesMessage">
        <source>Potential XAML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie kodu XAML, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesTitle">
        <source>Review code for XAML injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu XAML</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesMessage">
        <source>Potential XML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Znaleziono potencjalną lukę umożliwiającą wstrzyknięcie kodu XML, gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesTitle">
        <source>Review code for XML injection vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających wstrzyknięcie kodu XML</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesMessage">
        <source>Potential cross-site scripting (XSS) vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">Wykryto potencjalną lukę umożliwiającą działanie skryptów międzywitrynowych (XSS), gdzie element „{0}” w metodzie „{1}” może zostać zanieczyszczony danymi kontrolowanymi przez użytkownika z elementu „{2}” w metodzie „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesTitle">
        <source>Review code for XSS vulnerabilities</source>
        <target state="translated">Przegląd kodu pod kątem luk umożliwiających działanie skryptów między witrynami</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesDescription">
        <source>SQL queries that directly use user input can be vulnerable to SQL injection attacks. Review this SQL query for potential vulnerabilities, and consider using a parameterized SQL query.</source>
        <target state="translated">Zapytania SQL korzystające bezpośrednio z danych wejściowych użytkownika mogą być podatne na ataki polegające na wstrzyknięciu kodu SQL. Sprawdź to zapytanie SQL pod kątem potencjalnych luk i rozważ użycie sparametryzowanego zapytania SQL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesMessageNoNonLiterals">
        <source>Review if the query string passed to '{0}' in '{1}', accepts any user input</source>
        <target state="translated">Sprawdź, czy ciąg zapytania przekazany do elementu „{0}” w elemencie „{1}” akceptuje dowolne dane wejściowe użytkownika</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesTitle">
        <source>Review SQL queries for security vulnerabilities</source>
        <target state="translated">Sprawdź zapytania SQL pod kątem luk w zabezpieczeniach</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesCodeFixTitle">
        <source>Seal class</source>
        <target state="translated">Klasa pieczęci</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesDescription">
        <source>When a type is not accessible outside its assembly and has no subtypes within its containing assembly, it can be safely sealed. Sealing types can improve performance.</source>
        <target state="translated">Jeśli typ jest niedostępny poza swoim zestawem i nie ma żadnych podtypów w obrębie swojego zawierającego zestawu, to można go bezpiecznie zapieczętować. Zapieczętowanie typów może zwiększyć wydajność.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesMessage">
        <source>Type '{0}' can be sealed because it has no subtypes in its containing assembly and is not externally visible</source>
        <target state="translated">Typ „{0}” może być zapieczętowany, ponieważ nie ma żadnych podtypów w swoim zawierającym zestawie i nie jest widoczny zewnętrznie</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesTitle">
        <source>Seal internal types</source>
        <target state="translated">Zapieczętuj typy wewnętrzne</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookie">
        <source>Set HttpOnly to true for HttpCookie</source>
        <target state="translated">Ustaw element HttpOnly na wartość true dla elementu HttpCookie</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieDescription">
        <source>As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies.</source>
        <target state="translated">W celu zapewnienia kompleksowej ochrony upewnij się, że wpływające na zabezpieczenia pliki cookie protokołu HTTP są oznaczone jako HttpOnly. Oznacza to, że przeglądarki internetowe powinny uniemożliwić skryptom uzyskiwanie dostępu do tych plików cookie. Wstrzykiwanie złośliwych skryptów to typowy sposób kradzieży plików cookie.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieMessage">
        <source>HttpCookie.HttpOnly is set to false or not set at all when using an HttpCookie. Ensure security sensitive cookies are marked as HttpOnly to prevent malicious scripts from stealing the cookies</source>
        <target state="translated">Właściwość HttpCookie.HttpOnly jest ustawiana na wartość false lub nie jest konfigurowana wcale w przypadku używania elementu HttpCookie. Upewnij się, że wpływające na zabezpieczenia pliki cookie są oznaczone jako HttpOnly, aby uniemożliwić złośliwym skryptom kradzież plików cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">Ustaw właściwość ViewStateUserKey dla klas pochodzących od klasy Page</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">Ustawienie właściwości ViewStateUserKey może pomóc zapobiec atakom na aplikację, umożliwiając przypisanie identyfikatora do zmiennej view-state dla poszczególnych użytkowników, aby nie mogli użyć zmiennej do wygenerowania ataku. W przeciwnym razie będą istniały luki w zabezpieczeniach przed fałszowaniem żądań międzywitrynowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The class {0} derived from System.Web.UI.Page does not set the ViewStateUserKey property in the OnInit method or Page_Init method</source>
        <target state="translated">Klasa {0} pochodząca z biblioteki System.Web.UI.Page nie ustawia właściwości ViewStateUserKey w metodzie OnInit lub metodzie Page_Init</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperDescription">
        <source>Specify culture to help avoid accidental implicit dependency on current culture. Using an invariant version yields consistent results regardless of the culture of an application.</source>
        <target state="translated">Określ kulturę, aby uniknąć przypadkowej, niejawnej zależności od bieżącej kultury. Użycie niezmiennej wersji daje spójne wyniki niezależnie od kultury aplikacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperMessage">
        <source>Specify a culture or use an invariant version to avoid implicit dependency on current culture</source>
        <target state="translated">Określ kulturę lub użyj niezmiennej wersji, aby uniknąć niejawnej zależności od bieżącej kultury</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperTitle">
        <source>Specify a culture or use an invariant version</source>
        <target state="translated">Określ kulturę lub użyj niezmiennej wersji</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">Metoda lub konstruktor wywołuje element członkowski z przeciążeniem akceptującym parametr System.Globalization.CultureInfo, a nie wywołuje przeciążenia pobierającego parametr CultureInfo. Jeśli parametr CultureInfo lub obiekt System.IFormatProvider nie zostanie określony, wartość domyślna podana przez przeciążony element członkowski może nie dawać pożądanego efektu w przypadku wszystkich ustawień regionalnych. Jeśli wynik będzie wyświetlany dla użytkownika, określ dla parametru „CultureInfo” wartość „CultureInfo.CurrentCulture”. W przeciwnym przypadku, jeśli wynik będzie przechowywany i używany przez oprogramowanie — tak jak przy utrwalaniu na dysku lub w bazie danych, określ wartość „CultureInfo.InvariantCulture”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Zachowanie elementu „{0}” może być różne w zależności od bieżących ustawień regionalnych użytkownika. Zastąp to wywołanie w metodzie „{1}” wywołaniem metody „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">Określ parametr CultureInfo</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCurrentCulture">
        <source>Specify current culture</source>
        <target state="translated">Określ bieżącą kulturę</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">Metoda lub konstruktor wywołuje co najmniej jedną składową z przeciążeniem akceptującym parametr System.IFormatProvider, a nie wywołuje przeciążenia pobierającego parametr IFormatProvider. Jeśli parametr System.Globalization.CultureInfo lub obiekt IFormatProvider nie zostanie określony, wartość domyślna podana przez przeciążoną składową może nie dawać pożądanego efektu w przypadku wszystkich ustawień regionalnych. Jeśli wynik będzie oparty na danych wprowadzanych przez użytkownika lub wyświetlanych dla użytkownika, określ dla parametru „IFormatProvider” wartość „CultureInfo.CurrentCulture”. W przeciwnym przypadku, jeśli wynik będzie przechowywany i używany przez oprogramowanie — tak jak przy ładowaniu z dysku lub bazy danych i utrwalaniu na dysku lub w bazie danych, określ wartość „CultureInfo.InvariantCulture”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Zachowanie elementu „{0}” może być różne w zależności od bieżących ustawień regionalnych użytkownika. Zastąp to wywołanie w metodzie „{1}” wywołaniem metody „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Zachowanie elementu „{0}” może być różne w zależności od bieżących ustawień regionalnych użytkownika. Zastąp to wywołanie w metodzie „{1}” wywołaniem metody „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderOptional">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Provide a value for the 'IFormatProvider' argument.</source>
        <target state="translated">Zachowanie elementu „{0}” może się różnić w zależności od ustawień regionalnych bieżącego użytkownika. Podaj wartość argumentu „IFormatProvider”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">Metoda „{0}” przekazuje wartość „{1}” jako parametr „IFormatProvider” do metody „{2}”. Ta właściwość zwraca kulturę nieodpowiednią dla metod formatujących.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">Metoda „{0}” przekazuje wartość „{1}” jako parametr „IFormatProvider” do metody „{2}”. Ta właściwość zwraca kulturę nieodpowiednią dla metod formatujących.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">Określ interfejs IFormatProvider</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">Element członkowski wywołania platformy zezwala na częściowo zaufany kod wywołujący, ma parametr ciągu i nie kieruje jawnie łańcuchem. Może to być przyczyną potencjalnej luki w zabezpieczeniach.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">Określ kierowanie dla argumentów ciągu P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. It is recommended to use the overload with StringComparison parameter for clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">Operacja porównywania ciągów używa przeciążenia metody bez ustawionego parametru StringComparison. Zalecamy użycie przeciążenia z parametrem StringComparison, aby wyjaśnić intencję. Jeśli wynik będzie wyświetlany dla użytkownika, tak jak w przypadku sortowania listy elementów do wyświetlenia w polu listy, określ wartość „StringComparison.CurrentCulture” lub „StringComparison.CurrentCultureIgnoreCase” dla parametru „StringComparison”. W przypadku porównywania identyfikatorów nieuwzględniających wielkości liter, takich jak ścieżki do plików, zmienne środowiskowe czy klucze i wartości rejestru, określ wartość „StringComparison.OrdinalIgnoreCase”. W przeciwnym przypadku, jeśli porównywane są identyfikatory uwzględniające wielkość liter, określ wartość „StringComparison.Ordinal”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Message">
        <source>'{0}' has a method overload that takes a 'StringComparison' parameter. Replace this call in '{1}' with a call to '{2}' for clarity of intent.</source>
        <target state="translated">Element „{0}” ma przeciążenie metody, które przyjmuje parametr „StringComparison”. Zamień to wywołanie w elemencie „{1}” na wywołanie elementu „{2}”, aby wyjaśnić intencję.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Title">
        <source>Specify StringComparison for clarity</source>
        <target state="translated">Określ parametr StringComparison w celu wyjaśnienia</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter, hence its behavior could vary based on the current user's locale settings. It is strongly recommended to use the overload with StringComparison parameter for correctness and clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">Operacja porównywania ciągów używa przeciążenia metody bez ustawionego parametru StringComparison, dlatego jej działanie może różnić się w zależności od bieżących ustawień regionalnych użytkownika. Stanowczo zalecamy użycie przeciążenia z parametrem StringComparison w celu osiągnięcia poprawności i wyjaśnienia intencji. Jeśli wynik będzie wyświetlany dla użytkownika, tak jak w przypadku sortowania listy elementów do wyświetlenia w polu listy, określ wartość „StringComparison.CurrentCulture” lub „StringComparison.CurrentCultureIgnoreCase” dla parametru „StringComparison”. W przypadku porównywania identyfikatorów nieuwzględniających wielkości liter, takich jak ścieżki do plików, zmienne środowiskowe czy klucze i wartości rejestru, określ wartość „StringComparison.OrdinalIgnoreCase”. W przeciwnym przypadku, jeśli porównywane są identyfikatory uwzględniające wielkość liter, określ wartość „StringComparison.Ordinal”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Message">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Zachowanie elementu „{0}” może być różne w zależności od bieżących ustawień regionalnych użytkownika. Zastąp to wywołanie w metodzie „{1}” wywołaniem metody „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Title">
        <source>Specify StringComparison for correctness</source>
        <target state="translated">Określ parametr StringComparison w celu osiągnięcia poprawności</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticAndAbstractRequiresPreviewFeatures">
        <source>Using both 'static' and 'abstract' modifiers requires opting into preview features. See https://aka.ms/dotnet-warnings/preview-features for more information.</source>
        <target state="translated">Używanie modyfikatorów „statycznych” i „abstrakcyjnych” wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz https://aka.ms/dotnet-warnings/preview-features.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">Porównywanie ciągów za pomocą właściwości String.Length lub metody String.IsNullOrEmpty jest znacznie szybsze niż za pomocą metody Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check</source>
        <target state="translated">Testowanie pod kątem pustego ciągu wykonuj za pomocą właściwości „string.Length” lub metody „string.IsNullOrEmpty” zamiast sprawdzania pod kątem równości</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">Sprawdzaj występowanie ciągów pustych za pomocą funkcji mierzenia długości ciągu</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">To wyrażenie sprawdza, czy wartość to Single.Nan lub Double.Nan. Użyj metody Single.IsNan(Single) lub Double.IsNan(Double), aby to sprawdzić.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">Sprawdzaj poprawnie pod kątem wartości NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">Sprawdzaj poprawnie pod kątem wartości NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineDescription">
        <source>'ThreadStatic' fields should be initialized lazily on use, not with inline initialization nor explicitly in a static constructor, which would only initialize the field on the thread that runs the type's static constructor.</source>
        <target state="translated">Pola „ThreadStatic“ powinny być inicjowane z opóźnieniem w użyciu, a nie z inicjacją śródwierszową ani jawnie w konstruktorze statycznym, co spowodowałoby zainicjowanie pola tylko w wątku, w którym działa konstruktor statyczny typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineMessage">
        <source>'ThreadStatic' fields should not use inline initialization</source>
        <target state="translated">Pola „ThreadStatic“ nie powinny używać inicjowania wbudowanego</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineTitle">
        <source>Improper 'ThreadStatic' field initialization</source>
        <target state="translated">Nieprawidłowe inicjowanie pola „ThreadStatic“</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldDescription">
        <source>'ThreadStatic' only affects static fields. When applied to instance fields, it has no impact on behavior.</source>
        <target state="translated">Element „ThreadStatic“ ma wpływ tylko na pola statyczne. Po zastosowaniu do pól wystąpienia, nie ma on wpływu na zachowanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldMessage">
        <source>Ensure 'ThreadStatic' is only used with static fields</source>
        <target state="translated">Upewnij się, że element „ThreadStatic“ jest używany tylko z polami statycznymi</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldTitle">
        <source>'ThreadStatic' only affects static fields</source>
        <target state="translated">Element „ThreadStatic“ ma wpływ tylko na pola statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentExceptionThrowHelperTitle">
        <source>Use ArgumentException throw helper</source>
        <target state="translated">Użyj pomocnika zgłaszania ArgumentException</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentNullExceptionThrowHelperTitle">
        <source>Use ArgumentNullException throw helper</source>
        <target state="translated">Użyj pomocnika zgłaszania ArgumentNullException</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentOutOfRangeExceptionThrowHelperTitle">
        <source>Use ArgumentOutOfRangeException throw helper</source>
        <target state="translated">Użyj pomocnika zgłaszania ArgumentOutOfRangeException</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">Użyj metody Array.Empty</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is often unwanted when it is implicitly used as a Span or Memory value. Use the AsSpan method to avoid the copy.</source>
        <target state="translated">Użycie indeksatora opartego na zakresie w przypadku wartości tablicy powoduje utworzenie kopii żądanej części tablicy. Ta kopia jest często niechciana, gdy jest niejawnie używana jako wartość Span lub Memory. Użyj metody AsSpan, aby uniknąć kopiowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerMessage">
        <source>Use '{0}' instead of the '{1}'-based indexer on '{2}' to avoid creating unnecessary data copies</source>
        <target state="translated">Użyj metody „{0}” zamiast indeksatora opartego na elementu „{1}” w przypadku wartości „{2}”, aby uniknąć tworzenia niepotrzebnych kopii danych</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAStringCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on a string</source>
        <target state="translated">Użyj elementu „{0}” zamiast indeksatorów opartych na zakresie względem ciągu</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAnArrayCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on an array</source>
        <target state="translated">Użyj elementu „{0}” zamiast indeksatorów opartych na zakresie względem tablicy</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerTitle">
        <source>Use AsSpan or AsMemory instead of Range-based indexers when appropriate</source>
        <target state="translated">Użyj metody AsSpan lub AsMemory zamiast indeksatorów opartych na zakresie, gdy ma to zastosowanie</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfStringRangeIndexerDescription">
        <source>The Range-based indexer on string values produces a copy of requested portion of the string. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">Użycie indeksatora opartego na zakresie w przypadku wartości ciągu powoduje utworzenie kopii żądanej części ciągu. Ta kopia jest zwykle niepotrzebna, gdy jest niejawnie używana jako wartość ReadOnlySpan lub ReadOnlyMemory. Użyj metody AsSpan, aby uniknąć zbędnego kopiowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanReadOnlyInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">Użycie indeksatora opartego na zakresie w przypadku wartości tablicy powoduje utworzenie kopii żądanej części tablicy. Ta kopia jest zwykle niepotrzebna, gdy jest niejawnie używana jako wartość ReadOnlySpan lub ReadOnlyMemory. Użyj metody AsSpan, aby uniknąć zbędnego kopiowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextDescription">
        <source>When inside a Task-returning method, use the async version of methods, if they exist.</source>
        <target state="translated">W metodzie zwracającej Task użyj asynchronicznej wersji metod, jeśli istnieją.</target>
        <note>{Locked="Task"}</note>
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextMessage">
        <source>'{0}' synchronously blocks. Await '{1}' instead.</source>
        <target state="translated">Metoda „{0}” powoduje blokowanie synchroniczne. Zamiast tego używaj operatora await „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextMessage_NoAlternative">
        <source>'{0}' synchronously blocks. Use await instead.</source>
        <target state="translated">Metoda „{0}” powoduje blokowanie synchroniczne. Zamiast tego używaj operatora await.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextTitle">
        <source>Call async methods when in an async method</source>
        <target state="translated">Wywoływanie metod asynchronicznych w metodzie asynchronicznej</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryToken">
        <source>Use antiforgery tokens in ASP.NET Core MVC controllers</source>
        <target state="translated">Użyj tokenów zabezpieczających przed fałszerstwem w kontrolerach MVC ASP.NET Core</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenDescription">
        <source>Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</source>
        <target state="translated">Obsługa żądania POST, PUT, PATCH lub DELETE bez weryfikacji tokenu zabezpieczającego przed fałszerstwem może prowadzić do podatności na ataki z wykorzystaniem fałszerstwa żądania międzywitrynowego. Atak z wykorzystaniem fałszerstwa żądania międzywitrynowego może wysyłać złośliwe żądania od uwierzytelnionego użytkownika do kontrolera MVC ASP.NET Core.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenMessage">
        <source>Method {0} handles a {1} request without performing antiforgery token validation. You also need to ensure that your HTML form sends an antiforgery token.</source>
        <target state="translated">Metoda {0} obsługuje żądanie {1} bez przeprowadzania weryfikacji tokenu zabezpieczającego przed fałszerstwem. Należy również upewnić się, że formularz HTML wysyła token zabezpieczający przed fałszerstwem.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedCodeFixTitle">
        <source>Replace with 'CancellationToken.ThrowIfCancellationRequested'</source>
        <target state="translated">Zamień na element „CancellationToken.ThrowIfCancellationRequested”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedDescription">
        <source>'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has.</source>
        <target state="translated">Polecenie „ThrowIfCancellationRequested” automatycznie sprawdza, czy token został anulowany, i zgłasza wyjątek „OperationCanceledException”, jeśli go ma.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedMessage">
        <source>Use 'ThrowIfCancellationRequested' instead of checking 'IsCancellationRequested' and throwing 'OperationCanceledException'</source>
        <target state="translated">Użyj polecenia „ThrowIfCancellationRequested” zamiast sprawdzania elementu „IsCancellationRequested” i zgłaszania wyjątku „OperationCanceledException”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedTitle">
        <source>Use 'ThrowIfCancellationRequested'</source>
        <target state="translated">Użyj polecenia „ThrowIfCancellationRequested”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatDescription">
        <source>Cache and use a 'CompositeFormat' instance as the argument to this formatting operation, rather than passing in the original format string. This reduces the cost of the formatting operation.</source>
        <target state="translated">Umieść wystąpienie „CompositeFormat” w pamięci podręcznej i użyj go jako argumentu tej operacji formatowania zamiast przekazywania oryginalnego ciągu formatu. Zmniejsza to koszt operacji formatowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatMessage">
        <source>Cache a 'CompositeFormat' for repeated use in this formatting operation</source>
        <target state="translated">Buforuj element „CompositeFormat” w celu wielokrotnego użycia w tej operacji formatowania</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatTitle">
        <source>Use 'CompositeFormat'</source>
        <target state="translated">Użyj elementu „CompositeFormat”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeDescription">
        <source>Using concrete types avoids virtual or interface call overhead and enables inlining.</source>
        <target state="translated">Użycie konkretnych typów pozwala uniknąć narzutu wywołań wirtualnych lub interfejsu i umożliwia podkreślenie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForFieldMessage">
        <source>Change type of field '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">Zmień typ pola „{0}” z „{1}” na „{2}”, aby zwiększyć wydajność</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForLocalMessage">
        <source>Change type of variable '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">Zmień typ zmiennej „{0}” z „{1}” na „{2}”, aby zwiększyć wydajność</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForMethodReturnMessage">
        <source>Change return type of method '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">Zmień zwracany typ metody „{0}” z „{1}” na „{2}”, aby zwiększyć wydajność</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForParameterMessage">
        <source>Change type of parameter '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">Zmień typ parametru „{0}” z „{1}” na „{2}”, aby zwiększyć wydajność</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForPropertyMessage">
        <source>Change type of property '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">Zmień typ właściwości „{0}” z „{1}” na „{2}”, aby zwiększyć wydajność</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeTitle">
        <source>Use concrete types when possible for improved performance</source>
        <target state="translated">Używaj konkretnych typów, aby zwiększyć wydajność – gdy jest to możliwe</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="translated">Użyj zasad dostępu na poziomie kontenera</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="translated">Nie określono identyfikatora zasad dostępu, co powoduje, że tokeny są nieodwoływalne.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS.</source>
        <target state="translated">Jeśli to możliwe, rozważ użycie kontroli dostępu opartej na rolach platformy Azure zamiast sygnatury dostępu współdzielonego (SAS). Jeśli nadal chcesz używać sygnatury SAS, podczas jej tworzenia użyj zasad dostępu na poziomie kontenera.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttribute">
        <source>Use DefaultDllImportSearchPaths attribute for P/Invokes</source>
        <target state="translated">Użyj atrybutu DefaultDllImportSearchPaths dla elementów P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeDescription">
        <source>By default, P/Invokes using DllImportAttribute probe a number of directories, including the current working directory for the library to load. This can be a security issue for certain applications, leading to DLL hijacking.</source>
        <target state="translated">Domyślnie elementy P/Invoke korzystające z atrybutu DllImportAttribute sondują określoną liczbę katalogów, w tym bieżący katalog roboczy biblioteki do załadowania. Może to stanowić problem z zabezpieczeniami dla pewnych aplikacji i prowadzić do przejęcia biblioteki DLL.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeMessage">
        <source>The method {0} didn't use DefaultDllImportSearchPaths attribute for P/Invokes.</source>
        <target state="translated">Metoda {0} nie korzystała z atrybutu DefaultDllImportSearchPaths dla elementów P/Invoke.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDisabledMarshallingEquivalentCodeFix">
        <source>Use equivalent code that works when marshalling is disabled</source>
        <target state="translated">Użyj równoważnego kodu, który działa, gdy kierowanie jest wyłączone</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdDescription">
        <source>'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'.</source>
        <target state="translated">Element „Environment. CurrentManagedThreadId” jest prostszy i szybszy niż element „Thread.CurrentThread. ManagedThreadId”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdFix">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="translated">Użyj elementu „Environment.CurrentManagedThreadId”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdMessage">
        <source>Use 'Environment.CurrentManagedThreadId' instead of 'Thread.CurrentThread.ManagedThreadId'</source>
        <target state="translated">Użyj elementu „Environment. CurrentManagedThreadId” zamiast elementu „Thread.CurrentThread.ManagedThreadId”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdTitle">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="translated">Użyj elementu „Environment.CurrentManagedThreadId”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdDescription">
        <source>'Environment.ProcessId' is simpler and faster than 'Process.GetCurrentProcess().Id'.</source>
        <target state="translated">Element „Environment.ProcessId” jest prostszy i szybszy niż element „Process.GetCurrentProcess().Id”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdFix">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">Użyj elementu „Environment.ProcessId”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdMessage">
        <source>Use 'Environment.ProcessId' instead of 'Process.GetCurrentProcess().Id'</source>
        <target state="translated">Użyj elementu „Environment.ProcessId” zamiast elementu „Process.GetCurrentProcess().Id”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdTitle">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">Użyj elementu „Environment.ProcessId”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathDescription">
        <source>'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'.</source>
        <target state="translated">Element „Environment.ProcessPath” jest prostszy i szybszy niż element „Process.GetCurrentProcess(). MainModule.FileName”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathFix">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="translated">Użyj ścieżki „Environment.ProcessPath”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathMessage">
        <source>Use 'Environment.ProcessPath' instead of 'Process.GetCurrentProcess().MainModule.FileName'</source>
        <target state="translated">Użyj elementu „Environment.ProcessPath” zamiast elementu „Process.GetCurrentProcess ().MainModule.FileName”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathTitle">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="translated">Użyj ścieżki „Environment.ProcessPath”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIndexer">
        <source>Use indexer</source>
        <target state="translated">Użyj indeksatora</target>
        <note />
      </trans-unit>
      <trans-unit id="UseInvariantVersion">
        <source>Use an invariant version</source>
        <target state="translated">Użyj niezmiennej wersji</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">Metoda wywoływania systemu operacyjnego jest zdefiniowana, a metoda mająca odpowiadającą jej funkcję znajduje się w bibliotece klas platformy .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Używaj zarządzanych odpowiedników funkcji win32 api</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Używaj zarządzanych odpowiedników funkcji win32 api</target>
        <note />
      </trans-unit>
      <trans-unit id="UseObjectDisposedExceptionThrowHelperTitle">
        <source>Use ObjectDisposedException throw helper</source>
        <target state="translated">Użyj pomocnika zgłaszania ObjectDisposedException</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">Operacja porównywania ciągów nieuwzględniająca zasad języka nie ustawia parametru StringComparison na wartość Ordinal ani OrdinalIgnoreCase. Jawne ustawienie parametru na wartość StringComparison.Ordinal lub StringComparison.OrdinalIgnoreCase umożliwia często przyspieszenie kodu oraz zwiększenie jego poprawności i niezawodności.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal string comparison</source>
        <target state="translated">Użyj porównywania ciągów porządkowych</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableDescription">
        <source>Enumerable.Count() potentially enumerates the sequence while a Length/Count property is a direct access.</source>
        <target state="translated">Metoda Enumerable.Count() może potencjalnie wyliczyć sekwencję, podczas gdy właściwość Length/Count stanowi dostęp bezpośredni.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableMessage">
        <source>Use the "{0}" property instead of Enumerable.Count()</source>
        <target state="translated">Użyj właściwości „{0}” zamiast metody Enumerable.Count()</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableTitle">
        <source>Use Length/Count property instead of Count() when available</source>
        <target state="translated">Użyj właściwości Length/Count zamiast metody Count(), gdy jest to możliwe</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest-Shamir-Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="translated">Użyj algorytmu Rivest-Shamir-Adleman (RSA) z wystarczającym rozmiarem klucza</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="translated">Algorytmy szyfrowania z kluczem o zbyt małym rozmiarze są podatne na ataki siłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">Rozmiar klucza algorytmu szyfrowania asymetrycznego {0} jest mniejszy niż 2048. Przełącz się na algorytm RSA z kluczem o rozmiarze co najmniej 2048, algorytm ECDH lub algorytm ECDSA.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountDescription">
        <source>'Regex.Count' is simpler and faster than 'Regex.Matches(...).Count'.</source>
        <target state="translated">Wyrażenie „Regex.Count” jest prostsze i szybsze niż „Regex.Matches(...).Count”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountFix">
        <source>Use 'Regex.Count'</source>
        <target state="translated">Używanie wyrażenia „Regex.Count”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountMessage">
        <source>Use 'Regex.Count' instead of 'Regex.Matches(...).Count'</source>
        <target state="translated">Użyj wyrażenia „Regex.Count” zamiast „Regex.Matches(...).Count”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountTitle">
        <source>Use 'Regex.Count'</source>
        <target state="translated">Używanie wyrażenia „Regex.Count”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchDescription">
        <source>'Regex.IsMatch' is simpler and faster than 'Regex.Match(...).Success'.</source>
        <target state="translated">Wyrażenie „Regex.IsMatch” jest prostsze i szybsze niż „Regex.Match(...).Success”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchFix">
        <source>Use 'Regex.IsMatch'</source>
        <target state="translated">Użyj wyrażenia „Regex.IsMatch”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchMessage">
        <source>Use 'Regex.IsMatch' instead of 'Regex.Match(...).Success'</source>
        <target state="translated">Użyj wyrażenia „Regex.IsMatch” zamiast „Regex.Match(...).Success”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchTitle">
        <source>Use 'Regex.IsMatch'</source>
        <target state="translated">Użyj wyrażenia „Regex.IsMatch”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesCodeFixTitle">
        <source>Use 'SearchValues'</source>
        <target state="translated">Użyj elementu „SearchValues”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesDescription">
        <source>Using a cached 'SearchValues' instance is more efficient than passing values to 'IndexOfAny'/'ContainsAny' directly.</source>
        <target state="translated">Użycie buforowanego wystąpienia „SearchValues” jest bardziej wydajne niż bezpośrednie przekazywanie wartości do elementu „IndexOfAny”/”ContainsAny”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesMessage">
        <source>Use a cached 'SearchValues' instance for improved searching performance</source>
        <target state="translated">Używanie buforowanego wystąpienia „SearchValues” w celu zwiększenia wydajności wyszukiwania</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesTitle">
        <source>Use a cached 'SearchValues' instance</source>
        <target state="translated">Używanie buforowanego wystąpienia „SearchValues”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="translated">Aplikacje dostępne za pośrednictwem protokołu HTTPS muszą korzystać z bezpiecznych plików cookie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">Użyj właściwości SharedAccessProtocol HttpsOnly</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">Protokół HTTPS szyfruje ruch sieciowy. Użyj właściwości HttpsOnly, a nie HttpOrHttps, aby ruch sieciowy był zawsze szyfrowany i aby zapobiec ujawnieniu poufnych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly.</source>
        <target state="translated">Jeśli to możliwe, rozważ użycie kontroli dostępu opartej na rolach platformy Azure zamiast sygnatury dostępu współdzielonego (SAS). Jeśli nadal chcesz używać sygnatury SAS, określ właściwość SharedAccessProtocol.HttpsOnly.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatCodeFixTitle">
        <source>Use 'AsSpan' with 'string.Concat'</source>
        <target state="translated">Użyj ciągu „AsSpan” z ciągiem „String.Concat”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatDescription">
        <source>It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator.</source>
        <target state="translated">Bardziej wydajne jest użycie ciągów „AsSpan” i "string.Concat", zamiast ciągu „Substring” i operatora złączenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatMessage">
        <source>Use span-based 'string.Concat' and 'AsSpan' instead of 'Substring'</source>
        <target state="translated">Użyj ciągu „string.Concat” opartego na zakresie i ciągu „AsSpan” zamiast ciągu „Substring”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatTitle">
        <source>Use span-based 'string.Concat'</source>
        <target state="translated">Użyj ciągu „string.Concat” opartego na zakresie. </target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillCodeFixTitle">
        <source>Use 'Clear()'</source>
        <target state="translated">Użyj polecenia „Clear()”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillDescription">
        <source>It is more efficient to use 'Clear', instead of 'Fill' with default value.</source>
        <target state="translated">Użycie opcji „Wyczyść” zamiast opcji „Wypełnij” z wartością domyślną jest efektywniejsze.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillMessage">
        <source>Prefer 'Span&lt;T&gt;.Clear()' instead of 'Span&lt;T&gt;.Fill(default)'</source>
        <target state="translated">Preferuj polecenie „Span&lt;T&gt;. Clear()” zamiast „Span&lt;T&gt;. Fill(domyślnie)”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillTitle">
        <source>Prefer 'Clear' over 'Fill'</source>
        <target state="translated">Preferuj opcję „Wyczyść” niż „Wypełnij”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFixTitle">
        <source>Use 'StartsWith'</source>
        <target state="translated">Użyj instrukcji „StartsWith”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroDescription">
        <source>It is both clearer and faster to use 'StartsWith' instead of comparing the result of 'IndexOf' to zero.</source>
        <target state="translated">Użycie instrukcji „StartsWith” jest wyraźniejsze i szybsze niż porównywanie wyniku „IndexOf” z wartością zero.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroMessage">
        <source>Use 'StartsWith' instead of comparing the result of 'IndexOf' to 0</source>
        <target state="translated">Użyj instrukcji „StartsWith” zamiast porównywania wyniku „IndexOf” z wartością 0</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroTitle">
        <source>Use 'StartsWith' instead of 'IndexOf'</source>
        <target state="translated">Użyj instrukcji „StartsWith” zamiast „IndexOf”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersDescription">
        <source>'string.Contains(char)' is available as a better performing overload for single char lookup.</source>
        <target state="translated">Ciąg „string.Contains(char)” jest dostępny jako przeciążenie o lepszej wydajności dla wyszukiwania pojedynczego znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.Contains(char)' instead of 'string.Contains(string)' when searching for a single character</source>
        <target state="translated">Użyj ciągu „string.Contains(char)”, zamiast ciągu „string.Contains(string)” podczas wyszukiwania pojedynczego znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersTitle">
        <source>Use char literal for a single character lookup</source>
        <target state="translated">Użyj literału char do wyszukiwania pojedynczego znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareCodeFixTitle">
        <source>Use 'string.Equals'</source>
        <target state="translated">Użyj ciągu „string. Equals”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareDescription">
        <source>It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero.</source>
        <target state="translated">Użycie ciągu „string.Equals” jest wyraźniejsze i prawdopodobnie szybsze zamiast porównywania wyniku „string.Compare” z zerem.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareMessage">
        <source>Use 'string.Equals' instead of comparing the result of 'string.Compare' to 0</source>
        <target state="translated">Użyj ciągu „string.Equals” zamiast porównywania wyniku ciągu „string.Compare” z wartością 0</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareTitle">
        <source>Use 'string.Equals'</source>
        <target state="translated">Użyj ciągu „string. Equals”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersDescription">
        <source>The char overload is a better performing overload than a string with a single char.</source>
        <target state="translated">Przeciążenie znakiem jest bardziej wydajnym przeciążeniem niż ciąg z pojedynczym znakiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.{0}(char)' instead of 'string.{0}(string)' when you have a string with a single char</source>
        <target state="translated">Użyj ciągu „string.{0}(char)” zamiast „string.{0}(string)” w przypadku ciągu z pojedynczym znakiem</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersTitle">
        <source>Use char overload</source>
        <target state="translated">Użyj przeciążenia znaków</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperDescription">
        <source>Throw helpers are simpler and more efficient than an if block constructing a new exception instance.</source>
        <target state="translated">Pomocnicy zgłaszania są prostsi i wydajniejsi niż blok if konstruujący nowe wystąpienie wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperFix">
        <source>Use '{0}.{1}'</source>
        <target state="translated">Użyj „{0}.{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperMessage">
        <source>Use '{0}.{1}' instead of explicitly throwing a new exception instance</source>
        <target state="translated">Użyj „{0}.{1}” zamiast jawnego zgłaszania nowego wystąpienia wyjątku</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringDescription">
        <source>Platform compatibility analyzer requires a valid platform name and version.</source>
        <target state="translated">Analizator zgodności platformy wymaga prawidłowej nazwy i wersji platformy.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringInvalidVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Use a version with 2{2} parts for this platform.</source>
        <target state="translated">Wersja „{0}” jest nieprawidłowa dla platformy „{1}”. Użyj wersji z 2{2} częściami dla tej platformy.</target>
        <note>Version '7' is not valid for platform 'windows'. Use a version with 2-4 parts for this platform.</note>
      </trans-unit>
      <trans-unit id="UseValidPlatformStringNoVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Do not use versions for this platform.</source>
        <target state="translated">Wersja „{0}” nie jest prawidłowa dla platformy „{1}”. Nie używaj wersji dla tej platformy.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringTitle">
        <source>Use valid platform string</source>
        <target state="translated">Użyj prawidłowego ciągu platformy</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringUnknownPlatform">
        <source>The platform '{0}' is not a known platform name</source>
        <target state="translated">Platforma „{0}” nie jest znaną nazwą platformy</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyDescription">
        <source>ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</source>
        <target state="translated">Elementy ValueTask zwracane przez wywołania elementów członkowskich są przeznaczone do bezpośredniego oczekiwania. Próby wielokrotnego użycia elementu ValueTask lub uzyskania bezpośredniego dostępu do wyniku elementu zanim jest wiadomo, że został on zakończony, mogą spowodować wystąpienie wyjątku lub uszkodzenia. Zignorowanie takiego elementu ValueTask prawdopodobnie wskazuje na usterkę funkcjonalną i może obniżyć wydajność.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_AccessingIncompleteResult">
        <source>ValueTask instances should not have their result directly accessed unless the instance has already completed. Unlike Tasks, calling Result or GetAwaiter().GetResult() on a ValueTask is not guaranteed to block until the operation completes. If you can't simply await the instance, consider first checking its IsCompleted property (or asserting it's true if you know that to be the case).</source>
        <target state="translated">Nie należy bezpośrednio uzyskiwać dostępu do wystąpień elementu ValueTask, chyba że wystąpienie jest już zakończone. W przeciwieństwie do zadań, wywołanie elementu Result lub GetAwaiter().GetResult() nie gwarantuje blokowania do momentu zakończenia operacji. Jeśli nie można po prostu oczekiwać na wystąpienie, zastanów się nad sprawdzeniem w pierwszej kolejności jego właściwości IsCompleted (lub założeniem, że ma wartość true, jeśli wiesz, że tak jest).</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_DoubleConsumption">
        <source>ValueTask instances should only be consumed once, such as via an await. Consuming the same ValueTask instance multiple times can result in exceptions and data corruption.</source>
        <target state="translated">Wystąpienia elementu ValueTask powinny być używane tylko raz, na przykład za pośrednictwem operatora await. Wielokrotne użycie tego samego wystąpienia elementu ValueTask może spowodować zgłaszanie wyjątków i uszkodzenie danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_General">
        <source>ValueTask instances returned from method calls should be directly awaited, returned, or passed as an argument to another method call. Other usage, such as storing an instance into a local or a field, is likely an indication of a bug, as ValueTask instances must only ever be consumed once.</source>
        <target state="translated">Wystąpienia elementu ValueTask zwracane przez wywołania metod powinny być w sposób bezpośredni oczekiwane, zwracane lub przekazywane jako argumenty do wywołania innych metod. Inne użycie, takie jak zapisanie wystąpienia w elemencie lokalnym lub w polu, prawdopodobnie wskazuje na usterkę, ponieważ wystąpienia elementu ValueTask mogą być zawsze używane tylko raz.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_Unconsumed">
        <source>ValueTask instances returned from method calls should always be used, typically awaited. Not doing so often represents a functional bug, but even if it doesn't, it can result in degraded performance if the target method pools objects for use with ValueTasks.</source>
        <target state="translated">Wystąpienia elementów ValueTask zwracane przez wywołania metod powinny zawsze zostać użyte, zazwyczaj przez oczekiwanie. Jeśli tak się nie dzieje, często oznacza to usterkę funkcjonalną, ale nawet jeśli usterka nie występuje, może to spowodować obniżenie wydajności, jeśli metoda docelowa grupuje obiekty w pule do użycia za pomocą elementów ValueTask.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyTitle">
        <source>Use ValueTasks correctly</source>
        <target state="translated">Użyj elementów ValueTask poprawnie</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">Przetwarzanie pliku XML na podstawie niezaufanych danych może spowodować załadowanie niebezpiecznych odwołań zewnętrznych, które powinny zostać ograniczone za pomocą czytnika XmlReader z bezpiecznym programem rozpoznawania nazw lub wyłączonym przetwarzaniem elementów DTD.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader for 'DataSet.ReadXml()'</source>
        <target state="translated">Użyj elementu XmlReader dla metody „DataSet.ReadXml()”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader for 'XmlSerializer.Deserialize()'</source>
        <target state="translated">Użyj elementu XmlReader dla metody „XmlSerializer.Deserialize()”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader for 'XmlSchema.Read()'</source>
        <target state="translated">Użyj elementu XmlReader dla metody „XmlSchema.Read()”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader for XmlValidatingReader constructor</source>
        <target state="translated">Użyj elementu XmlReader dla konstruktora XmlValidatingReader</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader for XPathDocument constructor</source>
        <target state="translated">Użyj elementu XmlReader dla konstruktora XPathDocument</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the '{0}.{1}' method is potentially unsafe. It may enable Document Type Definition (DTD) which can be vulnerable to denial of service attacks, or might use an XmlResolver which can be vulnerable to information disclosure. Use an overload that takes a XmlReader instance instead, with DTD processing disabled and no XmlResolver.</source>
        <target state="translated">To przeciążenie metody „{0}.{1}” jest potencjalnie niebezpieczne. Być może włącza definicję typu dokumentu podatną na ataki typu „odmowa usługi” lub używa elementu XmlResolver podatnego na ujawnienie informacji. Użyj zamiast tego przeciążenia, które przyjmuje wystąpienie elementu XmlReader, ma wyłączone przetwarzanie definicji typu dokumentu i nie używa elementu XmlResolver.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsesPreviewTypeParameterMessage">
        <source>'{0}' uses the preview type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">„{0}” używa typu w wersji zapoznawczej „{1}” i wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsesPreviewTypeParameterMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' uses the preview type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} „{0}” używa typu w wersji zapoznawczej „{1}” i wymaga wyrażenia zgody na korzystanie z funkcji w wersji zapoznawczej. Aby uzyskać więcej informacji, zobacz {2}.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>