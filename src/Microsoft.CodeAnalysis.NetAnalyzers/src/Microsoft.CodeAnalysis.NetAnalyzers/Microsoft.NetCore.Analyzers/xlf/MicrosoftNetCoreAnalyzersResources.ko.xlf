<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../MicrosoftNetCoreAnalyzersResources.resx">
    <body>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">이 필드에 'NonSerialized' 특성을 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">Serializable 특성 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherMode">
        <source>Review cipher mode usage with cryptography experts</source>
        <target state="translated">암호화 전문가와 암호화 모드 사용 현황 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These cipher modes might be vulnerable to attacks. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">이 암호화 모드는 공격에 취약할 수 있습니다. 권장 모드(CBC, CTS)를 사용하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>Review the usage of cipher mode '{0}' with cryptography experts. Consider using recommended modes (CBC, CTS).</source>
        <target state="translated">암호화 전문가와 암호화 모드 '{0}'의 사용 현황을 검토합니다. 권장 모드(CBC, CTS)를 사용하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">특성의 문자열 리터럴 매개 변수가 URL, GUID 또는 버전에 대해 올바르게 구문 분석되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'</source>
        <target state="translated">'{0}'의 생성자에서 현재 "{2}"인 '{1}' 인수 값을 '{3}'(으)로 올바르게 구문 분석될 수 있는 다른 값으로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'</source>
        <target state="translated">'{0}'의 생성자에서 현재 빈 문자열("")인 '{1}' 인수 값을 '{2}'(으)로 올바르게 구문 분석될 수 있는 다른 값으로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">특성 문자열 리터럴이 올바르게 구문 분석되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidConstArraysCodeFixTitle">
        <source>Extract to static readonly field</source>
        <target state="translated">정적 읽기 전용 필드로 추출</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidConstArraysDescription">
        <source>Constant arrays passed as arguments are not reused when called repeatedly, which implies a new array is created each time. Consider extracting them to 'static readonly' fields to improve performance if the passed array is not mutated within the called method.</source>
        <target state="translated">인수로 전달된 상수 배열은 반복적으로 호출될 때 다시 사용되지 않으며, 이는 매번 새 배열이 생성됨을 의미합니다. 전달된 배열이 호출된 메서드 내에서 변경되지 않은 경우 'static readonly' 필드에 추출하여 성능을 향상하는 것이 좋습니다.</target>
        <note>{Locked="static readonly"}</note>
      </trans-unit>
      <trans-unit id="AvoidConstArraysMessage">
        <source>Prefer 'static readonly' fields over constant array arguments if the called method is called repeatedly and is not mutating the passed array</source>
        <target state="translated">호출된 메서드가 반복적으로 호출되고 전달된 배열을 변경하지 않는 경우 상수 배열 인수보다 'static readonly' 필드를 사용하세요.</target>
        <note>{Locked="static readonly"}</note>
      </trans-unit>
      <trans-unit id="AvoidConstArraysTitle">
        <source>Avoid constant arrays as arguments</source>
        <target state="translated">상수 배열을 인수로 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingDescription">
        <source>In many situations, logging is disabled or set to a log level that results in an unnecessary evaluation for this argument.</source>
        <target state="translated">많은 상황에서 로깅이 비활성화되거나 이 인수에 대해 불필요한 평가가 발생하는 로그 수준으로 설정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingMessage">
        <source>Evaluation of this argument may be expensive and unnecessary if logging is disabled</source>
        <target state="translated">로깅이 비활성화되면 이 인수를 평가하는 데 비용이 많이 들고 불필요할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPotentiallyExpensiveCallWhenLoggingTitle">
        <source>Avoid potentially expensive logging</source>
        <target state="translated">비용이 많이 드는 로깅을 피하세요</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsDescription">
        <source>Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead. Single use 'JsonSerializerOptions' instances can substantially degrade the performance of your application.</source>
        <target state="translated">모든 직렬화 작업에 대해 새 'JsonSerializerOptions' 인스턴스를 만들지 마세요. 대신 인스턴스를 캐시하고 다시 사용합니다. 단일 사용 'JsonSerializerOptions' 인스턴스는 애플리케이션의 성능을 크게 저하시킬 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsMessage">
        <source>Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead.</source>
        <target state="translated">모든 직렬화 작업에 대해 새 'JsonSerializerOptions' 인스턴스를 만들지 마세요. 대신 인스턴스를 캐시하고 다시 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidSingleUseOfLocalJsonSerializerOptionsTitle">
        <source>Cache and reuse 'JsonSerializerOptions' instances</source>
        <target state="translated">'JsonSerializerOptions' 인스턴스 캐시 및 다시 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersDescription">
        <source>Marshalling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshalling operation.</source>
        <target state="translated">'StringBuilder'를 마샬링하는 경우 항상 네이티브 버퍼 복사본이 만들어지므로 하나의 마샬링 작업에 대해 할당이 여러 번 이루어집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersMessage">
        <source>Avoid 'StringBuilder' parameters for P/Invokes. Consider using a character buffer instead.</source>
        <target state="translated">P/Invokes에는 'StringBuilder' 매개 변수를 사용하지 마세요. 대신 문자 버퍼를 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidStringBuilderPInvokeParametersTitle">
        <source>Avoid 'StringBuilder' parameters for P/Invokes</source>
        <target state="translated">P/Invokes에는 'StringBuilder' 매개 변수를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadCodeFixTitle">
        <source>Use 'Stream.ReadExactly'</source>
        <target state="translated">'Stream.ReadExactly' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadDescription">
        <source>A call to 'Stream.Read' may return fewer bytes than requested, resulting in unreliable code if the return value is not checked.</source>
        <target state="translated">'Stream.Read'에 대한 호출은 요청된 바이트보다 적은 바이트를 반환할 수 있으므로 반환 값을 확인하지 않으면 신뢰할 수 없는 코드가 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadMessage">
        <source>Avoid inexact read with '{0}'</source>
        <target state="translated">‘{0}’(으)로 부정확한 읽기 방지</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnreliableStreamReadTitle">
        <source>Avoid inexact read with 'Stream.Read'</source>
        <target state="translated">'Stream.Read'로 부정확한 읽기 방지</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">.NET Framework 클래스 라이브러리에서 사용자 지정 특성을 검색하기 위한 메서드를 제공합니다. 기본적으로 이 메서드는 특성 상속 계층 구조를 검색합니다. 특성을 봉인하면 상속 계층 구조를 통한 검색을 중단하여 성능을 향상시킬 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">봉인되지 않은 특성을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">봉인되지 않은 특성을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">길이가 0인 불필요한 배열 할당을 사용하지 마세요.  대신 {0}을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations</source>
        <target state="translated">길이가 0인 배열 할당을 사용하면 안 됨</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">역직렬화된 개체 그래프에서 개체 형식을 제한하기 위해 SerializationBinder 없이 신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</source>
        <target state="translated">BinaryFormatter.Deserialize를 호출하기 전에 BinaryFormatter.Binder를 설정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">역직렬화된 개체 그래프에서 개체 형식을 제한하기 위해 SerializationBinder 없이 신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterDeserializeWithoutBinderSetTitle">
        <source>Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</source>
        <target state="translated">먼저 BinaryFormatter.Binder를 설정하지 않고 BinaryFormatter.Deserialize를 호출하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect BinaryFormatter deserialization without a SerializationBinder set, then disable rule CA2300, and enable rules CA2301 and CA2302.</source>
        <target state="translated">신뢰할 수 없는 데이터를 deserialize할 경우 '{0}' 메서드는 안전하지 않습니다. SerializationBinder를 설정하지 않고 BinaryFormatter deserialization을 검색해야 하는 경우에는 규칙 CA2300을 사용하지 않도록 설정하고 규칙 CA2301 및 CA2302를 사용하도록 설정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">신뢰할 수 없는 데이터를 deserialize하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer BinaryFormatter</source>
        <target state="translated">안전하지 않은 역직렬 변환기 BinaryFormatter를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyDescription">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.</source>
        <target state="translated">'Buffer.BlockCopy'는 'count' 인수에 대해 복사할 바이트 수를 예상합니다. 'Array.Length'를 사용하면 복사해야 하는 바이트 수가 일치하지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyLengthMessage">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.</source>
        <target state="translated">'Buffer.BlockCopy'는 'count' 인수에 대해 복사할 바이트 수를 예상합니다. 'Array.Length'를 사용하면 복사해야 하는 바이트 수가 일치하지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferBlockCopyLengthTitle">
        <source>'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument</source>
        <target state="translated">'Buffer.BlockCopy'는 'count' 인수에 대해 복사할 바이트 수를 예상합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).</source>
        <target state="translated">Dispose를 구현하는 메서드가 GC.SuppressFinalize를 호출하지 않거나, Dispose를 구현하지 않는 메서드가 GC.SuppressFinalize를 호출하거나, 메서드가 GC.SuppressFinalize를 호출하고 다른 개체(Visual Basic의 경우 Me)를 전달합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">{0}을(를) 변경하여 {1}을(를) 호출하세요. 이렇게 하면 종료자를 사용하는 파생 형식에서 'IDisposable'을 호출하기 위해 다시 구현하지 않아도 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">{0}을(를) 변경하여 {1}을(를) 호출하세요. 이렇게 하면 개체가 삭제되어 범위 외부로 이동된 후에 불필요하게 종료되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">{0}이(가) 자기 자신이 아닌 다른 개체에서 {1}을(를) 호출합니다. 대신 호출 사이트를 변경하여 'this'(Visual Basic의 경우 'Me')를 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">{0}이(가) 일반적으로 'IDisposable.Dispose'의 구현 내에서만 호출되는 메서드인 {1}을(를) 호출합니다. 자세한 내용은 IDisposable 패턴을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">Dispose 메서드는 SuppressFinalize를 호출해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommaSeparator">
        <source>, </source>
        <target state="translated">, </target>
        <note>Separator used for separating list of platform names: {API} is only supported on: {‘windows’, ‘browser’, ‘linux’}</note>
      </trans-unit>
      <trans-unit id="ConstantExpectedApplicationDescription">
        <source>ConstantExpected attribute is not applied correctly on the parameter.</source>
        <target state="translated">ConstantExpected 특성이 매개 변수에 올바르게 적용되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedApplicationTitle">
        <source>Incorrect usage of ConstantExpected attribute</source>
        <target state="translated">ConstantExpected 특성의 사용이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedAttributExpectedMessage">
        <source>The ConstantExpected attribute is required for the parameter due to the parent method annotation</source>
        <target state="translated">부모 메서드 주석으로 인해 매개 변수에 ConstantExpected 특성이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedIncompatibleConstantTypeMessage">
        <source>The '{0}' value is not compatible with parameter type of '{1}'</source>
        <target state="translated">'{0}' 값이 '{1}' 매개 변수 형식과 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvalidBoundsMessage">
        <source>The '{0}' value does not fit within the parameter value bounds of '{1}' to '{2}'</source>
        <target state="translated">'{0}' 값이 '{1}'에서 '{2}'까지 매개 변수 값 범위 내에 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvalidMessage">
        <source>The constant is not of the same '{0}' type as the parameter</source>
        <target state="translated">상수가 매개 변수와 동일한 '{0}' 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedInvertedRangeMessage">
        <source>The Min and Max values are inverted</source>
        <target state="translated">최소 및 최대값이 반전됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedNotConstantMessage">
        <source>The argument should be a constant for optimal performance</source>
        <target state="translated">최적의 성능을 위해 인수는 상수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedNotSupportedMessage">
        <source>The '{0}' type is not supported for ConstantExpected attribute</source>
        <target state="translated">ConstantExpected 특성에는 '{0}' 형식이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedOutOfBoundsMessage">
        <source>The constant does not fit within the value bounds of '{0}' to '{1}'</source>
        <target state="translated">상수가 '{0}'에서 '{1}'까지 값 범위 내에 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedUsageDescription">
        <source>The parameter expects a constant for optimal performance.</source>
        <target state="translated">매개 변수에는 최적의 성능을 위해 상수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstantExpectedUsageTitle">
        <source>A constant is expected for the parameter</source>
        <target state="translated">매개 변수에 상수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">신뢰할 수 없는 입력을 역직렬화하는 경우 {0} 개체를 역직렬화하는 것은 안전하지 않습니다. '{1}'은(는) {0}이거나 이 항목에서 파생됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type found in deserializable object graph</source>
        <target state="translated">역직렬화 가능한 개체 그래프에서 안전하지 않은 DataSet 또는 DataTable 형식을 찾음</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}. Ensure that the auto-generated type is never deserialized with untrusted data.</source>
        <target state="translated">IFormatter 기반 직렬 변환기를 사용하여 신뢰할 수 없는 입력을 역직렬화하는 경우 {0} 개체를 역직렬화하는 것은 안전하지 않습니다. '{1}'은(는) {0}이거나 이 항목에서 파생됩니다. 자동 생성된 형식이 신뢰할 수 없는 데이터로 역직렬화되지 않도록 하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceAutogeneratedSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in auto-generated serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">자동 생성된 직렬화 가능한 형식의 안전하지 않은 DataSet 또는 DataTable은 원격 코드 실행 공격에 취약할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">신뢰할 수 없는 입력을 역직렬화하는 경우 {0} 개체를 역직렬화하는 것은 안전하지 않습니다. '{1}'은(는) {0}이거나 이 항목에서 파생됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks</source>
        <target state="translated">역직렬화된 개체 그래프의 안전하지 않은 DataSet 또는 DataTable은 원격 코드 실행 공격에 취약할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeMessage">
        <source>When deserializing untrusted input with an IFormatter-based serializer, deserializing a {0} object is insecure. '{1}' either is or derives from {0}.</source>
        <target state="translated">IFormatter 기반 직렬 변환기를 사용하여 신뢰할 수 없는 입력을 역직렬화하는 경우 {0} 개체를 역직렬화하는 것은 안전하지 않습니다. '{1}'은(는) {0}이거나 이 항목에서 파생됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInRceSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</source>
        <target state="translated">직렬화 가능한 형식의 안전하지 않은 DataSet 또는 DataTable은 원격 코드 실행 공격에 취약할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">신뢰할 수 없는 입력을 역직렬화하는 경우 {0} 개체를 역직렬화하는 것은 안전하지 않습니다. '{1}'은(는) {0}이거나 이 항목에서 파생됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInSerializableTypeTitle">
        <source>Unsafe DataSet or DataTable in serializable type</source>
        <target state="translated">직렬화 가능한 형식의 안전하지 않은 DataSet 또는 DataTable</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphMessage">
        <source>When deserializing untrusted input, deserializing a {0} object is insecure. '{1}' either is or derives from {0}</source>
        <target state="translated">신뢰할 수 없는 입력을 역직렬화하는 경우 {0} 개체를 역직렬화하는 것은 안전하지 않습니다. '{1}'은(는) {0}이거나 이 항목에서 파생됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetDataTableInWebDeserializableObjectGraphTitle">
        <source>Unsafe DataSet or DataTable type in web deserializable object graph</source>
        <target state="translated">웹 역직렬화 가능한 개체 그래프의 안전하지 않은 DataSet 또는 DataTable 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data. Make sure that auto-generated class containing the '{0}' call is not deserialized with untrusted data.</source>
        <target state="translated">신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다. '{0}' 호출을 포함하는 자동 생성된 클래스가 신뢰할 수 없는 데이터로 역직렬화되지 않도록 하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlAutogeneratedTitle">
        <source>Ensure auto-generated class containing DataSet.ReadXml() is not used with untrusted data</source>
        <target state="translated">DataSet.ReadXml()을 포함하는 자동 생성된 클래스가 신뢰할 수 없는 데이터와 함께 사용되지 않는지 확인</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataSetReadXmlTitle">
        <source>Do not use DataSet.ReadXml() with untrusted data</source>
        <target state="translated">DataSet.ReadXml()을 신뢰할 수 없는 데이터와 함께 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data</source>
        <target state="translated">신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataTableReadXmlTitle">
        <source>Do not use DataTable.ReadXml() with untrusted data</source>
        <target state="translated">DataTable.ReadXml()을 신뢰할 수 없는 데이터와 함께 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheck">
        <source>HttpClients should enable certificate revocation list checks</source>
        <target state="translated">HttpClients에서 인증서 해지 목록 확인을 사용하도록 설정해야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyDisableHttpClientCRLCheckMessage">
        <source>HttpClient is created without enabling CheckCertificateRevocationList</source>
        <target state="translated">CheckCertificateRevocationList를 사용하지 않고 HttpClient가 생성됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="translated">루트 저장소에 인증서 추가 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="translated">운영 체제의 신뢰할 수 있는 루트 인증서에 인증서를 추가하면 불법 인증서를 잘못 인증하게 될 위험이 늘어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIV">
        <source>Do not use CreateEncryptor with non-default IV</source>
        <target state="translated">기본이 아닌 IV와 함께 CreateEncryptor 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseCreateEncryptorWithNonDefaultIVMessage">
        <source>Symmetric encryption uses non-default initialization vector, which could be potentially repeatable</source>
        <target state="translated">대칭형 암호화는 잠재적으로 반복할 수 있는, 기본이 아닌 초기화 벡터를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">ASP.NET Core에서 보안 쿠키 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">쿠키를 설정할 때 CookieOptions.Secure = true를 설정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCount">
        <source>Do Not Use Weak Key Derivation Function With Insufficient Iteration Count</source>
        <target state="translated">부족한 반복 횟수로 취약한 키 파생 함수를 사용하면 안 됨</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCountMessage">
        <source>Use at least {0} iterations when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">암호에서 암호화 키를 파생할 때 {0}회 이상의 반복을 사용하세요. 기본적으로 Rfc2898DeriveByte의 IterationCount는 1,000뿐입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsDescription">
        <source>Older protocol versions of Transport Layer Security (TLS) are less secure than TLS 1.2 and TLS 1.3, and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk.</source>
        <target state="translated">TLS(전송 계층 보안)의 이전 프로토콜 버전은 TLS 1.2 및 TLS 1.3보다 보안 수준이 낮으며 새로운 취약성이 발생할 가능성이 더 높습니다. 위험을 최소화하려면 이전 프로토콜 버전을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsMessage">
        <source>Transport Layer Security protocol version '{0}' is deprecated.  Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">전송 계층 보안 프로토콜 버전 '{0}'은(는) 사용되지 않습니다. 운영 체제에서 버전을 선택하도록 하려면 '없음'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeprecatedSslProtocolsTitle">
        <source>Do not use deprecated SslProtocols values</source>
        <target state="translated">사용되지 않는 SslProtocols 값 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivesFromPreviewClassMessage">
        <source>'{0}' derives from preview class '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}'은(는) 미리 보기 클래스 '{1}'에서 파생되므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivesFromPreviewClassMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' derives from preview class '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}'은(는) 미리 보기 클래스 '{1}'에서 파생되므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesDescription">
        <source>An assembly has to opt into preview features before using them.</source>
        <target state="translated">어셈블리는 기능을 사용하기 전에 미리 보기 기능을 선택해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesMessage">
        <source>Using '{0}' requires opting into preview features. See {1} for more information.</source>
        <target state="translated">'{0}'을(를) 사용하려면 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {1}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesMessageWithCustomMessagePlaceholder">
        <source>{2} Using '{0}' requires opting into preview features. See {1} for more information.</source>
        <target state="translated">{2} '{0}'을(를) 사용하려면 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {1}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DetectPreviewFeaturesTitle">
        <source>This API requires opting into preview features</source>
        <target state="translated">이 API는 미리 보기 기능을 선택해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">System.IDisposable을 구현하는 형식은 IDisposable도 구현하는 형식의 필드를 선언합니다. 필드의 Dispose 메서드는 선언 형식의 Dispose 메서드에 의해 호출되지 않습니다. 이 규칙 위반 문제를 해결하려면 필드에 포함되는 비관리형 리소스를 할당 및 해제해야 하는 경우 IDisposable을 구현하는 형식의 필드에서 Dispose를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>'{0}' contains field '{1}' that is of IDisposable type '{2}', but it is never disposed. Change the Dispose method on '{0}' to call Close or Dispose on this field.</source>
        <target state="translated">'{0}'에는 IDisposable 형식 '{2}'의 '{1}' 필드가 포함되지만, 삭제되지는 않습니다. 이 필드에서 Close 또는 Dispose를 호출하려면 '{0}'에서 Dispose 메서드를 변경합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">삭제 가능한 필드는 삭제해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">System.IDisposable을 구현하며, 관리되지 않는 리소스를 사용하도록 제안하는 필드가 있는 형식은 Object.Finalize에 설명된 대로 종료자를 구현하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">삭제 가능한 형식에서 종료자를 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">삭제 가능한 형식에서 종료자를 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.</source>
        <target state="translated">System.IDisposable을 구현하는 형식은 IDisposable도 구현하는 형식에서 상속됩니다. 상속 형식의 Dispose 메서드는 부모 형식의 Dispose 메서드를 호출하지 않습니다. 이 규칙 위반 문제를 해결하려면 Dispose 메서드에서 base.Dispose를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Ensure that method '{0}' calls '{1}' in all possible control flow paths</source>
        <target state="translated">'{0}' 메서드가 모든 가능한 제어 흐름 경로에서 '{1}'을(를) 호출하도록 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose methods should call base class dispose</source>
        <target state="translated">Dispose 메서드는 기본 클래스 Dispose를 호출해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</source>
        <target state="translated">삭제 가능한 개체에 대한 모든 참조가 범위를 벗어나기 전에 삭제 가능한 개체가 명시적으로 삭제되지 않으면 가비지 수집기가 개체의 종료자를 실행할 때 비활성화 시점에서 개체가 삭제됩니다. 개체 종료자의 실행을 방지하는 예외적인 이벤트가 발생할 수 있으므로 대신 개체를 명시적으로 삭제해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">권장 dispose 패턴을 사용하여 '{0}'에서 생성된 개체가 모든 경로에서 삭제되도록 합니다. 가능한 경우 'using' 문이나 'using' 선언 내에서 생성을 래핑합니다. 그렇지 않으면 try 영역 앞에 선언된 전용 지역 변수 및 'finally' 영역에 있는 null이 아닌 값의 비조건부 Dispose 호출('x?.Dispose()')과 함께 try-finally 패턴을 사용하세요. 개체가 try 영역 내에서 명시적으로 삭제되거나 삭제 소유권이 다른 개체나 메서드로 이전되면 해당 작업 바로 뒤의 지역 변수에 'null'을 할당하여 'finally'에서 이중 삭제를 방지하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all exception paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">권장 dispose 패턴을 사용하여 '{0}'에서 생성된 개체가 모든 예외 경로에서 삭제되도록 합니다. 가능한 경우 'using' 문이나 'using' 선언 내에서 생성을 래핑합니다. 그렇지 않으면 try 영역 앞에 선언된 전용 지역 변수 및 'finally' 영역에 있는 null이 아닌 값의 비조건부 Dispose 호출('x?.Dispose()')과 함께 try-finally 패턴을 사용하세요. 개체가 try 영역 내에서 명시적으로 삭제되거나 삭제 소유권이 다른 개체나 메서드로 이전되면 해당 작업 바로 뒤의 지역 변수에 'null'을 할당하여 'finally'에서 이중 삭제를 방지하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedMessage">
        <source>Call System.IDisposable.Dispose on object created by '{0}' before all references to it are out of scope</source>
        <target state="translated">'{0}'에서 생성된 개체에 대한 모든 참조가 범위를 벗어나기 전에 해당 개체에서 System.IDisposable.Dispose를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage">
        <source>Object created by '{0}' is not disposed along all exception paths. Call System.IDisposable.Dispose on the object before all references to it are out of scope.</source>
        <target state="translated">'{0}'에서 생성된 개체는 일부 예외 경로와 함께 삭제되지 않습니다. 개체에 대한 모든 참조가 범위를 벗어나기 전에 해당 개체에서 System.IDisposable.Dispose를 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose objects before losing scope</source>
        <target state="translated">범위를 벗어나기 전에 개체를 삭제하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPath">
        <source>Do Not Add Archive Item's Path To The Target File System Path</source>
        <target state="translated">대상 파일 시스템 경로에 아카이브 항목 경로 추가 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription">
        <source>When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</source>
        <target state="translated">아카이브에서 파일을 추출하고 아카이브 항목 경로를 사용할 때 경로가 안전한지 확인합니다. 아카이브 경로는 상대적일 수 있고 예상 파일 시스템 대상 경로 밖의 파일 시스템 액세스를 초래하여 lay-and-wait 기법을 통해 악의적으로 구성이 변경되고 원격 코드 실행이 이루어질 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage">
        <source>When creating path for '{0} in method {1}' from relative archive item path to extract file and the source is an untrusted zip archive, make sure to sanitize relative archive item path '{2} in method {3}'</source>
        <target state="translated">파일을 추출하기 위해 상대 아카이브 항목 경로에서 '메서드 {1}의 {0}' 경로를 만들 때 소스가 신뢰할 수 없는 zip 아카이브인 경우 상대 아카이브 항목 경로 '메서드 {3}의 {2}'을(를) 삭제해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">URL로 스키마를 추가하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">XmlSchemaCollection.Add 메서드의 이 오버로드는 사용되는 XML 판독기에서 내부적으로 DTD 처리를 사용하도록 설정하고 UrlResolver를 사용하여 외부 XML 엔터티를 확인합니다. 결과는 정보 공개입니다. XML을 처리하는 머신에 대한 파일 시스템 또는 네트워크 공유의 콘텐츠가 공격자에게 공개될 수 있습니다. 또한 공격자가 이 취약성을 DoS 벡터로 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">Add 메서드의 이 오버로드는 위험한 외부 참조를 확인할 수 있으므로 잠재적으로 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesDescription">
        <source>By setting critical TokenValidationParameter validation delegates to true, important authentication safeguards are disabled which can lead to tokens from any issuer or expired tokens being wrongly validated.</source>
        <target state="translated">중요한 TokenValidationParameter 유효성 검사 대리자를 true로 설정하면 발급자의 토큰이나 만료된 토큰의 유효성이 잘못 검사될 수 있는 중요한 인증 보호 장치가 비활성화됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesMessage">
        <source>The {0} is set to a function that is always returning true. By setting the validation delegate, you are overriding default validation and by always returning true, this validation is completely disabled.</source>
        <target state="translated">{0}은(는) 항상 true를 반환하는 함수로 설정됩니다. 유효성 검사 대리자를 설정하면 기본 유효성 검사를 무시하고, 항상 true를 반환하면 이 유효성 검사가 완전히 비활성화됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAlwaysSkipTokenValidationInDelegatesTitle">
        <source>Do not always skip token validation in delegates</source>
        <target state="translated">대리자에서 토큰 유효성 검사를 항상 건너뛰지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">안전하지 않은 deserialization은 트러스트되지 않은 데이터를 사용하여 애플리케이션 논리를 남용할 때 발생하는 취약성이고, DoS(서비스 거부) 공격을 가하거나 deserialize될 때 임의의 코드를 실행하기도 합니다. 종종 악의적인 사용자가 제어하는 트리스트되지 않은 데이터를 애플리케이션에서 deserialize할 때 이러한 deserialization 기능을 사용할 수 있습니다. 특히 deserialization 과정에 위험한 메서드를 호출합니다. 안전하지 않은 deserialization 공격이 성공하면 공격자가 DoS 공격, 인증 건너뜀 및 원격 코드 실행과 같은 공격을 수행할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class '{0}', method '{1}' can directly or indirectly call dangerous method '{2}'</source>
        <target state="translated">클래스 '{0}'의 인스턴스를 역직렬화할 때 '{1}' 메서드가 위험한 메서드 '{2}'을(를) 직접 또는 간접적으로 호출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationTitle">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">역직렬화에서 위험한 메서드를 호출하면 안 됨</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesDescription">
        <source>Enumerable.Cast&lt;T&gt; and Enumerable.OfType&lt;T&gt; require compatible types to function expectedly.  
The generic cast (IL 'unbox.any') used by the sequence returned by Enumerable.Cast&lt;T&gt; will throw InvalidCastException at runtime on elements of the types specified.  
The generic type check (C# 'is' operator/IL 'isinst') used by Enumerable.OfType&lt;T&gt; will never succeed with elements of types specified, resulting in an empty sequence.  
Widening and user defined conversions are not supported with generic types.</source>
        <target state="translated">Enumerable.Cast&lt;T&gt; 및 Enumerable.OfType&lt;T&gt;가 제대로 작동하려면 호환되는 형식이 필요합니다.  
Enumerable.Cast&lt;T&gt;에서 반환된 시퀀스에서 사용하는 일반 캐스트(IL 'unbox.any')는 지정된 형식의 요소에서 런타임에 InvalidCastException을 발생시킵니다.  
Enumerable.OfType&lt;T&gt;에서 사용하는 제네릭 형식 검사(C# 'is' 연산자/IL 'isinst')는 지정된 형식의 요소로 성공하지 못하여 결과적으로 빈 시퀀스가 됩니다.  
확대 및 사용자 정의 변환은 일반 형식에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageCast">
        <source>Type '{0}' is incompatible with type '{1}' and cast attempts will throw InvalidCastException at runtime</source>
        <target state="translated">형식 '{0}'은(는) 형식 '{1}'과(와) 호환되지 않으며 캐스트 시도에서 런타임에 InvalidCastException이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageOfType">
        <source>This call will always result in an empty sequence because type '{0}' is incompatible with type '{1}'</source>
        <target state="translated">형식 '{0}'이(가) 형식 '{1}'과(와) 호환되지 않기 때문에 이 호출은 항상 빈 시퀀스를 생성합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesTitle">
        <source>Do not call Enumerable.Cast&lt;T&gt; or Enumerable.OfType&lt;T&gt; with incompatible types</source>
        <target state="translated">호환되지 않는 형식으로 Enumerable.Cast&lt;T&gt; 또는 Enumerable.OfType&lt;T&gt;를 호출하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueMessage">
        <source>Do not call {0} on an {1} value</source>
        <target state="translated">{1} 값의 {0}을(를) 호출하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallToImmutableCollectionOnAnImmutableCollectionValueTitle">
        <source>Do not call ToImmutableCollection on an ImmutableCollection value</source>
        <target state="translated">ImmutableCollection 값의 ToImmutableCollection을 호출하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToDefaultMessage">
        <source>Comparing a span to 'default' might not do what you intended, make the code more explicit by checking 'IsEmpty'</source>
        <target state="translated">범위를 'default'로 비교해도 의도한 대로 수행되지 않을 수 있습니다. 'IsEmpty'를 확인하여 코드를 더 명시적으로 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullIsEmptyCodeFixTitle">
        <source>Use 'IsEmpty'</source>
        <target state="translated">'IsEmpty' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullMessage">
        <source>Comparing a span to 'null' might be redundant, the 'null' literal will be implicitly converted to a 'Span&lt;T&gt;.Empty'</source>
        <target state="translated">범위를 'null'에 비교하면 중복될 수 있습니다. 'null' 리터럴은 암시적으로 'Span&lt;T&gt;.Empty'로 변환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullOrDefaultDescription">
        <source>Comparing a span to 'null' or 'default' might not do what you intended. 'default' and the 'null' literal are implicitly converted to 'Span&lt;T&gt;.Empty'. Remove the redundant comparison or make the code more explicit by using 'IsEmpty'.</source>
        <target state="translated">범위를 'null' 또는 'default'에 비교해도 의도한 대로 수행되지 않을 수 있습니다. 'default'와 'null' 리터럴은 암시적으로 'Span&lt;T&gt;.Empty'로 변환됩니다. 중복 비교를 제거하거나 'IsEmpty'를 사용하여 코드를 더 명시적으로 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCompareSpanToNullOrDefaultTitle">
        <source>Do not compare Span&lt;T&gt; to 'null' or 'default'</source>
        <target state="translated">Span&lt;T&gt;을(를) 'null' 또는 'default'와 비교하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsDescription">
        <source>TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.  Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</source>
        <target state="translated">TaskCompletionSource에는 기본 작업을 제어하는 TaskCreationOptions를 사용하는 생성자와 이 작업에 저장된 상태 개체를 사용하는 생성자가 있습니다.  실수로 TaskCreationOptions 대신 TaskContinuationOptions를 전달하면 이 옵션을 상태로 처리하는 호출이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsFix">
        <source>Replace TaskContinuationOptions with TaskCreationOptions.</source>
        <target state="translated">TaskContinuationOptions를 TaskCreationOptions로 대체합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsMessage">
        <source>Argument contains TaskContinuationsOptions enum instead of TaskCreationOptions enum</source>
        <target state="translated">인수에 TaskCreationOptions 열거형이 아닌 TaskContinuationsOptions 열거형이 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTaskCompletionSourceWithWrongArgumentsTitle">
        <source>Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</source>
        <target state="translated">TaskCompletionSource 생성자로 전달된 인수는 TaskContinuationOptions 열거형이 아닌 TaskCreationOptions 열거형이어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerDescription">
        <source>Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear.</source>
        <target state="translated">TaskScheduler를 사용하는 오버로드 중 하나를 사용하지 않는 경우 작업을 만들지 마세요. 기본값은 TaskScheduler.Current에 예약하는 것이며 이는 교착 상태를 유발할 수 있습니다. 원하는 결과를 얻으려면 스레드 풀에서 TaskScheduler.Default를 사용하여 예약하거나 TaskScheduler.Current를 명시적으로 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerMessage">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">TaskScheduler를 전달하지 않은 상태에서 작업을 만들지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCreateTasksWithoutPassingATaskSchedulerTitle">
        <source>Do not create tasks without passing a TaskScheduler</source>
        <target state="translated">TaskScheduler를 전달하지 않은 상태에서 작업을 만들지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerDescription">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;.</source>
        <target state="translated">MemoryManager&lt;T&gt;에서 파생된 형식에 종료자를 추가하면 Span&lt;T&gt;에서 여전히 메모리를 사용하는 동안 메모리 해제가 허용될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerMessage">
        <source>Adding a finalizer to a type derived from MemoryManager&lt;T&gt; may permit memory to be freed while it is still in use by a Span&lt;T&gt;</source>
        <target state="translated">MemoryManager&lt;T&gt;에서 파생된 형식에 종료자를 추가하면 Span&lt;T&gt;에서 계속 메모리를 사용하는 동안 메모리 해제가 허용될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDefineFinalizersForTypesDerivedFromMemoryManagerTitle">
        <source>Do not define finalizers for types derived from MemoryManager&lt;T&gt;</source>
        <target state="translated">MemoryManager&lt;T&gt;에서 파생된 형식에 대한 종료자 정의 금지</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">인증서 유효성 검사를 비활성화하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">인증서는 서버의 ID를 인증하는 데 도움이 될 수 있습니다. 클라이언트가 요청을 원하는 서버에 보내려면 서버 인증서의 유효성을 검사해야 합니다. ServerCertificateValidationCallback이 항상 'true'를 반환하는 경우 모든 인증서가 유효성 검사를 통과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">ServerCertificateValidationCallback은 항상 true를 반환하여 서버 인증서를 허용하는 함수로 설정되어 있습니다. 서버 인증서의 유효성을 검사하여 요청을 받는 서버의 ID를 확인해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">HTTP 헤더 검사를 사용하지 않도록 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">HTTP 헤더 검사를 사용하면 응답 헤더에 있는 캐리지 리턴 및 줄 바꿈 문자 \r 및 \n을 인코딩할 수 있습니다. 이 인코딩을 수행하면 헤더에 포함된 신뢰할 수 없는 데이터를 에코하는 애플리케이션을 악용하는 삽입 공격을 방지할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">HTTP 헤더 검사를 사용하지 않도록 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHttpClientCRLCheckDescription">
        <source>Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid.</source>
        <target state="translated">CheckCertificateRevocationList 속성이 true로 설정된 플랫폼별 처리기(WinHttpHandler 또는 CurlHandler 또는 HttpClientHandler)를 제공하지 않고 HttpClient를 사용하면 해지된 인증서를 HttpClient에서 유효한 것으로 사용할 수 있도록 허용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">요청 유효성 검사를 사용하지 않도록 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">요청 유효성 검사는 HTTP 요청을 검사하고 잠재적으로 위험한 콘텐츠가 포함되는지 확인하는 ASP.NET 기능입니다. 이 검사는 악의적인 목적으로 추가되었을 수 있는 URL 쿼리 문자열, 쿠키 또는 게시된 양식 값에 있는 태그 또는 코드에서 보호를 추가합니다. 따라서 일반적으로 이 검사를 수행하는 것이 좋고 심층 방어를 위해 사용하도록 설정해 두어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">{0}에서 요청 유효성 검사가 사용하지 않도록 설정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">SChannel의 강력한 암호화 사용을 비활성화하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommended to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">.NET Framework 4.6부터 System.Net.ServicePointManager 및 System.Net.Security.SslStream 클래스는 새 프로토콜을 사용하는 것이 좋습니다. 프로토콜 약점이 있는 기존 클래스는 지원되지 않습니다. Switch.System.Net.DontEnableSchUseStrongCrypto를 true로 설정하면 이전의 취약한 암호화 검사를 사용하여 프로토콜 마이그레이션을 옵트아웃합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">{0}이(가) TLS 1.2를 사용하지 않도록, SSLv3를 사용하도록 설정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksDescription">
        <source>Token validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation.</source>
        <target state="translated">토큰 유효성 검사는 토큰 유효성을 검사하는 동안 모든 측면이 분석되고 확인되도록 합니다. 유효성 검사를 끄면 신뢰할 수 없는 토큰이 유효성 검사를 통과하도록 허용하여 보안 허점이 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksMessage">
        <source>TokenValidationParameters.{0} should not be set to false as it disables important validation</source>
        <target state="translated">TokenValidationParameters.{0}은(는) 중요한 유효성 검사를 비활성화하므로 false로 설정하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableTokenValidationChecksTitle">
        <source>Do not disable token validation checks</source>
        <target state="translated">토큰 유효성 검사를 비활성화하지 마세요</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsMessage">
        <source>Do not set Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols to true.  Setting this switch limits Windows Communication Framework (WCF) to using Transport Layer Security (TLS) 1.0, which is insecure and obsolete.</source>
        <target state="translated">Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols를 true로 설정하지 마세요. 이 스위치를 설정하면 WCF(Windows Communication Framework)가 안전하지 않고 사용되지 않는 TLS(전송 계층 보안) 1.0을 사용하도록 제한됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableUsingServicePointManagerSecurityProtocolsTitle">
        <source>Do not disable ServicePointManagerSecurityProtocols</source>
        <target state="translated">ServicePointManagerSecurityProtocols를 사용하지 않도록 설정 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyDescription">
        <source>Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'. The former already checks whether the key exists, and will not throw if it does not.</source>
        <target state="translated">'Dictionary.ContainsKey(key)'를 사용하여 'Dictionary.Remove(key)'를 보호하지 마세요. 전자는 키가 있는지 여부를 이미 확인하고, 있지 않으면 throw하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyMessage">
        <source>Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'</source>
        <target state="translated">'Dictionary.ContainsKey(key)'를 사용하여 'Dictionary.Remove(key)'를 보호하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardDictionaryRemoveByContainsKeyTitle">
        <source>Unnecessary call to 'Dictionary.ContainsKey(key)'</source>
        <target state="translated">'Dictionary.ContainsKey(key)'에 대한 불필요한 호출</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsDescription">
        <source>Do not guard 'Add(item)' or 'Remove(item)' with 'Contains(item)' for the set. The former two already check whether the item exists and will return if it was added or removed.</source>
        <target state="translated">세트에 대해 '포함(항목)'으로 '추가(항목)' 또는 '제거(항목)'을 보호하지 마세요. 앞의 두 개는 이미 항목이 존재하는지 확인하고 추가 또는 제거된 경우 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsMessage">
        <source>Do not guard '{0}' with '{1}'</source>
        <target state="translated">'{1}'(으)로 '{0}'을(를) 보호하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotGuardSetAddOrRemoveByContainsTitle">
        <source>Unnecessary call to 'Contains(item)'</source>
        <target state="translated">'Contains(item)'에 대한 불필요한 호출</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificate">
        <source>Do not hard-code certificate</source>
        <target state="translated">인증서 하드 코딩 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateDescription">
        <source>Hard-coded certificates in source code are vulnerable to being exploited.</source>
        <target state="translated">소스 코드의 하드 코딩된 인증서는 악용될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeCertificateMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded certificate from '{2}' in method '{3}'</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 하드 코딩된 인증서에 의해 오염될 수 있는 잠재적인 보안 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKey">
        <source>Do not hard-code encryption key</source>
        <target state="translated">암호화 키 하드 코딩 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyDescription">
        <source>SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hard-coded value.</source>
        <target state="translated">SymmetricAlgorithm의 .Key 속성 또는 메서드의 rgbKey 매개 변수는 하드 코딩된 값이어서는 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHardCodeEncryptionKeyMessage">
        <source>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hard-coded key from '{2}' in method '{3}'</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 하드 코딩된 키에 의해 오염될 수 있는 잠재적인 보안 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="translated">기본적으로 신뢰할 수 있는 루트 인증 기관 인증서 저장소는 Microsoft 루트 인증서 프로그램의 요구 사항을 준수하는 공용 CA 세트로 구성됩니다. 모든 신뢰할 수 있는 루트 CA는 모든 도메인에 대한 인증서를 발급할 수 있으므로 공격자는 사용자가 직접 설치한 약하거나 강제할 수 있는 CA를 선택하여 공격 대상으로 지정할 수 있으며, 취약하거나 악의적이거나 강제할 수 있는 CA 하나가 전체 시스템의 보안을 약화시킵니다. 설상가상으로 이러한 공격자는 상당히 쉽게 눈에 띄지 않고 넘어갈 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">개체가 약한 ID를 가진 경우는 애플리케이션 도메인 경계에서 해당 개체에 직접 액세스할 수 있을 때를 말합니다. 약한 ID를 가진 개체에 대한 잠금을 획득하려는 스레드는 동일한 개체에 대한 잠금을 획득한 다른 애플리케이션 도메인의 두 번째 스레드로 인해 차단될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">약한 ID를 가진 개체를 잠그지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">약한 ID를 가진 개체를 잠그지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersDescription">
        <source>A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.</source>
        <target state="translated">메서드는 .NET Framework 클래스 라이브러리의 생성자 또는 메서드에 문자열 리터럴을 매개 변수로 전달하고 해당 문자열은 지역화 가능해야 합니다. 이 규칙 위반 문제를 해결하려면 문자열 리터럴을 ResourceManager 클래스의 인스턴스를 통해 검색된 문자열로 바꿉니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersMessage">
        <source>Method '{0}' passes a literal string as parameter '{1}' of a call to '{2}'. Retrieve the following string(s) from a resource table instead: "{3}".</source>
        <target state="translated">'{0}' 메서드가 리터럴 문자열을 '{2}' 호출의 '{1}' 매개 변수로 전달합니다. 대신 리소스 테이블에서 "{3}" 문자열을 가져오세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersTitle">
        <source>Do not pass literals as localized parameters</source>
        <target state="translated">리터럴을 지역화된 매개 변수로 전달하지 마십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullCodeFixTitle">
        <source>Remove superfluous 'ArgumentNullException.ThrowIfNull' call</source>
        <target state="translated">불필요한 'ArgumentNullException.ThrowIfNull' 호출 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullDescription">
        <source>'ArgumentNullException.ThrowIfNull' throws when the passed argument is 'null'. Certain constructs like non-nullable structs, 'nameof()' and 'new' expressions are known to never be null, so 'ArgumentNullException.ThrowIfNull' will never throw.</source>
        <target state="translated">전달된 인수가 'null'이면 'ArgumentNullException.ThrowIfNull'이 throw됩니다. null을 허용하지 않는 구조체, 'nameof()' 및 'new' 식과 같은 특정 구문은 null이 아닌 것으로 알려져 있으므로 'ArgumentNullException.ThrowIfNull'은 throw되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullMessage">
        <source>Calling 'ArgumentNullException.ThrowIfNull' and passing a non-nullable value is a no-op</source>
        <target state="translated">'ArgumentNullException.ThrowIfNull'을 호출하고 null을 허용하지 않는 값을 전달하는 no-op</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNonNullableValueToArgumentNullExceptionThrowIfNullTitle">
        <source>Do not pass a non-nullable value to 'ArgumentNullException.ThrowIfNull'</source>
        <target state="translated">null을 허용하지 않는 값을 'ArgumentNullException.ThrowIfNull'에 전달 금지</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullCodeFixTitle">
        <source>Replace the 'ArgumentNullException.ThrowIfNull' call with a conditional</source>
        <target state="translated">'ArgumentNullException.ThrowIfNull' 호출을 조건부로 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullDescription">
        <source>'ArgumentNullException.ThrowIfNull' accepts an 'object', so passing a nullable struct may cause the value to be boxed.</source>
        <target state="translated">'ArgumentNullException.ThrowIfNull'은 'object'를 허용하므로 nullable 구조체를 전달하면 값이 박스 처리될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullMessage">
        <source>Passing a nullable struct to 'ArgumentNullException.ThrowIfNull' may cause boxing</source>
        <target state="translated">nullable 구조체를 'ArgumentNullException.ThrowIfNull'에 전달하면 박스 처리가 발생할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassNullableStructToArgumentNullExceptionThrowIfNullTitle">
        <source>Do not pass a nullable struct to 'ArgumentNullException.ThrowIfNull'</source>
        <target state="translated">nullable 구조체를 'ArgumentNullException.ThrowIfNull'에 전달 금지</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">충분히 구체적이지 않거나 런타임에서 예약된 형식의 예외는 사용자 지정 코드에서 발생할 수 없습니다. 이로 인해 원래 오류를 감지하거나 디버그하기 어려워집니다. 이러한 예외 인스턴스가 throw되면 다른 예외 형식을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime</source>
        <target state="translated">예외 형식 {0}이(가) 런타임에서 예약되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific</source>
        <target state="translated">예외 형식 {0}이(가) 충분히 구체적이지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">예약된 예외 형식을 발생시키지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">포인터 필드를 사용하여 형식을 직렬화하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">포인터는 가리키는 메모리의 정확성을 보장할 수 없다는 점에서 "형식이 안전"하지 않습니다. 따라서 공격자가 포인터를 제어하게 될 수 있으므로 포인터 필드를 사용하여 형식을 직렬화하는 것은 위험합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type</source>
        <target state="translated">직렬화 가능한 형식의 포인터 필드 {0}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">계정 공유 액세스 서명 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">SAS(공유 액세스 서명)는 Azure Storage를 사용하는 애플리케이션에 대한 보안 모델의 필수적인 부분으로, 계정 키가 없는 클라이언트에 스토리지 계정에 대한 제한되고 안전한 권한을 제공해야 합니다. 서비스 SAS를 통해 사용할 수 있는 모든 작업은 계정 SAS를 통해서도 사용할 수 있습니다. 즉, 계정 SAS는 권한이 너무 강력합니다. 따라서 서비스 SAS를 사용하여 액세스 권한을 더욱 신중하게 위임하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">세분화된 액세스 제어와 컨테이너 수준 액세스 정책을 위해 계정 SAS가 아닌 서비스 SAS 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">손상된 암호화 알고리즘을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">계산상 이 알고리즘을 손상시킬 수 있는 공격이 있습니다. 이를 통해, 제공되어야 하는 암호화 보장이 공격자에 의해 손상될 수 있습니다. 암호화 알고리즘의 형식과 애플리케이션에 따라 공격자가 암호화된 메시지를 읽고, 암호화된 메시지를 변조하고, 디지털 서명을 위조하고, 해시된 콘텐츠를 변조하거나 이 알고리즘 기반의 암호화 시스템을 손상시킬 수 있습니다. 암호화를 키 길이가 128비트보다 크거나 같은 AES 알고리즘(AES-256, AES-192 및 AES-128 사용 가능)으로 바꾸세요. 해시를 SHA512, SHA384 또는 SHA256과 같은 SHA-2 패밀리의 해시 알고리즘으로 바꾸세요. 디지털 서명을 키 길이가 2048비트보다 크거나 같은 RSA 또는 키 길이가 256비트보다 크거나 같은 ECDSA로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">{0}이(가) 손상된 암호화 알고리즘 {1}을(를) 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingDescription">
        <source>The ConfigureAwaitOptions.SuppressThrowing option is only supported with the non-generic Task, not a Task&lt;TResult&gt;.  To use it with a Task&lt;TResult&gt;, first cast to the base Task.</source>
        <target state="translated">ConfigureAwaitOptions.SuppressThrowing 옵션은 Task&lt;TResult&gt;가 아니라 제네릭이 아닌 작업에서만 지원됩니다.  작업&lt;TResult&gt;과 함께 사용하려면 먼저 기본 작업에 캐스트합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingMessage">
        <source>The ConfigureAwaitOptions.SuppressThrowing option is only supported with the non-generic Task</source>
        <target state="translated">ConfigureAwaitOptions.SuppressThrowing 옵션은 제네릭이 아닌 작업에서만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseConfigureAwaitWithSuppressThrowingTitle">
        <source>Do not use ConfigureAwaitOptions.SuppressThrowing with Task&lt;TResult&gt;</source>
        <target state="translated">작업&lt;TResult&gt;과 함께 ConfigureAwaitOptions.SuppressThrowing 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedDescription">
        <source>For non-empty collections, CountAsync() and LongCountAsync() enumerate the entire sequence, while AnyAsync() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">비어 있지 않은 컬렉션의 경우 CountAsync() 및 LongCountAsync()는 전체 시퀀스를 열거하고, AnyAsync()는 첫 번째 항목 또는 조건을 충족하는 첫 번째 항목에서 중지합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedMessage">
        <source>{0}() is used where AnyAsync() could be used instead to improve performance</source>
        <target state="translated">{0}()은(는) 성능 개선을 위해 AnyAsync()를 대신 사용할 수 있는 경우에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountAsyncWhenAnyAsyncCanBeUsedTitle">
        <source>Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used</source>
        <target state="translated">AnyAsync()를 사용할 수 있는 경우 CountAsync() 또는 LongCountAsync() 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedDescription">
        <source>For non-empty collections, Count() and LongCount() enumerate the entire sequence, while Any() stops at the first item or the first item that satisfies a condition.</source>
        <target state="translated">비어 있지 않은 컬렉션의 경우 Count() 및 LongCount()는 전체 시퀀스를 열거하고, Any()는 첫 번째 항목 또는 조건을 충족하는 첫 번째 항목에서 중지합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedMessage">
        <source>{0}() is used where Any() could be used instead to improve performance</source>
        <target state="translated">{0}()은(는) 성능 개선을 위해 Any()를 대신 사용할 수 있는 경우에 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCountWhenAnyCanBeUsedTitle">
        <source>Do not use Count() or LongCount() when Any() can be used</source>
        <target state="translated">Any()를 사용할 수 있는 경우 Count() 또는 LongCount() 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseCreateEncryptorWithNonDefaultIVDescription">
        <source>Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</source>
        <target state="translated">대칭형 암호화는 항상 반복할 수 없는 초기화 벡터를 사용하여 사전 공격을 방지해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="translated">DSA (디지털 서명 알고리즘) 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="translated">DSA가 보호 수준이 너무 낮아 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">비대칭 암호화 알고리즘 {0}은(는) 취약합니다. 대신 최소 2048 키 크기, ECDH 또는 ECDSA 알고리즘이 포함된 RSA로 전환하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">사용되지 않는 보안 프로토콜을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">시스템 기본값이 아닌 사용되지 않는 보안 프로토콜을 사용하는 것은 위험합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">사용되지 않는 보안 프로토콜 {0}의 하드 코드된 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsDescription">
        <source>The property 'StreamReader.EndOfStream' can cause unintended synchronous blocking when no data is buffered. Instead, use 'StreamReader.ReadLineAsync' directly, which returns 'null' when reaching the end of the stream.</source>
        <target state="translated">'StreamReader.EndOfStream' 속성은 데이터가 버퍼링되지 않은 경우 의도하지 않은 동기 차단을 초래할 수 있습니다. 대신, 스트림의 끝에 도달할 때 'null'을 반환하는 'StreamReader.ReadLineAsync'를 직접 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsMessage">
        <source>Do not use '{0}' in an async method</source>
        <target state="translated">비동기 메서드에서 '{0}'을(를) 사용하지 마세요</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEndOfStreamInAsyncMethodsTitle">
        <source>Do not use 'StreamReader.EndOfStream' in async methods</source>
        <target state="translated">비동기 메서드에서는 'StreamReader.EndOfStream'을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">이 컬렉션을 직접 인덱싱할 수 있습니다. 여기에서 LINQ를 통과하면 불필요한 할당과 CPU 작업이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly.</source>
        <target state="translated">인덱싱 가능한 컬렉션의 Enumerable 메서드를 사용하지 마세요. 대신 컬렉션을 직접 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections</source>
        <target state="translated">인덱싱 가능한 컬렉션의 Enumerable 메서드를 사용하면 안 됨</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomness">
        <source>Do not use insecure randomness</source>
        <target state="translated">안전하지 않은 임의성 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessDescription">
        <source>Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated. Use a cryptographically strong random number generator if an unpredictable value is required, or ensure that weak pseudo-random numbers aren't used in a security-sensitive manner.</source>
        <target state="translated">암호화가 약한 의사 난수 생성기를 사용하면 공격자가 생성되는 보안에 중요한 값을 예측할 수 있습니다. 예측 불가능한 값이 필요한 경우 암호화가 강한 난수 생성기를 사용하거나, 약한 의사 난수가 보안에 중요한 방식으로 사용되지 않도록 하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessMessage">
        <source>{0} is an insecure random number generator. Use cryptographically secure random number generators when randomness is required for security.</source>
        <target state="translated">{0}은(는) 비보안 난수 생성기입니다. 보안을 위해 임의성이 필요한 경우 암호화된 보안 난수 생성기를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">사용되지 않는 키 파생 함수 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">암호 기반 키 파생은 PBKDF2와 SHA-2를 사용해야 합니다. PasswordDeriveBytes는 PBKDF1 키를 생성하므로 사용하지 마세요. Rfc2898DeriveBytes.CryptDeriveKey는 반복 횟수 또는 솔트를 사용하지 않으므로 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">사용되지 않는 키 파생 함수 {0}.{1}에 대한 호출</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersDescription">
        <source>String parameters passed by value with the 'OutAttribute' can destabilize the runtime if the string is an interned string.</source>
        <target state="translated">'OutAttribute'를 사용하여 값으로 전달된 문자열 매개 변수는 문자열이 인턴 지정된 문자열인 경우 런타임을 불안정하게 만들 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersMessage">
        <source>Do not use the 'OutAttribute' for string parameter '{0}' which is passed by value. If marshalling of modified data back to the caller is required, use the 'out' keyword to pass the string by reference instead.</source>
        <target state="translated">값으로 전달된 문자열 매개 변수 '{0}'에는 'OutAttribute'를 사용하지 마세요. 수정된 데이터를 다시 호출자에 마샬링해야 하는 경우 대신 'out' 키워드를 사용하여 참조로 문자열을 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseOutAttributeStringPInvokeParametersTitle">
        <source>Do not use 'OutAttribute' on string parameters for P/Invokes</source>
        <target state="translated">P/Invokes에 대한 문자열 매개 변수에는 'OutAttribute'를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesComparerMessage">
        <source>Do not pass an argument with value type '{0}' to the 'Equals' method on 'ReferenceEqualityComparer'. Due to value boxing, this call to 'Equals' can return an unexpected result. Consider using 'EqualityComparer' instead, or pass reference type arguments if you intend to use 'ReferenceEqualityComparer'.</source>
        <target state="translated">값 형식이 '{0}'인 인수를 'ReferenceEqualityComparer'의 'Equals' 메소드에 전달하지 마세요. 값 boxing으로 인해 'Equals'에 대한 이 호출은 예기치 않은 결과를 반환할 수 있습니다. 대신 'EqualityComparer'를 사용하거나 'ReferenceEqualityComparer'를 사용하려는 경우 참조 형식 인수를 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesDescription">
        <source>Value type typed arguments are uniquely boxed for each call to this method, therefore the result can be unexpected.</source>
        <target state="translated">값 형식 형식 인수는 이 메소드에 대한 각 호출에 대해 고유하게 boxing되므로 예상하지 못한 결과가 나올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesMethodMessage">
        <source>Do not pass an argument with value type '{0}' to 'ReferenceEquals'. Due to value boxing, this call to 'ReferenceEquals' can return an unexpected result. Consider using 'Equals' instead, or pass reference type arguments if you intend to use 'ReferenceEquals'.</source>
        <target state="translated">값 형식이 '{0}'인 인수를 'ReferenceEquals'에 전달하지 마세요. 값 boxing으로 인해 'ReferenceEquals'에 대한 이 호출은 예기치 않은 결과를 반환할 수 있습니다. 대신 'Equals'를 사용하거나 'ReferenceEquals'를 사용하려는 경우 참조 형식 인수를 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseReferenceEqualsWithValueTypesTitle">
        <source>Do not use ReferenceEquals with value types</source>
        <target state="translated">값 형식이 있는 ReferenceEquals를 사용하면 안 됨</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsDescription">
        <source>Stack space allocated by a stackalloc is only released at the end of the current method's invocation.  Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</source>
        <target state="translated">stackalloc에서 할당된 스택 공간은 현재 메서드의 호출이 끝날 때만 릴리스됩니다. 루프에서 stackalloc를 사용하면 바인딩되지 않은 스택 증가 및 최종 스택 오버플로 조건이 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsMessage">
        <source>Potential stack overflow. Move the stackalloc out of the loop.</source>
        <target state="translated">잠재적 스택 오버플로입니다. stackalloc를 루프 밖으로 이동합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseStackallocInLoopsTitle">
        <source>Do not use stackalloc in loops</source>
        <target state="translated">루프에서 stackalloc을 사용하면 안 됨</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseThreadVolatileReadWriteCodeFixTitle">
        <source>Replace obsolete call</source>
        <target state="translated">사용되지 않는 호출 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">정기적인 작업의 실행 빈도가 높아지면 CPU 사용률도 높아져 디스플레이 및 하드 디스크를 끄는 절전 유휴 타이머에 방해가 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">전원 상태 변경을 방해하는 타이머를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">전원 상태 변경을 방해하는 타이머를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPath">
        <source>Do not use unsafe DllImportSearchPath value</source>
        <target state="translated">안전하지 않은 DllImportSearchPath 값 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathDescription">
        <source>There could be a malicious DLL in the default DLL search directories. Or, depending on where your application is run from, there could be a malicious DLL in the application's directory. Use a DllImportSearchPath value that specifies an explicit search path instead. The DllImportSearchPath flags that this rule looks for can be configured in .editorconfig.</source>
        <target state="translated">기본 DLL 검색 디렉터리에 악성 DLL이 있을 수 있습니다. 또는 애플리케이션이 실행되는 위치에 따라 애플리케이션의 디렉터리에 악성 DLL이 있을 수 있습니다. 대신 명시적 검색 경로를 지정하는 DllImportSearchPath 값을 사용합니다. 이 규칙이 검색하는 DllImportSearchPath 플래그는 .editorconfig에서 구성할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseUnsafeDllImportSearchPathMessage">
        <source>Use of unsafe DllImportSearchPath value {0}</source>
        <target state="translated">안전하지 않은 DllImportSearchPath 값 {0} 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskDescription">
        <source>Using 'WaitAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="translated">단일 작업에 'WaitAll'을 사용하면 대신 성능이 저하되거나 작업을 기다리거나 반환할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskFix">
        <source>Replace 'WaitAll' with single 'Wait'</source>
        <target state="translated">'WaitAll'을 단일 'Wait'으로 교체</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWaitAllWithSingleTaskTitle">
        <source>Do not use 'WaitAll' with a single task</source>
        <target state="translated">단일 작업에 'WaitAll'을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">취약한 암호화 알고리즘을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">암호화 알고리즘의 성능이 점점 저하되어 공격자가 더 많은 계산에 액세스할 수 있도록 공격이 진화합니다. 암호화 알고리즘의 형식과 애플리케이션 및 계속 저하되는 암호화 기능에 따라 공격자가 암호화된 메시지를 읽고, 암호화된 메시지를 변조하고, 디지털 서명을 위조하고, 해시된 콘텐츠를 변조하거나 이 알고리즘 기반의 암호화 시스템을 손상시킬 수 있습니다. 암호화를 키 길이가 128비트보다 크거나 같은 AES 알고리즘(AES-256, AES-192 및 AES-128 사용 가능)으로 바꾸세요. 해시를 SHA-2 512, SHA-2 384 또는 SHA-2 256과 같은 SHA-2 패밀리의 해시 알고리즘으로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">{0}이(가) 취약한 암호화 알고리즘 {1}을(를) 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Ensure Key Derivation Function algorithm is sufficiently strong</source>
        <target state="translated">키 파생 함수 알고리즘이 충분히 강력한지 확인</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="translated">Rfc2898DeriveBytes 클래스의 일부 구현에서는 해시 알고리즘을 생성자 매개 변수에 지정하거나 HashAlgorithm 속성에서 덮어쓸 수 있도록 허용합니다. 해시 알고리즘이 지정된 경우 SHA-256 이상의 해시 알고리즘이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} might be using a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password.</source>
        <target state="translated">{0}이(가) 취약한 해시 알고리즘을 사용하고 있을 수 있습니다. 암호에서 강력한 키를 만들려면 SHA256, SHA384 또는 SHA512를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFInsufficientIterationCountDescription">
        <source>When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).</source>
        <target state="translated">암호와 같은 사용자 제공 입력에서 암호화 키를 파생할 때 충분한 반복 횟수(10만 이상)를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskDescription">
        <source>Using 'WhenAll' with a single task may result in performance loss, await or return the task instead.</source>
        <target state="translated">단일 작업에 'WhenAll'을 사용하면 대신 성능이 저하되거나 작업을 기다리거나 반환할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskFix">
        <source>Replace 'WhenAll' call with argument</source>
        <target state="translated">'WhenAll' 호출을 인수로 대체</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWhenAllWithSingleTaskTitle">
        <source>Do not use 'WhenAll' with a single task</source>
        <target state="translated">단일 작업에 'WhenAll'을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">XslTransform 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">XslTransform을 사용하지 마세요. 잠재적으로 위험한 외부 참조를 제한하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedDescription">
        <source>Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic.</source>
        <target state="translated">기능적인 'DynamicInterfaceCastableImplementationAttribute' 속성 인터페이스를 제공하려면 Visual Basic에서 지원되지 않는 기본 인터페이스 멤버 기능이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedMessage">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="translated">Visual Basic에서 'DynamicInterfaceCastableImplementation' 인터페이스 제공은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicInterfaceCastableImplementationUnsupportedTitle">
        <source>Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported</source>
        <target state="translated">Visual Basic에서 'DynamicInterfaceCastableImplementation' 인터페이스 제공은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledDescription">
        <source>Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.</source>
        <target state="translated">런타임 마샬링이 비활성화된 경우 런타임 마샬링이 필요한 기능을 사용하면 런타임 예외가 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageAutoLayoutTypes">
        <source>Types with '[StructLayout(LayoutKind.Auto)]' require runtime marshalling to be enabled</source>
        <target state="translated">'[StructLayout(LayoutKind.Auto)]' 유형은 런타임 마샬링을 활성화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageByRefParameters">
        <source>By-ref parameters require runtime marshalling to be enabled</source>
        <target state="translated">By-ref 매개 변수는 런타임 마샬링을 활성화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageDelegateUsage">
        <source>Delegates with managed types as parameters or the return type require runtime marshalling to be enabled in the assembly where the delegate is defined</source>
        <target state="translated">관리되는 형식을 매개 변수로 사용하거나 반환 형식을 사용하는 대리자는 대리자가 정의된 어셈블리에서 런타임 마샬링을 사용하도록 설정해야 합니다</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageHResultSwapping">
        <source>HResult-swapping requires runtime marshalling to be enabled</source>
        <target state="translated">HResult-swapping은 런타임 마샬링을 활성화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageLCIDConversionAttribute">
        <source>Using 'LCIDConversionAttribute' requires runtime marshalling to be enabled</source>
        <target state="translated">'LCIDConversionAttribute'를 사용하려면 런타임 마샬링을 활성화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageManagedParameterOrReturnTypes">
        <source>Managed parameter or return types require runtime marshalling to be enabled</source>
        <target state="translated">관리되는 매개 변수 또는 반환 유형은 런타임 마샬링을 활성화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageSetLastError">
        <source>Setting SetLastError to 'true' requires runtime marshalling to be enabled</source>
        <target state="translated">SetLastError를 'true'로 설정하려면 런타임 마샬링을 활성화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageVarargPInvokes">
        <source>Varadic P/Invoke signatures require runtime marshalling to be enabled</source>
        <target state="translated">Varadic P/Invoke 서명은 런타임 마샬링을 활성화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FeatureUnsupportedWhenRuntimeMarshallingDisabledTitle">
        <source>Property, type, or attribute requires runtime marshalling</source>
        <target state="translated">속성, 유형 또는 특성에는 런타임 마샬링이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldIsPreviewTypeMessage">
        <source>'{0}''s type contains the preview type '{1}' and requires opting into preview features. See {2} for more information.</source>
        <target state="translated">'{0}'의 유형에 미리 보기 유형 '{1}'이(가) 포함되어 있으며 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldIsPreviewTypeMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}''s type contains the preview type '{1}' and requires opting into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}'의 유형에 '{1}' 미리 보기 유형이 포함되어 있으며 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsDescription">
        <source>Forward the 'CancellationToken' parameter to methods to ensure the operation cancellation notifications gets properly propagated, or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token.</source>
        <target state="translated">'CancellationToken' 매개 변수를 메서드로 전달하여 작업 취소 알림이 올바르게 전파되도록 하거나, 명시적으로 'CancellationToken.None'을 전달하여 의도적으로 토큰을 전파하지 않음을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsMessage">
        <source>Forward the '{0}' parameter to the '{1}' method or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token</source>
        <target state="translated">'{0}' 매개 변수를 '{1}' 메서드로 전달하거나, 명시적으로 'CancellationToken.None'을 전달하여 의도적으로 토큰을 전파하지 않음을 나타내세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ForwardCancellationTokenToInvocationsTitle">
        <source>Forward the 'CancellationToken' parameter to methods</source>
        <target state="translated">'CancellationToken' 매개 변수를 메서드로 전달</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="translated">운영 체제에서 사용할 최상의 전송 계층 보안 프로토콜을 선택할 수 있게 하려면 SecurityProtocolType {0}을(를) 하드 코딩하지 말고 대신 SecurityProtocolType.SystemDefault를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="translated">SecurityProtocolType 값 하드 코딩 방지</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsDescription">
        <source>Current Transport Layer Security protocol versions may become deprecated if vulnerabilities are found. Avoid hardcoding SslProtocols values to keep your application secure. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">취약성이 발견되면 현재 전송 계층 보안 프로토콜 버전이 사용되지 않을 수 있습니다. 애플리케이션을 안전하게 유지하려면 SslProtocols 값을 하드 코딩하지 않습니다. 운영 체제에서 버전을 선택하도록 하려면 '없음'을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsMessage">
        <source>Avoid hardcoding SslProtocols '{0}' to ensure your application remains secure in the future. Use 'None' to let the Operating System choose a version.</source>
        <target state="translated">앞으로 애플리케이션을 안전하게 유지하려면 SslProtocols '{0}'을(를) 하드 코딩하지 마세요. 운영 체제에서 버전을 선택하도록 하려면 '없음'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardcodedSslProtocolsTitle">
        <source>Avoid hardcoded SslProtocols values</source>
        <target state="translated">하드 코딩된 SslProtocols 값 방지</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyDescription">
        <source>Generic math interfaces require the derived type itself to be used for the self recurring type parameter.</source>
        <target state="translated">제네릭 수학 인터페이스를 사용하려면 파생 형식 자체를 자체 되풀이 형식 매개 변수에 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyMessage">
        <source>The '{0}' requires the '{1}' type parameter to be filled with the derived type '{2}'</source>
        <target state="translated">'{0}'을(를) 사용하려면 '{1}' 형식 매개 변수를 파생 형식 '{2}'(으)로 채워야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementGenericMathInterfacesCorrectlyTitle">
        <source>Use correct type parameter</source>
        <target state="translated">올바른 형식 매개 변수 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementInterfacesOnDynamicCastableImplementation">
        <source>Implement inherited interfaces</source>
        <target state="translated">상속된 인터페이스 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewInterfaceMessage">
        <source>'{0}' implements the preview interface '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}'은(는) 미리 보기 인터페이스 '{1}'를 구현하므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewInterfaceMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' implements the preview interface '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}'은(는) 미리 보기 인터페이스 '{1}'을(를) 구현하므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewMethodMessage">
        <source>'{0}' implements the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}'은(는) 미리 보기 메서드 '{1}'를 구현하므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementsPreviewMethodMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' implements the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}'은(는) 미리 보기 방법 '{1}'을 구현하므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">참조 형식이 명시적 정적 생성자를 선언합니다. 이 규칙 위반 문제를 해결하려면 선언될 때 모든 정적 데이터를 초기화하고 정적 생성자를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">참조 형식 정적 필드 인라인을 초기화하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">'{0}'의 필드가 선언될 때 모든 정적 필드를 초기화하고 정적 생성자를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">값 형식이 명시적 정적 생성자를 선언합니다. 이 규칙 위반 문제를 해결하려면 선언될 때 모든 정적 데이터를 초기화하고 정적 생성자를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">값 형식 정적 필드 인라인을 초기화하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyChangeToTwoArgumentCodeFixTitle">
        <source>Change to call the two argument constructor, pass null for the message.</source>
        <target state="translated">두 인수 생성자를 호출하도록 변경하고 메시지로 null을 전달합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">예외 형식의 매개 변수가 없는 기본 생성자에 발생하는 호출은 ArgumentException이거나 ArgumentException에서 파생됩니다. 즉, 올바르지 않은 문자열 인수는 ArgumentException이거나 ArgumentException에서 파생된 예외 형식의 매개 변수가 있는 생성자로 전달됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyFlipArgumentOrderCodeFixTitle">
        <source>Swap the arguments order</source>
        <target state="translated">인수 순서 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">{0} 메서드가 매개 변수 이름 '{1}'을(를) {3} 생성자에 {2} 인수로 전달합니다. 이 인수를 자세한 설명이 있는 메시지로 바꾸고 매개 변수 이름을 올바른 위치에 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">{0} 메서드가 '{1}'을(를) {3} 생성자에 {2} 인수로 전달합니다. 이 인수를 메서드의 매개 변수 이름 중 하나로 바꾸세요. 제공된 매개 변수 이름의 대/소문자는 메서드에 선언된 것과 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter</source>
        <target state="translated">메시지 및/또는 paramName 매개 변수를 포함하는 {0} 생성자를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate argument exceptions correctly</source>
        <target state="translated">올바른 인수 예외를 인스턴스화하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationDescription">
        <source>Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise.</source>
        <target state="translated">'DynamicInterfaceCastableImplementationAttribute' 특성이 있는 형식은 'IDynamicInterfaceCastable' 형식을 구현하는 형식에 대한 인터페이스 구현으로 작동합니다. 그 결과, 다른 경우에는 'IDynamicInterfaceCastable'을 구현하는 형식이 해당 항목을 제공하지 않기 때문에 상속된 인터페이스에 정의된 모든 멤버의 구현을 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationMessage">
        <source>Type '{0}' has the 'DynamicInterfaceCastableImplementationAttribute' applied to it but does not provide an implementation of all interface members defined in inherited interfaces</source>
        <target state="translated">'{0}' 형식에 'DynamicInterfaceCastableImplementationAttribute'가 적용되었지만 상속된 인터페이스에 정의된 모든 인터페이스 멤버의 구현을 제공하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMembersMissingImplementationTitle">
        <source>All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface</source>
        <target state="translated">부모 인터페이스에 선언된 모든 멤버는 DynamicInterfaceCastableImplementation 속성 인터페이스에서 구현해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Ensure that the JavaScriptSerializer is initialized without a JavaScriptTypeResolver specified, or initialized with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">SimpleTypeResolver로 초기화된 JavaScriptSerializer로 신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다. JavaScriptSerializer가 JavaScriptTypeResolver가 지정되지 않은 상태로 초기화되었거나 역직렬화된 개체 그래프에서 해당 개체 형식을 제한하는 JavaScriptTypeResolver로 초기화되었는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerMaybeWithSimpleTypeResolverTitle">
        <source>Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</source>
        <target state="translated">deserialize하기 전에 JavaScriptSerializer가 SimpleTypeResolver로 초기화되지 않았는지 확인</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data with a JavaScriptSerializer initialized with a SimpleTypeResolver. Initialize JavaScriptSerializer without a JavaScriptTypeResolver specified, or initialize with a JavaScriptTypeResolver that limits the types of objects in the deserialized object graph.</source>
        <target state="translated">SimpleTypeResolver로 초기화된 JavaScriptSerializer로 신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다. JavaScriptTypeResolver가 지정되지 않은 상태로 JavaScriptSerializer를 초기화하거나 역직렬화된 개체 그래프에서 해당 개체 형식을 제한하는 JavaScriptTypeResolver로 초기화하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JavaScriptSerializerWithSimpleTypeResolverTitle">
        <source>Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</source>
        <target state="translated">SimpleTypeResolver를 사용하여 JavaScriptSerializer로 deserialize 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">신뢰할 수 없는 입력을 역직렬화하는 경우 역직렬화되는 임의 형식을 허용하는 것은 안전하지 않습니다. JsonSerializer를 역직렬화하는 경우 TypeNameHandling.None을 사용하고, 또는 None 이외의 값에 대해 SerializationBinder를 사용하여 역직렬화된 형식을 제한하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSerializerTitle">
        <source>Do not deserialize with JsonSerializer using an insecure configuration</source>
        <target state="translated">안전하지 않은 구성을 사용하여 JsonSerializer로 역직렬화 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">신뢰할 수 없는 입력을 deserialize하는 경우 deserialize되는 임의 형식을 허용하는 것은 안전하지 않습니다. JsonSerializerSettings를 사용하는 경우 TypeNameHandling.None을 사용하고, 또는 None 이외의 값에 대해 SerializationBinder를 사용하여 deserialize된 형식을 제한하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetInsecureSettingsTitle">
        <source>Do not use insecure JsonSerializerSettings</source>
        <target state="translated">안전하지 않은 JsonSerializerSettings를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure. When using deserializing JsonSerializer, use TypeNameHandling.None, or for values other than None, restrict deserialized types with a SerializationBinder.</source>
        <target state="translated">신뢰할 수 없는 입력을 역직렬화하는 경우 역직렬화되는 임의 형식을 허용하는 것은 안전하지 않습니다. JsonSerializer를 역직렬화하는 경우 TypeNameHandling.None을 사용하고, 또는 None 이외의 값에 대해 SerializationBinder를 사용하여 역직렬화된 형식을 제한하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSerializerTitle">
        <source>Ensure that JsonSerializer has a secure configuration when deserializing</source>
        <target state="translated">역직렬화할 때 JsonSerializer에 보안 구성이 있는지 확인</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsMessage">
        <source>When deserializing untrusted input, allowing arbitrary types to be deserialized is insecure.  When using JsonSerializerSettings, ensure TypeNameHandling.None is specified, or for values other than None, ensure a SerializationBinder is specified to restrict deserialized types.</source>
        <target state="translated">신뢰할 수 없는 입력을 deserialize하는 경우 deserialize되는 임의 형식을 허용하는 것은 안전하지 않습니다. JsonSerializerSettings를 사용하는 경우 TypeNameHandling.None이 지정되었는지 확인하고, 또는 None 이외의 값에 대해 SerializationBinder가 지정되어 deserialize된 형식을 제한하는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetMaybeInsecureSettingsTitle">
        <source>Ensure that JsonSerializerSettings are secure</source>
        <target state="translated">JsonSerializerSettings가 안전한지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingDescription">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.  If you need to instead detect Json.NET deserialization when a SerializationBinder isn't specified, then disable rule CA2326, and enable rules CA2327, CA2328, CA2329, and CA2330.</source>
        <target state="translated">None 이외의 TypeNameHandling 값을 사용하는 경우 JSON deserialize가 안전하지 않을 수 있습니다. SerializationBinder가 지정되지 않았을 때 대신 Json.NET deserialization을 검색해야 하는 경우 CA2326 규칙을 사용하지 않도록 설정하고 CA2327, CA2328, CA2329, CA2330 규칙을 사용하도록 설정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingMessage">
        <source>Deserializing JSON when using a TypeNameHandling value other than None can be insecure.</source>
        <target state="translated">None 이외의 TypeNameHandling 값을 사용하는 경우 JSON deserialize가 안전하지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNetTypeNameHandlingTitle">
        <source>Do not use TypeNameHandling values other than None</source>
        <target state="translated">None 이외의 TypeNameHandling 값을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">신뢰할 수 없는 데이터를 deserialize하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LosFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer LosFormatter</source>
        <target state="translated">안전하지 않은 역직렬 변환기 LosFormatter를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMethodDeclaredOnImplementationTypeStatic">
        <source>Convert to static method</source>
        <target state="translated">정적 메서드로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMethodDeclaredOnImplementationTypeStaticMayProduceInvalidCode">
        <source>Converting an instance method to a static method may produce invalid code</source>
        <target state="translated">인스턴스 메서드를 정적 메서드로 변환하면 잘못된 코드가 생성될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeParameterlessConstructorPublic">
        <source>Make the constructor that takes zero parameters 'public'</source>
        <target state="translated">매개 변수가 0인 생성자를 '공개'로 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">직렬화할 수 없는 형식의 인스턴스 필드는 직렬화할 수 있는 형식으로 선언됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">{0} 필드는 직렬화할 수 있는 {1} 형식의 멤버이지만 직렬화할 수 없는 {2} 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">모두 serialize할 수 없는 필드로 표시하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageDescription">
        <source>The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set.</source>
        <target state="translated">NeutralResourcesLanguage 특성은 어셈블리의 중립 문화권 리소스를 표시하는 데 사용된 언어 정보를 ResourceManager에 제공합니다. 그 결과 로드되는 첫 번째 리소스에 대한 조회 성능이 향상되고 작업 집합이 줄어듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageMessage">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">NeutralResourcesLanguageAttribute로 어셈블리를 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithNeutralResourcesLanguageTitle">
        <source>Mark assemblies with NeutralResourcesLanguageAttribute</source>
        <target state="translated">NeutralResourcesLanguageAttribute로 어셈블리를 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">부울 데이터 형식은 비관리 코드에서 다양하게 표현됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">P/Invoke {1}의 {0} 매개 변수에 MarshalAsAttribute를 추가하세요. 관리되지 않는 해당 매개 변수가 4바이트 Win32 'BOOL'인 경우 [MarshalAs(UnmanagedType.Bool)]를 사용하세요. 1바이트 C++ 'bool'인 경우 MarshalAs(UnmanagedType.U1)를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">P/Invoke {0}의 반환 형식에 MarshalAsAttribute를 추가하세요. 관리되지 않는 해당 반환 형식이 4바이트 Win32 'BOOL'인 경우 MarshalAs(UnmanagedType.Bool)를 사용하세요. 1바이트 C++ 'bool'인 경우 MarshalAs(UnmanagedType.U1)를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">MarshalAs로 부울 PInvoke 인수를 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">공용 언어 런타임에서 serializable로 인식되려면 형식이 ISerializable 인터페이스 구현을 통해 사용자 지정 serialization 루틴을 사용하는 경우에도 SerializableAttribute 특성을 사용하여 형식을 표시해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">ISerializable을 구현하는 [Serializable]을 {0}에 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">serializable로 ISerializable 형식 표시</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheck">
        <source>Ensure HttpClient certificate revocation list check is not disabled</source>
        <target state="translated">HttpClient 인증서 해지 목록 확인을 사용할 수 있는지 확인합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeDisableHttpClientCRLCheckMessage">
        <source>HttpClient may be created without enabling CheckCertificateRevocationList</source>
        <target state="translated">CheckCertificateRevocationList를 사용하지 않고 HttpClient가 생성될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="translated">루트 저장소에 인증서가 추가되지 않았는지 확인</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="translated">운영 체제의 신뢰할 수 있는 루트 인증서에 인증서를 추가하는 것은 안전하지 않습니다. 대상 저장소가 루트 저장소가 아닌지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIV">
        <source>Use CreateEncryptor with the default IV</source>
        <target state="translated">기본 IV와 함께 CreateEncryptor 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseCreateEncryptorWithNonDefaultIVMessage">
        <source>The non-default initialization vector, which can be potentially repeatable, is used in the encryption. Ensure use the default one.</source>
        <target state="translated">잠재적으로 반복할 수 있는, 기본이 아닌 초기화 벡터가 암호화에 사용됩니다. 기본 초기화 벡터를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.NET Core</source>
        <target state="translated">ASP.NET Core에서 보안 쿠키 사용 확인</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">쿠키를 설정할 때 CookieOptions.Secure = true인지 확인합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCount">
        <source>Ensure Sufficient Iteration Count When Using Weak Key Derivation Function</source>
        <target state="translated">취약한 키 파생 함수를 사용할 때 충분한 반복 횟수가 필요함</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCountMessage">
        <source>Ensure that the iteration count is at least {0} when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="translated">암호에서 암호화 키를 파생할 때 {0} 이상의 반복 횟수를 사용하세요. 기본적으로 Rfc2898DeriveByte의 IterationCount는 1,000뿐입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticDescription">
        <source>Since a type that implements 'IDynamicInterfaceCastable' may not implement a dynamic interface in metadata, calls to an instance interface member that is not an explicit implementation defined on this type are likely to fail at runtime. Mark new interface members 'static' to avoid runtime errors.</source>
        <target state="translated">'IDynamicInterfaceCastable'을 구현하는 형식은 메타데이터에서 동적 인터페이스를 구현하지 않을 수 있으므로 이 형식에 정의된 명시적 구현이 아닌 인스턴스 인터페이스 멤버에 대한 호출은 런타임에 실패할 가능성이 높습니다. 런타임 오류를 방지하려면 새 인터페이스 멤버를 '정적'으로 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticMessage">
        <source>The '{0}' member on the '{1}' type should be marked 'static' as '{1}' has the 'DynamicInterfaceImplementationAttribute' applied</source>
        <target state="translated">'{1}' 형식의 '{0}' 멤버는 '{1}'에 'DynamicInterfaceImplementationAttribute'가 적용되었으므로 '정적'으로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MembersDeclaredOnImplementationTypeMustBeStaticTitle">
        <source>Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'static'</source>
        <target state="translated">'DynamicInterfaceCastableImplementationAttribute'가 있는 인터페이스에 정의된 멤버는 '정적'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodReturnsPreviewTypeMessage">
        <source>'{0}' returns the preview type '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}'은(는) 미리 보기 유형 '{1}'을(를) 반환하므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodReturnsPreviewTypeMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' returns the preview type '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}'은(는) 미리 보기 유형 '{1}'을 반환하므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesPreviewTypeAsParameterMessage">
        <source>'{0}' takes in a preview parameter of type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}'은(는) '{1}' 유형의 미리 보기 매개 변수를 사용하며 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesPreviewTypeAsParameterMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' takes in a preview parameter of type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}'은(는) '{1}' 유형의 미리 보기 매개 변수를 사용하며 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledDescription">
        <source>This method uses runtime marshalling even when runtime marshalling is disabled, which can cause unexpected behavior differences at runtime due to different expectations of a type's native layout.</source>
        <target state="translated">이 메서드는 런타임 마샬링이 비활성화된 경우에도 런타임 마샬링을 사용하므로 형식의 기본 레이아웃에 대한 기대치가 다르기 때문에 런타임에 예기치 않은 동작 차이가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledMessage">
        <source>'{0}' uses runtime marshalling even when 'DisableRuntimeMarshallingAttribute' is applied. Use features like 'sizeof' and pointers directly to ensure accurate results.</source>
        <target state="translated">'{0}'은(는) 'DisableRuntimeMarshallingAttribute'가 적용된 경우에도 런타임 마샬링을 사용합니다. 정확한 결과를 보장하기 위해 'sizeof' 및 포인터와 같은 기능을 직접 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledTitle">
        <source>This method uses runtime marshalling even when the 'DisableRuntimeMarshallingAttribute' is applied</source>
        <target state="translated">이 메서드는 'DisableRuntimeMarshallingAttribute'가 적용된 경우에도 런타임 마샬링을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttribute">
        <source>Miss HttpVerb attribute for action methods</source>
        <target state="translated">작업 메서드의 HttpVerb 특성 누락</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeDescription">
        <source>All the methods that create, edit, delete, or otherwise modify data do so in the [HttpPost] overload of the method, which needs to be protected with the anti forgery attribute from request forgery. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</source>
        <target state="translated">데이터를 생성, 편집, 삭제 또는 수정하는 모든 메서드는 위조 방지 특성을 사용하여 요청 위조로부터 보호되어야 하는 메서드의 [HttpPost] 오버로드에서 해당 작업을 수행합니다. GET 작업 수행은 부작용이 없고 영구 데이터를 수정하지 않는 안전한 작업이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissHttpVerbAttributeMessage">
        <source>Action method {0} needs to specify the HTTP request kind explicitly</source>
        <target state="translated">작업 메서드 {0}은(는) HTTP 요청 종류를 명시적으로 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesDescription">
        <source>Module initializers are intended to be used by application code to ensure an application's components are initialized before the application code begins executing. If library code declares a method with the 'ModuleInitializerAttribute', it can interfere with application initialization and also lead to limitations in that application's trimming abilities. Instead of using methods marked with 'ModuleInitializerAttribute', the library should expose methods that can be used to initialize any components within the library and allow the application to invoke the method during application initialization.</source>
        <target state="translated">모듈 이니셜라이저는 응용 프로그램 코드가 실행을 시작하기 전에 응용 프로그램의 구성 요소가 초기화되도록 응용 프로그램 코드에서 사용하기 위한 것입니다. 라이브러리 코드가 'ModuleInitializerAttribute'를 사용하여 메서드를 선언하면 응용 프로그램 초기화를 방해할 수 있으며 해당 응용 프로그램의 트리밍 기능에 제한이 생길 수도 있습니다. 'ModuleInitializerAttribute'로 표시된 메서드를 사용하는 대신 라이브러리는 라이브러리 내의 구성 요소를 초기화하는 데 사용할 수 있는 메서드를 노출하고 응용 프로그램 초기화 중에 응용 프로그램이 메서드를 호출할 수 있도록 해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesMessage">
        <source>The 'ModuleInitializer' attribute is only intended to be used in application code or advanced source generator scenarios</source>
        <target state="translated">'ModuleInitializer' 특성은 애플리케이션 코드 또는 고급 원본 생성기 시나리오에서만 사용하기 위한 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ModuleInitializerAttributeShouldNotBeUsedInLibrariesTitle">
        <source>The 'ModuleInitializer' attribute should not be used in libraries</source>
        <target state="translated">'ModuleInitializer' 특성은 라이브러리에서 사용하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">역직렬화된 개체 그래프에서 개체 형식을 제한하기 위해 SerializationBinder 없이 신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeMaybeWithoutBinderSetTitle">
        <source>Ensure NetDataContractSerializer.Binder is set before deserializing</source>
        <target state="translated">deserialize하기 전에 NetDataContractSerializer.Binder를 설정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data without a SerializationBinder to restrict the type of objects in the deserialized object graph.</source>
        <target state="translated">역직렬화된 개체 그래프에서 개체 형식을 제한하기 위해 SerializationBinder 없이 신뢰할 수 없는 데이터를 역직렬화하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerDeserializeWithoutBinderSetTitle">
        <source>Do not deserialize without first setting NetDataContractSerializer.Binder</source>
        <target state="translated">먼저 NetDataContractSerializer.Binder를 설정하지 않고 deserialize하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedDescription">
        <source>The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect NetDataContractSerializer deserialization without a SerializationBinder set, then disable rule CA2310, and enable rules CA2311 and CA2312.</source>
        <target state="translated">신뢰할 수 없는 데이터를 deserialize할 경우 '{0}' 메서드는 안전하지 않습니다. SerializationBinder를 설정하지 않고 NetDataContractSerializer deserialization을 검색해야 하는 경우에는 규칙 CA2310을 사용하지 않도록 설정하고 규칙 CA2311 및 CA2312를 사용하도록 설정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">신뢰할 수 없는 데이터를 deserialize하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NetDataContractSerializerMethodUsedTitle">
        <source>Do not use insecure deserializer NetDataContractSerializer</source>
        <target state="translated">안전하지 않은 역직렬 변환기 NetDataContractSerializer를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">문자열이 대문자로 정규화되어야 합니다. 소규모의 문자가 소문자로 변환되면 왕복 작업을 수행할 수 없습니다. 왕복 작업은 문자를 하나의 로캘에서 문자 데이터가 다르게 표시되는 다른 로캘로 변환한 다음 변환된 문자에서 원래 문자를 정확하게 검색하는 것을 의미합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'</source>
        <target state="translated">'{0}' 메서드에서 '{1}' 호출을 '{2}'(으)로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">대문자로 문자열 정규화</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedMessage">
        <source>The method '{0}' is insecure when deserializing untrusted data.</source>
        <target state="translated">신뢰할 수 없는 데이터를 deserialize하는 경우 '{0}' 메서드는 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectStateFormatterMethodUsedTitle">
        <source>Do not use insecure deserializer ObjectStateFormatter</source>
        <target state="translated">안전하지 않은 역직렬 변환기 ObjectStateFormatter를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverridesPreviewMethodMessage">
        <source>'{0}' overrides the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}'은(는) 미리 보기 방법 '{1}'을(를) 재정의하므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverridesPreviewMethodMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' overrides the preview method '{1}' and therefore needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}'은(는) 미리 보기 방법 '{1}'을(를) 재정의하므로 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">public 형식의 public 또는 protected 메서드에 System.Runtime.InteropServices.DllImportAttribute 특성(Visual Basic의 선언 키워드에서 구현함)이 있습니다. 이러한 메서드는 노출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">P/Invoke 메서드 '{0}'을(를) 표시하지 않아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">P/Invokes를 표시하지 않아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParenthesisWithPlaceHolder">
        <source> ({0})</source>
        <target state="translated"> ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllPlatforms">
        <source>and all other platforms</source>
        <target state="translated">및 다른 모든 플랫폼</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and later, and all other platforms</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityAllVersions">
        <source>'{0}' all versions</source>
        <target state="translated">'{0}' 모든 버전</target>
        <note>This call site is reachable on: 'Windows' all versions.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityDescription">
        <source>Using platform dependent API on a component makes the code no longer work across all platforms.</source>
        <target state="translated">구성 요소에서 플랫폼 종속 API를 사용하면 모든 플랫폼에서 코드가 더 이상 작동하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityFromVersionToVersion">
        <source>'{0}' from version {1} to {2}</source>
        <target state="translated">'{0}' 버전 {1}~007E;{2}</target>
        <note>'SupportedOnWindows1903UnsupportedOn2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityObsoletedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is obsoleted on: {1}.</source>
        <target state="translated">이 통화 사이트는 모든 플랫폼에서 연결할 수 있습니다. '{0}'은(는) {1}에서 사용되지 않습니다.</target>
        <note>This call site is reachable on all platforms. 'OboletedOnMacOS()' is obsoleted on: 'macos'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityObsoletedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is obsoleted on: {1}.</source>
        <target state="translated">이 통화 사이트는 {2}에서 연결할 수 있습니다. '{0}'은(는) {1}에서 사용되지 않습니다.</target>
        <note>This call site is reachable on 'macos', 'linux'. 'OboletedOnMacOS()' is obsoleted on: 'macos'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is only supported on: {1}.</source>
        <target state="translated">이 호출 사이트에는 모든 플랫폼에서 연결할 수 있습니다. '{0}'은(는) {1}에서만 지원됩니다.</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindowsAndBrowser()' is only supported on: 'windows', 'browser' .</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">이 호출 사이트에는 {2}에서 연결할 수 있습니다. '{0}'은(는) {1}에서만 지원됩니다.</target>
        <note>This call site is reachable on: 'windows' all versions.'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityOnlySupportedCsUnreachableMessage">
        <source>This call site is unreachable on: {2}. '{0}' is only supported on: {1}.</source>
        <target state="translated">이 호출 사이트에는 {2}에서 연결할 수 없습니다. '{0}'은(는) {1}에서만 지원됩니다.</target>
        <note>This call site is unreachable on: 'browser'. 'SupportedOnWindowsAndBrowser()' is only supported on: 'browser', 'windows'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is supported on: {1}.</source>
        <target state="translated">이 호출 사이트에는 모든 플랫폼에서 연결할 수 있습니다. '{0}'은(는) {1}에서 지원됩니다.</target>
        <note>This call site is reachable on all platforms. 'SupportedOnWindows1903UnsupportedFrom2004()' is supported on: 'windows' from version 10.0.1903 to 10.0.2004.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilitySupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is supported on: {1}.</source>
        <target state="translated">이 호출 사이트에는 {2}에서 연결할 수 있습니다. '{0}'은(는) {1}에서 지원됩니다.</target>
        <note>This call site is reachable on: 'windows' 10.0.2000 and before. 'UnsupportedOnWindowsSupportedOn1903()' is supported on: 'windows' 10.0.1903 and later.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityTitle">
        <source>Validate platform compatibility</source>
        <target state="translated">플랫폼 호환성 유효성 검사</target>
        <note />
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsAllPlatformMessage">
        <source>This call site is reachable on all platforms. '{0}' is unsupported on: {1}.</source>
        <target state="translated">이 호출 사이트에는 모든 플랫폼에서 연결할 수 있습니다. '{0}'은(는) {1}에서 지원되지 않습니다.</target>
        <note>This call site is reachable on all platforms. 'UnsupportedOnWindows()' is unsupported on: 'windows'</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityUnsupportedCsReachableMessage">
        <source>This call site is reachable on: {2}. '{0}' is unsupported on: {1}.</source>
        <target state="translated">이 호출 사이트에는 {2}에서 연결할 수 있습니다. '{0}'은(는) {1}에서 지원되지 않습니다.</target>
        <note>This call site is reachable on: 'windows', 'browser'. 'UnsupportedOnBrowser()' is unsupported on: 'browser'.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndBefore">
        <source>'{0}' {1} and before</source>
        <target state="translated">'{0}' {1} 이하</target>
        <note>'SupportedOnWindowsUnsupportedFromWindows2004()' is only supported on: 'windows' 10.0.2004 and before.</note>
      </trans-unit>
      <trans-unit id="PlatformCompatibilityVersionAndLater">
        <source>'{0}' {1} and later</source>
        <target state="translated">'{0}' {1} 이상</target>
        <note>'SupportedOnWindows10()' is only supported on: 'windows' 10.0 and later.</note>
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphDescription">
        <source>Review code that processes untrusted deserialized data for handling of unexpected reference cycles. An unexpected reference cycle should not cause the code to enter an infinite loop. Otherwise, an unexpected reference cycle can allow an attacker to DOS or exhaust the memory of the process when deserializing untrusted data.</source>
        <target state="translated">신뢰할 수 없는 역직렬화된 데이터를 처리하는 코드를 검토하여 예기치 않은 참조 주기를 처리합니다. 예기치 않은 참조 주기로 인해 코드의 무한 루프가 시작되어서는 안 됩니다. 참조 주기를 처리하지 않으면 공격자가 신뢰할 수 없는 데이터를 역직렬화할 때 프로세스의 메모리를 고갈시키거나 DOS를 수행할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">{0}이(가) 잠재적 참조 순환에 참여합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PotentialReferenceCycleInDeserializedObjectGraphTitle">
        <source>Potential reference cycle in deserialized object graph</source>
        <target state="translated">역직렬화된 개체 그래프의 잠재적 참조 주기</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringCodefixTitle">
        <source>Replace 'Substring' with 'AsSpan'</source>
        <target state="translated">'Substring'을 'AsSpan'으로 바꿉니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringDescription">
        <source>'AsSpan' is more efficient than 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost.</source>
        <target state="translated">'AsSpan'은 'Substring'보다 효율적입니다. 'Substring'은 O(n) 문자열 복사를 수행하는 반면 'AsSpan'은 수행하지 않으며 일정한 비용이 듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringMessage">
        <source>Prefer 'AsSpan' over 'Substring' when span-based overloads are available</source>
        <target state="translated">범위 기반 오버로드를 사용할 수 있는 경우 'Substring'보다 'AsSpan'을 우선적으로 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAsSpanOverSubstringTitle">
        <source>Prefer 'AsSpan' over 'Substring'</source>
        <target state="translated">''Substring'보다 'AsSpan' 우선적으로 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderDescription">
        <source>'StringBuilder.Append(char)' is more efficient than 'StringBuilder.Append(string)' when the string is a single character. When calling 'Append' with a constant, prefer using a constant char rather than a constant string containing one character.</source>
        <target state="translated">문자열이 단일 문자인 경우 'StringBuilder.Append(char)'가 'StringBuilder.Append(string)'보다 효율적입니다. 상수를 사용하여 'Append'를 호출하는 경우 한 문자를 포함하는 상수 문자열 대신 상수 문자를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderMessage">
        <source>Use 'StringBuilder.Append(char)' instead of 'StringBuilder.Append(string)' when the input is a constant unit string</source>
        <target state="translated">입력이 상수 단위 문자열인 경우 'StringBuilder.Append(string)' 대신 'StringBuilder.Append(char)'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstCharOverConstUnitStringInStringBuilderTitle">
        <source>Consider using 'StringBuilder.Append(char)' when applicable</source>
        <target state="translated">해당하는 경우 'StringBuilder.Append(char)'를 사용하는 것이 좋음</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterCodeFixTitle">
        <source>Replace with 'Convert.{0}'</source>
        <target state="translated">'Convert.{0}'(으)로 대체</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterDescription">
        <source>Use 'Convert.ToHexString' or 'Convert.ToHexStringLower' when encoding bytes to a hexadecimal string representation. These methods are more efficient and allocation-friendly than using 'BitConverter.ToString' in combination with 'String.Replace' to replace dashes and 'String.ToLower'.</source>
        <target state="translated">바이트를 16진수 문자열 표현으로 인코딩할 때 'Convert.ToHexString' 또는 'Convert.ToHexStringLower'를 사용합니다. 이러한 메서드는 대시와 'String.ToLower'를 바꾸기 위해 'String.Replace'와 함께 'BitConverter.ToString'을 사용하는 것보다 효율적이고 할당에 친화적입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterMessage">
        <source>Prefer '{0}' over call chains based on '{1}'</source>
        <target state="translated">'{0}' 기반의 호출 체인보다 '{1}' 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConvertToHexStringOverBitConverterTitle">
        <source>Prefer 'Convert.ToHexString' and 'Convert.ToHexStringLower' over call chains based on 'BitConverter.ToString'</source>
        <target state="translated">'BitConverter.ToString'을 기반으로 하는 호출 체인보다 'Convert.ToHexString' 및 'Convert.ToHexStringLower'를 선호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferCountOverAnyCodeFixTitle">
        <source>Use 'Count' check instead of 'Any()'</source>
        <target state="translated">'Any()' 대신 'Count' 확인 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferCountOverAnyMessage">
        <source>Prefer comparing 'Count' to 0 rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">명확성과 성능을 위해 'Any()'를 사용하는 것보다 'Count'를 0과 비교하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyCodeFixTitle">
        <source>Use 'ContainsKey'</source>
        <target state="translated">'ContainsKey' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyDescription">
        <source>'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations.</source>
        <target state="translated">'ContainsKey'는 일반적으로 O(1)인 반면 'Keys.Contains'는 경우에 따라 O(n)일 수 있습니다. 또한 많은 사전 구현은 할당을 줄이기 위해 Keys 컬렉션을 느리게 초기화합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsKeyMessage">
        <source>Prefer 'ContainsKey' over 'Keys.Contains' for dictionary type '{0}'</source>
        <target state="translated">사전 형식 '{0}'에 대해 'Keys.Contains'보다 'ContainsKey'를 우선적으로 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsMethodsTitle">
        <source>Prefer Dictionary.Contains methods</source>
        <target state="translated">Dictionary.Contains 메서드를 우선적으로 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueCodeFixTitle">
        <source>Use 'ContainsValue'</source>
        <target state="translated">'ContainsValue' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueDescription">
        <source>Many dictionary implementations lazily initialize the Values collection. To avoid unnecessary allocations, prefer 'ContainsValue' over 'Values.Contains'.</source>
        <target state="translated">많은 사전 구현이 Values ​​컬렉션을 느리게 초기화합니다. 불필요한 할당을 피하려면 'Values.Contains'보다 'ContainsValue'를 우선적으로 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryContainsValueMessage">
        <source>Prefer 'ContainsValue' over 'Values.Contains' for dictionary type '{0}'</source>
        <target state="translated">사전 형식 '{0}'에 대해 'Values.Contains'보다 'ContainsValue'를 우선적으로 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddDescription">
        <source>Prefer a 'TryAdd' call over an 'Add' call guarded by a 'ContainsKey' check. 'TryAdd' behaves the same as 'Add', except that when the specified key already exists, it returns 'false' instead of throwing an exception.</source>
        <target state="translated">'ContainsKey' 확인으로 보호되는 'Add' 호출보다 'TryAdd' 호출을 선호합니다. 'TryAdd'는 'Add'와 동일하게 동작하지만 지정한 키가 이미 존재하는 경우 예외를 던지는 대신 'false'를 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddMessage">
        <source>To avoid double lookup, call 'TryAdd' instead of calling 'Add' with a 'ContainsKey' guard</source>
        <target state="translated">이중 조회를 방지하려면 'ContainsKey' 가드를 사용하여 'Add'를 호출하는 대신 'TryAdd'를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddTitle">
        <source>Prefer the 'IDictionary.TryAdd(TKey, TValue)' method</source>
        <target state="translated">'IDictionary.TryAdd(TKey, TValue)' 메서드 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryAddValueCodeFixTitle">
        <source>Use 'TryAdd(TKey, TValue)'</source>
        <target state="translated">'TryAdd(TKey, TValue)' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueCodeFixTitle">
        <source>Use 'TryGetValue(TKey, out TValue)'</source>
        <target state="translated">'TryGetValue(TKey, out TValue)' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueDescription">
        <source>Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check. 'ContainsKey' and the indexer both would lookup the key under the hood, so using 'TryGetValue' removes the extra lookup.</source>
        <target state="translated">'ContainsKey' 검사로 보호되는 사전 인덱서 액세스보다 'TryGetValue' 호출을 선호합니다. 'ContainsKey'와 인덱서는 모두 내부 키를 조회하므로 'TryGetValue'를 사용하면 추가 조회가 제거됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueMessage">
        <source>Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check to avoid double lookup</source>
        <target state="translated">이중 조회 방지를 위해 'ContainsKey' 검사로 보호되는 사전 인덱서 액세스보다 'TryGetValue' 호출을 선호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDictionaryTryGetValueTitle">
        <source>Prefer the 'IDictionary.TryGetValue(TKey, out TValue)' method</source>
        <target state="translated">'IDictionary.TryGetValue(TKey, out TValue)' 메서드 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsCodeFixTitle">
        <source>Use generic overload</source>
        <target state="translated">제네릭 오버로드 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsDescription">
        <source>Using a generic overload is preferable to the 'System.Type' overload when the type is known, promoting cleaner and more type-safe code with improved compile-time checks.</source>
        <target state="translated">형식이 알려진 경우 제네릭 오버로드를 사용하는 것이 'System.Type' 오버로드보다 낫기 때문에 컴파일 시간 검사를 개선하여 보다 깔끔하고 형식이 안전한 코드를 승격할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsMessage">
        <source>Prefer the generic overload '{0}' instead of '{1}'</source>
        <target state="translated">'{1}' 대신 '{0}' 제네릭 오버로드를 선호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferGenericOverloadsTitle">
        <source>Prefer generic overload when type is known</source>
        <target state="translated">형식이 알려진 경우 제네릭 오버로드 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataCodefixTitle">
        <source>Replace with 'HashData' method</source>
        <target state="translated">'HashData' 메소드로 대체</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerDescription">
        <source>It is more efficient to use the static 'HashData' method over creating and managing a HashAlgorithm instance to call 'ComputeHash'.</source>
        <target state="translated">'ComputeHash'를 호출하기 위해 HashAlgorithm 인스턴스를 생성하고 관리하는 것보다 정적 'HashData' 메서드를 사용하는 것이 더 효율적입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerMessage">
        <source>Prefer static '{0}.HashData' method over 'ComputeHash'</source>
        <target state="translated">'ComputeHash'보다 정적 '{0}.HashData' 메서드를 선호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferHashDataOverComputeHashAnalyzerTitle">
        <source>Prefer static 'HashData' method over 'ComputeHash'</source>
        <target state="translated">'ComputeHash'보다 정적 'HashData' 메서드를 선호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverAnyCodeFixTitle">
        <source>Use 'IsEmpty' check instead of 'Any()'</source>
        <target state="translated">'Any()' 대신 'IsEmpty' 확인 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverAnyMessage">
        <source>Prefer an 'IsEmpty' check rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">명확성과 성능을 위해 'Any()'를 사용하는 것보다 'IsEmpty' 확인 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountDescription">
        <source>For determining whether the object contains or not any items, prefer using 'IsEmpty' property rather than retrieving the number of items from the 'Count' property and comparing it to 0 or 1.</source>
        <target state="translated">개체에 항목이 포함되어 있는지 확인하려면 'Count' 속성의 항목 수를 검색하고 0 또는 1과 비교하는 대신 'IsEmpty' 속성을 사용하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountMessage">
        <source>Prefer 'IsEmpty' over 'Count' to determine whether the object is empty</source>
        <target state="translated">개체가 비어 있는지 확인하려면 'Count' 대신 'IsEmpty'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferIsEmptyOverCountTitle">
        <source>Prefer IsEmpty over Count</source>
        <target state="translated">Count 대신 IsEmpty 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthCountIsEmptyOverAnyDescription">
        <source>Prefer using 'IsEmpty', 'Count' or 'Length' properties whichever available, rather than calling 'Enumerable.Any()'. The intent is clearer and it is more performant than using 'Enumerable.Any()' extension method.</source>
        <target state="translated">'Enumerable.Any()'를 호출하는 것보다 사용 가능한 'IsEmpty', 'Count' 또는 'Length' 속성을 사용하는 것이 좋습니다. 의도가 더 명확하고 'Enumerable.Any()' 확장 방법을 사용하는 것보다 더 성능이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthCountIsEmptyOverAnyTitle">
        <source>Avoid using 'Enumerable.Any()' extension method</source>
        <target state="translated">'Enumerable.Any()' 확장 메서드 사용 금지</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthOverAnyCodeFixTitle">
        <source>Use 'Length' check instead of 'Any()'</source>
        <target state="translated">'Any()' 대신 'Length' 확인 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferLengthOverAnyMessage">
        <source>Prefer comparing 'Length' to 0 rather than using 'Any()', both for clarity and for performance</source>
        <target state="translated">명확성과 성능을 위해 'Any()'를 사용하는 것보다 'Length'를 0과 비교하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsDescription">
        <source>'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument. Prefer calling the memory based overloads, which are more efficient.</source>
        <target state="translated">'Stream'에 첫 번째 인수로 'Memory&lt;Byte&gt;'를 사용하는 'ReadAsync' 오버로드와 첫 번째 인수로 'ReadOnlyMemory&lt;Byte&gt;'를 사용하는 'WriteAsync' 오버로드가 있습니다. 더 효율적인 메모리 기반 오버로드를 호출하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsMessage">
        <source>Change the '{0}' method call to use the '{1}' overload</source>
        <target state="translated">'{1}' 오버로드를 사용하도록 '{0}' 메서드 호출을 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStreamAsyncMemoryOverloadsTitle">
        <source>Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</source>
        <target state="translated">'ReadAsync' 및 'WriteAsync'에 '메모리' 기반 오버로드 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfCodeFixTitle">
        <source>Replace with 'string.Contains'</source>
        <target state="translated">'string.Contains'로 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfDescription">
        <source>Calls to 'string.IndexOf' where the result is used to check for the presence/absence of a substring can be replaced by 'string.Contains'.</source>
        <target state="translated">결과가 하위 문자열의 존재 여부를 확인하는 데 사용되는 'string.IndexOf' 호출은 'string.Contains'로 바꿀 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfMessage">
        <source>Use 'string.Contains' instead of 'string.IndexOf' to improve readability</source>
        <target state="translated">가독성을 개선하기 위해 'string.IndexOf' 대신 'string.Contains'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferStringContainsOverIndexOfTitle">
        <source>Consider using 'string.Contains' instead of 'string.IndexOf'</source>
        <target state="translated">'string.IndexOf' 대신 'string.Contains' 사용 고려</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsDescription">
        <source>StringBuilder.Append and StringBuilder.Insert provide overloads for multiple types beyond System.String.  When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</source>
        <target state="translated">StringBuilder.Append 및 StringBuilder.Insert는 System.String 외의 여러 형식에 대한 오버로드를 제공합니다. 가능한 경우 ToString() 및 문자열 기반 오버로드를 사용하는 대신 강력한 형식의 오버로드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsMessage">
        <source>Remove the ToString call in order to use a strongly-typed StringBuilder overload</source>
        <target state="translated">강력한 형식의 StringBuilder 오버로드를 사용하려면 ToString 호출을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsRemoveToString">
        <source>Remove the ToString call</source>
        <target state="translated">ToString 호출 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTypedStringBuilderAppendOverloadsTitle">
        <source>Prefer strongly-typed Append and Insert method overloads on StringBuilder</source>
        <target state="translated">StringBuilder 대신 강력한 형식의 Append 및 Insert 메서드 오버로드를 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesConversionNotThrowMessage">
        <source>Starting with .NET 7 the explicit conversion '{0}' will not throw when overflowing in an unchecked context. Wrap the expression with a 'checked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">.NET 7부터는 확인되지 않은 컨텍스트에서 오버플로할 때 명시적 변환 '{0}'이(가) throw되지 않습니다. .NET 6 동작을 복원하려면 식을 'checked' 문으로 래핑합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesConversionThrowsMessage">
        <source>Starting with .NET 7 the explicit conversion '{0}' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">.NET 7부터 명시적 변환 '{0}'은(는) 확인된 컨텍스트에서 오버플로할 때 throw됩니다. .NET 6 동작을 복원하려면 'unchecked' 문으로 식을 래핑합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesDescription">
        <source>Some built-in operators added in .NET 7 behave differently when overflowing than did the corresponding user-defined operators in .NET 6 and earlier versions. Some operators that previously threw in an unchecked context now don't throw unless wrapped within a checked context. Also, some operators that did not previously throw in a checked context now throw unless wrapped in an unchecked context.</source>
        <target state="translated">.NET 7에 추가된 일부 기본 제공 연산자는 오버플로 시 .NET 6 및 이전 버전에서 해당 사용자 정의 연산자와 다르게 동작합니다. 이전에 선택되지 않은 컨텍스트에서 throw한 일부 연산자는 이제 선택한 컨텍스트 내에서 래핑되지 않는 한 throw되지 않습니다. 또한 이전에 선택한 컨텍스트에서 throw하지 않은 일부 연산자는 선택되지 않은 컨텍스트에서 래핑되지 않은 한 지금 throw합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesOperatorThrowsMessage">
        <source>Starting with .NET 7 the operator '{0}' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.</source>
        <target state="translated">.NET 7부터 연산자 '{0}'은(는) 확인된 컨텍스트에서 오버플로할 때 throw됩니다. .NET 6 동작을 복원하려면 'unchecked' 문으로 식을 래핑합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreventNumericIntPtrUIntPtrBehavioralChangesTitle">
        <source>Prevent behavioral change</source>
        <target state="translated">동작 변경 방지</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagDescription">
        <source>'Enum.HasFlag' method expects the 'enum' argument to be of the same 'enum' type as the instance on which the method is invoked and that this 'enum' is marked with 'System.FlagsAttribute'. If these are different 'enum' types, an unhandled exception will be thrown at runtime. If the 'enum' type is not marked with 'System.FlagsAttribute' the call will always return 'false' at runtime.</source>
        <target state="translated">'Enum.HasFlag' 메서드는 'enum' 인수가 이 메서드가 호출되는 인스턴스와 같은 'enum' 형식이어야 하며 이 'enum'이 'System.FlagsAttribute'로 표시되어야 합니다. 이 형식이 서로 다른 'enum' 형식이면 런타임에 처리되지 않은 예외가 throw됩니다. 'enum' 형식이 'System.FlagsAttribute'로 표시되지 않으면 호출에서 런타임에 항상 'false'를 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagMessageDifferentType">
        <source>The argument type, '{0}', must be the same as the enum type '{1}'</source>
        <target state="translated">인수 형식 '{0}'은(는) 열거형 형식 '{1}'과(와) 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentToEnumHasFlagTitle">
        <source>Provide correct 'enum' argument to 'Enum.HasFlag'</source>
        <target state="translated">'Enum.HasFlag'에 올바른 'enum' 인수 제공</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">System.String.Format으로 전달된 format 인수에 각 개체 인수에 해당하는 format 항목이 포함되지 않으며 그 반대의 경우도 마찬가지입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsInvalidFormatMessage">
        <source>The format argument is not a valid format string</source>
        <target state="translated">형식 인수가 올바른 형식 문자열이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">서식 지정 메서드에 올바른 인수를 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">서식 지정 메서드에 올바른 인수를 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyDescription">
        <source>The property 'MaxResponseHeadersLength' is measured in kilobytes, not in bytes. The provided value is multiplied by 1024, which might be greater than your intended maximum length.</source>
        <target state="translated">'MaxResponseHeadersLength' 속성은 바이트가 아닌 킬로바이트 단위로 측정됩니다. 제공된 값에 1024를 곱합니다. 이 값은 의도한 최대 길이보다 클 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyMessage">
        <source>Make sure the value '{0}' is correct. This value is measured in kilobytes, not bytes.</source>
        <target state="translated">'{0}' 값이 올바른지 확인합니다. 이 값은 바이트가 아닌 킬로바이트 단위로 측정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHttpClientHandlerMaxResponseHeaderLengthValueCorrectlyTitle">
        <source>Set 'MaxResponseHeadersLength' properly</source>
        <target state="translated">'MaxResponseHeadersLength'를 올바르게 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorDescription">
        <source>Providing a parameterless constructor that is as visible as the containing type for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions.</source>
        <target state="translated">'System.Runtime.InteropServices.SafeHandle'에서 파생된 형식에 대한 포함 형식만큼 표시되는 매개 변수 없는 생성자를 제공하면 원본 생성 interop 솔루션의 성능과 사용이 향상됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorMessage">
        <source>Provide a parameterless constructor that is as visible as the containing type for the '{0}' type that is derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="translated">'System.Runtime.InteropServices.SafeHandle'에서 파생된 '{0}' 형식에 대한 포함 형식만큼 표시되는 매개 변수 없는 생성자를 제공합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidePublicParameterlessSafeHandleConstructorTitle">
        <source>Provide a parameterless constructor that is as visible as the containing type for concrete types derived from 'System.Runtime.InteropServices.SafeHandle'</source>
        <target state="translated">'System.Runtime.InteropServices.SafeHandle'에서 파생된 구체적인 형식에 대한 포함 형식만큼 표시되는 매개 변수 없는 생성자를 제공합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesDescription">
        <source>To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods.</source>
        <target state="translated">성능을 향상시키려면 'Stream'의 서브클래스를 지정할 때 메모리 기반 비동기 메서드를 재정의하세요. 그런 다음 메모리 기반 방법의 관점에서 배열 기반 방법을 구현합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesMessage">
        <source>'{0}' overrides array-based '{1}' but does not override memory-based '{2}'. Consider overriding memory-based '{2}' to improve performance.</source>
        <target state="translated">'{0}'은(는) 배열 기반 '{1}'을 재정의하지만 메모리 기반 '{2}'은(는) 재정의하지 않습니다. 성능을 향상시키려면 메모리 기반 '{2}'을(를) 재정의하는 것이 좋습니다.</target>
        <note>0 = type that subclasses Stream directly, 1 = array-based method, 2 = memory-based method</note>
      </trans-unit>
      <trans-unit id="ProvideStreamMemoryBasedAsyncOverridesTitle">
        <source>Provide memory-based overrides of async methods when subclassing 'Stream'</source>
        <target state="translated">'Stream’의 서브클래스를 지정할 때 비동기 메서드의 메모리 기반 재정의 제공</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons when using 'CompareTo', because they lead to an allocation. Instead, use 'StringComparer' to perform case-insensitive comparisons. Switching to using 'StringComparer' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'.</source>
        <target state="translated">'CompareTo'를 사용할 때 대/소문자를 구분하지 않는 문자열 비교를 수행하기 위해 'ToLower', 'ToUpper', 'ToLowerInvariant', 'ToUpperInvariant'를 호출하지 마세요. 이로 인해 할당이 발생하게 됩니다. 대신 'StringComparer'를 사용하여 대/소문자를 구분하지 않는 비교를 수행하세요. 'StringComparer' 사용으로 전환하면 동작이 미세하게 바뀔 수 있으므로 제안을 적용한 후 정밀한 테스트를 수행하는 것이 중요합니다. 또한 문화적으로 민감한 비교가 필요하지 않은 경우에는 'StringComparer.OrdinalIgnoreCase' 사용을 고려해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerMessage">
        <source>Prefer using 'StringComparer' to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'</source>
        <target state="translated">대/소문자를 구분하지 않는 비교를 수행하기 위해 'StringComparer'를 사용하는 것을 선호하되 이로 인해 동작이 미세하게 바뀔 수 있으므로 제안을 적용한 후 정밀한 테스트를 수행하거나, 문화적으로 민감한 비교가 필요하지 않은 경우에는 'StringComparer.OrdinalIgnoreCase' 사용을 고려해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparerStringComparisonCodeFixTitle">
        <source>Use the 'string.{0}(string, StringComparison)' overload</source>
        <target state="translated">'string.{0}(string, StringComparison)' 오버로드 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons because they lead to an allocation. Instead, prefer calling the method overloads of 'Contains', 'IndexOf' and 'StartsWith' that take a 'StringComparison' enum value to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</source>
        <target state="translated">대/소문자를 구분하지 않는 문자열 비교를 수행하기 위해 'ToLower', 'ToUpper', 'ToLowerInvariant', 'ToUpperInvariant'를 호출하지 마세요. 이로 인해 할당이 발생하게 됩니다. 대신 대/소문자를 구분하지 않는 비교를 수행하기 위해 'StringComparison' 열거형 값을 사용하는 'Contains', 'IndexOf', 'StartsWith'의 메서드 오버로드를 호출하는 것이 좋습니다. 'StringComparison'을 사용하는 오버로드 사용으로 전환하면 동작이 미세하게 바뀔 수 있으므로 제안을 적용한 후 정밀한 테스트를 수행하는 것이 중요합니다. 또한 문화적으로 민감한 비교가 필요하지 않은 경우에는 'StringComparison.OrdinalIgnoreCase' 사용을 고려해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonMessage">
        <source>Prefer the string comparison method overload of '{0}' that takes a 'StringComparison' enum value to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</source>
        <target state="translated">대/소문자를 구분하지 않는 비교를 수행하기 위해 'StringComparison' 열거형 값을 사용하는 '{0}' 문자열 비교 메서드 오버로드를 선호하되 이로 인해 동작이 미세하게 바뀔 수 있으므로 제안을 적용한 후 정밀한 테스트를 수행하거나, 문화적으로 민감한 비교가 필요하지 않은 경우에는 'StringComparison.OrdinalIgnoreCase' 사용을 고려해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringComparisonTitle">
        <source>Use the 'StringComparison' method overloads to perform case-insensitive string comparisons</source>
        <target state="translated">대/소문자를 구분하지 않는 문자열 비교를 수행하려면 'StringComparison' 메서드 오버로드를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsCodeFixTitle">
        <source>Use 'string.Equals(string, StringComparison)'</source>
        <target state="translated">'string.Equals(문자열, StringComparison)' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsDescription">
        <source>Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons, as in 'string.ToLower() == string.ToLower()', because they lead to an allocation. Instead, use 'string.Equals(string, StringComparison)' to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.</source>
        <target state="translated">'string.ToLower() == string.ToLower()'처럼 대/소문자를 구분하지 않는 문자열 비교를 수행하기 위해 'ToLower', 'ToUpper', 'ToLowerInvariant', 'ToUpperInvariant'를 호출하지 마세요. 이로 인해 할당이 발생하게 됩니다. 대신 'string.Equals(string, StringComparison)'을 사용하여 대/소문자를 구분하지 않는 비교를 수행하세요. 'StringComparison'을 사용하는 오버로드 사용으로 전환하면 동작이 미세하게 바뀔 수 있으므로 제안을 적용한 후 정밀한 테스트를 수행하는 것이 중요합니다. 또한 문화적으로 민감한 비교가 필요하지 않은 경우에는 'StringComparison.OrdinalIgnoreCase' 사용을 고려해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecommendCaseInsensitiveStringEqualsMessage">
        <source>Prefer using 'string.Equals(string, StringComparison)' to perform a case-insensitive comparison, but keep in mind that this might cause subtle changes in behavior, so make sure to conduct thorough testing after applying the suggestion, or if culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'</source>
        <target state="translated">대/소문자를 구분하지 않는 비교를 수행하기 위해 'string.Equals(string, StringComparison)'를 사용하는 것을 선호하되 이로 인해 동작이 미세하게 바뀔 수 있으므로 제안을 적용한 후 정밀한 테스트를 수행하거나, 문화적으로 민감한 비교가 필요하지 않은 경우에는 'StringComparison.OrdinalIgnoreCase' 사용을 고려해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantCall">
        <source>Remove redundant call</source>
        <target state="translated">중복 호출 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantGuardCallCodeFixTitle">
        <source>Remove unnecessary call</source>
        <target state="translated">불필요한 호출 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplaceStringLiteralWithCharLiteralCodeActionTitle">
        <source>Replace string literal with char literal</source>
        <target state="translated">문자열 리터럴을 char 리터럴로 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesMessage">
        <source>Potential DLL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 DLL 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForDllInjectionVulnerabilitiesTitle">
        <source>Review code for DLL injection vulnerabilities</source>
        <target state="translated">코드에서 DLL 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesMessage">
        <source>Potential file path injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 파일 경로 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForFilePathInjectionVulnerabilitiesTitle">
        <source>Review code for file path injection vulnerabilities</source>
        <target state="translated">코드에서 파일 경로 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesMessage">
        <source>Potential information disclosure vulnerability was found where '{0}' in method '{1}' may contain unintended information from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'에 '{3}' 메서드에 있는 '{2}'의 의도하지 않은 데이터가 포함될 수 있는 잠재적인 정보 공개 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForInformationDisclosureVulnerabilitiesTitle">
        <source>Review code for information disclosure vulnerabilities</source>
        <target state="translated">코드에서 정보 공개 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesMessage">
        <source>Potential LDAP injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 LDAP 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForLdapInjectionVulnerabilitiesTitle">
        <source>Review code for LDAP injection vulnerabilities</source>
        <target state="translated">코드에서 LDAP 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesMessage">
        <source>Potential open redirect vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 오픈 리디렉션 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForOpenRedirectVulnerabilitiesTitle">
        <source>Review code for open redirect vulnerabilities</source>
        <target state="translated">코드에서 오픈 리디렉션 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesMessage">
        <source>Potential process command injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 프로세스 명령 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForProcessCommandInjectionVulnerabilitiesTitle">
        <source>Review code for process command injection vulnerabilities</source>
        <target state="translated">코드에서 프로세스 명령 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesMessage">
        <source>Potential regex injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 regex 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForRegexInjectionVulnerabilitiesTitle">
        <source>Review code for regex injection vulnerabilities</source>
        <target state="translated">코드에서 regex 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesMessage">
        <source>Potential SQL injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 SQL 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForSqlInjectionVulnerabilitiesTitle">
        <source>Review code for SQL injection vulnerabilities</source>
        <target state="translated">코드에서 SQL 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesMessage">
        <source>Potential XPath injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 XPath 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXPathInjectionVulnerabilitiesTitle">
        <source>Review code for XPath injection vulnerabilities</source>
        <target state="translated">코드에서 XPath 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesMessage">
        <source>Potential XAML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 XAML 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXamlInjectionVulnerabilitiesTitle">
        <source>Review code for XAML injection vulnerabilities</source>
        <target state="translated">코드에서 XAML 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesMessage">
        <source>Potential XML injection vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 XML 삽입 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXmlInjectionVulnerabilitiesTitle">
        <source>Review code for XML injection vulnerabilities</source>
        <target state="translated">코드에서 XML 삽입 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesMessage">
        <source>Potential cross-site scripting (XSS) vulnerability was found where '{0}' in method '{1}' may be tainted by user-controlled data from '{2}' in method '{3}'.</source>
        <target state="translated">'{1}' 메서드의 '{0}'이(가) '{3}' 메서드의 '{2}'에서 사용자 제어 데이터에 의해 감염될 수 있는 잠재적인 XSS(사이트 간 스크립팅) 취약성이 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewCodeForXssVulnerabilitiesTitle">
        <source>Review code for XSS vulnerabilities</source>
        <target state="translated">코드에서 XSS 취약성 검토</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesDescription">
        <source>SQL queries that directly use user input can be vulnerable to SQL injection attacks. Review this SQL query for potential vulnerabilities, and consider using a parameterized SQL query.</source>
        <target state="translated">사용자 입력을 직접 사용하는 SQL 쿼리는 SQL 삽입 공격에 취약할 수 있습니다. 이 SQL 쿼리에 잠재적인 취약성이 있는지 검토하고 매개 변수화된 SQL 쿼리를 사용하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesMessageNoNonLiterals">
        <source>Review if the query string passed to '{0}' in '{1}', accepts any user input</source>
        <target state="translated">'{1}'의 '{0}'에 전달되는 쿼리 문자열이 사용자 입력을 허용하는지 검토합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewSQLQueriesForSecurityVulnerabilitiesTitle">
        <source>Review SQL queries for security vulnerabilities</source>
        <target state="translated">보안상 취약한 부분이 있는지 SQL 쿼리를 검토하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesCodeFixTitle">
        <source>Seal class</source>
        <target state="translated">봉인 클래스</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesDescription">
        <source>When a type is not accessible outside its assembly and has no subtypes within its containing assembly, it can be safely sealed. Sealing types can improve performance.</source>
        <target state="translated">형식이 해당 어셈블리 외부에서 액세스할 수 없고 포함하는 어셈블리 내에 하위 형식이 없는 경우 안전하게 봉인할 수 있습니다. 봉인 유형은 성능을 향상시킬 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesMessage">
        <source>Type '{0}' can be sealed because it has no subtypes in its containing assembly and is not externally visible</source>
        <target state="translated">유형 '{0}'은(는) 포함하는 어셈블리에 하위 유형이 없고 외부에서 볼 수 없기 때문에 봉인될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealInternalTypesTitle">
        <source>Seal internal types</source>
        <target state="translated">내부 형식 봉인</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookie">
        <source>Set HttpOnly to true for HttpCookie</source>
        <target state="translated">HttpCookie에 대해 HttpOnly를 true로 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieDescription">
        <source>As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies.</source>
        <target state="translated">심층 방어 수단으로 보안에 중요한 HTTP 쿠키가 HttpOnly로 표시되어 있는지 확인합니다. 이는 웹 브라우저에서 스크립트가 쿠키에 액세스하는 것을 허용하지 않아야 함을 나타냅니다. 삽입된 악성 스크립트는 쿠키를 도용하는 일반적인 방법입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetHttpOnlyForHttpCookieMessage">
        <source>HttpCookie.HttpOnly is set to false or not set at all when using an HttpCookie. Ensure security sensitive cookies are marked as HttpOnly to prevent malicious scripts from stealing the cookies</source>
        <target state="translated">HttpCookie를 사용할 경우 HttpCookie.HttpOnly가 false로 설정되거나, 설정되지 않습니다. 악성 스크립트가 쿠키를 도용하지 못하도록 하려면 보안에 중요한 쿠키가 HttpOnly로 표시되어 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">Page에서 파생된 클래스의 ViewStateUserKey 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">ViewStateUserKey 속성을 설정하면 공격을 생성하는 데 변수를 사용할 수 없도록 개별 사용자의 뷰 상태 변수에 식별자를 할당할 수 있어 애플리케이션에 대한 공격을 방지할 수 있습니다. 그렇지 않으면 교차 사이트 요청 위조 취약성이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The class {0} derived from System.Web.UI.Page does not set the ViewStateUserKey property in the OnInit method or Page_Init method</source>
        <target state="translated">System.Web.UI.Page에서 파생된 {0} 클래스가 OnInit 메서드 또는 Page_Init 메서드에서 ViewStateUserKey 속성을 설정하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperDescription">
        <source>Specify culture to help avoid accidental implicit dependency on current culture. Using an invariant version yields consistent results regardless of the culture of an application.</source>
        <target state="translated">현재 문화권에 대한 우발적인 암시적 종속을 방지하려면 문화권을 지정하세요. 불변 버전을 사용하면 애플리케이션의 문화권에 관계없이 일관된 결과를 얻을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperMessage">
        <source>Specify a culture or use an invariant version to avoid implicit dependency on current culture</source>
        <target state="translated">현재 문화권에 대한 암시적 종속성을 피하기 위해 문화권을 지정하거나 고정 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureForToLowerAndToUpperTitle">
        <source>Specify a culture or use an invariant version</source>
        <target state="translated">문화권 지정 또는 고정 버전 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">메서드 또는 생성자는 System.Globalization.CultureInfo 매개 변수를 허용하는 오버로드가 있는 멤버를 호출하며 CultureInfo 매개 변수를 사용하는 오버로드를 호출하지 않습니다. CultureInfo 또는 System.IFormatProvider 개체가 제공되지 않으면 오버로드된 멤버가 제공한 기본값을 사용하여 원하는 결과를 모든 로캘에서 얻지 못할 수 있습니다. 결과가 사용자에게 표시되는 경우 'CultureInfo.CurrentCulture'를 'CultureInfo' 매개 변수로 지정하세요. 반면 디스크 또는 데이터베이스에 보관될 때와 같이 결과가 저장되고, 소프트웨어에서 결과에 액세스하는 경우 'CultureInfo.InvariantCulture'를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}'의 동작은 현재 사용자의 로캘 설정에 따라 다를 수 있습니다. '{1}'에서 이 호출을 '{2}'에 대한 호출로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">CultureInfo를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCurrentCulture">
        <source>Specify current culture</source>
        <target state="translated">현재 문화권 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">메서드 또는 생성자는 System.IFormatProvider 매개 변수를 허용하는 오버로드가 있는 하나 이상의 멤버를 호출하며 IFormatProvider 매개 변수를 사용하는 오버로드를 호출하지 않습니다. System.Globalization.CultureInfo 또는 IFormatProvider 개체가 제공되지 않으면 오버로드된 멤버에서 제공한 기본값을 사용하여 원하는 결과를 모든 로캘에서 얻지 못할 수 있습니다. 결과가 사용자의 입력/사용자에게 표시되는 출력을 기반으로 하는 경우 'CultureInfo.CurrentCulture'를 'IFormatProvider'로 지정하세요. 그러지 않고 디스크/데이터베이스에서 로드되고 디스크/데이터베이스에 유지될 때와 같이 소프트웨어에서 결과를 저장하고 이에 액세스하는 경우 'CultureInfo.InvariantCulture'를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}'의 동작은 현재 사용자의 로캘 설정에 따라 다를 수 있습니다. '{1}'에서 이 호출을 '{2}'에 대한 호출로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}'의 동작은 현재 사용자의 로캘 설정에 따라 다를 수 있습니다. '{1}'에서 이 호출을 '{2}'에 대한 호출로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderOptional">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Provide a value for the 'IFormatProvider' argument.</source>
        <target state="translated">'{0}' 동작은 현재 사용자의 로캘 설정에 따라 다를 수 있습니다. 'IFormatProvider' 인수에 대한 값을 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">'{0}'에서는 '{1}'을(를) 'IFormatProvider' 매개 변수로 '{2}'에 전달합니다. 이 속성이 서식 지정 메서드에 적합하지 않은 문화권을 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">'{0}'에서는 '{1}'을(를) 'IFormatProvider' 매개 변수로 '{2}'에 전달합니다. 이 속성이 서식 지정 메서드에 적합하지 않은 문화권을 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">IFormatProvider를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">플랫폼 호출 멤버는 부분적으로 신뢰하는 호출자를 허용하고, 문자열 매개 변수를 보유하며, 문자열을 명시적으로 마샬링하지 않습니다. 이로 인해 잠재적인 보안 취약성이 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">P/Invoke 문자열 인수에 대해 마샬링을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. It is recommended to use the overload with StringComparison parameter for clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">문자열 비교 작업에서는 StringComparison 매개 변수를 설정하지 않는 메서드 오버로드를 사용합니다. 의도를 명확하게 하기 위해 StringComparison 매개 변수가 있는 오버로드를 사용하는 것이 좋습니다. 목록 상자에 표시하기 위해 항목 목록을 정렬할 때와 같이 결과가 사용자에게 표시되는 경우 'StringComparison.CurrentCulture' 또는 'StringComparison.CurrentCultureIgnoreCase'를 'StringComparison' 매개 변수로 지정하세요. 파일 경로, 환경 변수 또는 레지스트리 키 및 값 등의 대/소문자를 구분하지 않는 식별자를 비교하는 경우 'StringComparison.OrdinalIgnoreCase'를 지정하세요. 반면 대/소문자를 구분하는 식별자를 비교하는 경우 'StringComparison.Ordinal'을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Message">
        <source>'{0}' has a method overload that takes a 'StringComparison' parameter. Replace this call in '{1}' with a call to '{2}' for clarity of intent.</source>
        <target state="translated">'{0}'에 'StringComparison' 매개 변수를 사용하는 메서드 오버로드가 있습니다. 의도를 명확하게 하기 위해 '{1}'의 이 호출을 '{2}'에 대한 호출로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1307Title">
        <source>Specify StringComparison for clarity</source>
        <target state="translated">명확성을 위해 StringComparison 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Description">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter, hence its behavior could vary based on the current user's locale settings. It is strongly recommended to use the overload with StringComparison parameter for correctness and clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">문자열 비교 작업에서는 StringComparison 매개 변수를 설정하지 않는 메서드 오버로드를 사용하므로 해당 동작은 현재 사용자의 로캘 설정에 따라 달라질 수 있습니다. 의도를 정확하고 명확하게 하기 위해 StringComparison 매개 변수가 있는 오버로드를 사용하는 것이 좋습니다. 목록 상자에 표시하기 위해 항목 목록을 정렬할 때와 같이 결과가 사용자에게 표시되는 경우 'StringComparison.CurrentCulture' 또는 'StringComparison.CurrentCultureIgnoreCase'를 'StringComparison' 매개 변수로 지정하세요. 파일 경로, 환경 변수 또는 레지스트리 키 및 값 등의 대/소문자를 구분하지 않는 식별자를 비교하는 경우 'StringComparison.OrdinalIgnoreCase'를 지정하세요. 반면 대/소문자를 구분하는 식별자를 비교하는 경우 'StringComparison.Ordinal'을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Message">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}'의 동작은 현재 사용자의 로캘 설정에 따라 다를 수 있습니다. '{1}'에서 이 호출을 '{2}'에 대한 호출로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonCA1310Title">
        <source>Specify StringComparison for correctness</source>
        <target state="translated">정확성을 위해 StringComparison 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticAndAbstractRequiresPreviewFeatures">
        <source>Using both 'static' and 'abstract' modifiers requires opting into preview features. See https://aka.ms/dotnet-warnings/preview-features for more information.</source>
        <target state="translated">'정적' 및 '추상' 한정자를 모두 사용하려면 미리 보기 기능을 선택해야 합니다. 자세한 내용은 https://aka.ms/dotnet-warnings/preview-features를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">String.Length 속성 또는 String.IsNullOrEmpty 메서드를 사용하면 Equals를 사용하는 것보다 훨씬 빠르게 문자열을 비교할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check</source>
        <target state="translated">같음 검사 대신 'string.Length' 속성 또는 'string.IsNullOrEmpty' 메서드를 사용하여 빈 문자열을 테스트하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">문자열 길이를 사용하여 빈 문자열을 테스트하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">이 식은 Single.Nan 또는 Double.Nan에 대한 값을 테스트합니다. Single.IsNan(단일) 또는 Double.IsNan(이중)을 사용하여 값을 테스트하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">NaN에 대해 정확하게 테스트하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">NaN에 대해 정확하게 테스트하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineDescription">
        <source>'ThreadStatic' fields should be initialized lazily on use, not with inline initialization nor explicitly in a static constructor, which would only initialize the field on the thread that runs the type's static constructor.</source>
        <target state="translated">'ThreadStatic' 필드는 인라인 초기화를 사용하거나 명시적으로 유형의 정적 생성자를 실행하는 스레드의 필드만 초기화하는 정적 생성자에서가 아니라 사용 시 느리게 초기화되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineMessage">
        <source>'ThreadStatic' fields should not use inline initialization</source>
        <target state="translated">'ThreadStatic' 필드는 인라인 초기화를 사용하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticInitializedInlineTitle">
        <source>Improper 'ThreadStatic' field initialization</source>
        <target state="translated">잘못된 'ThreadStatic' 필드 초기화</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldDescription">
        <source>'ThreadStatic' only affects static fields. When applied to instance fields, it has no impact on behavior.</source>
        <target state="translated">'ThreadStatic'은(는) 정적 필드에만 영향을 줍니다. 인스턴스 필드에 적용할 때 동작에 영향을 주지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldMessage">
        <source>Ensure 'ThreadStatic' is only used with static fields</source>
        <target state="translated">'ThreadStatic'이(가) 정적 필드에서만 사용되는지 확인</target>
        <note />
      </trans-unit>
      <trans-unit id="ThreadStaticOnNonStaticFieldTitle">
        <source>'ThreadStatic' only affects static fields</source>
        <target state="translated">'ThreadStatic'은(는) 정적 필드에만 영향을 줍니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentExceptionThrowHelperTitle">
        <source>Use ArgumentException throw helper</source>
        <target state="translated">ArgumentException throw 도우미 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentNullExceptionThrowHelperTitle">
        <source>Use ArgumentNullException throw helper</source>
        <target state="translated">ArgumentNullException throw 도우미 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArgumentOutOfRangeExceptionThrowHelperTitle">
        <source>Use ArgumentOutOfRangeException throw helper</source>
        <target state="translated">ArgumentOutOfRangeException throw 도우미 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">Array.Empty를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is often unwanted when it is implicitly used as a Span or Memory value. Use the AsSpan method to avoid the copy.</source>
        <target state="translated">배열 값에 대한 범위 기반 인덱서는 배열의 요청된 부분의 복사본을 생성합니다. 이 복사본은 암시적으로 범위 또는 메모리 값으로 사용될 경우 대개 필요하지 않습니다. 복사본이 생성되지 않도록 하려면 AsSpan 메서드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerMessage">
        <source>Use '{0}' instead of the '{1}'-based indexer on '{2}' to avoid creating unnecessary data copies</source>
        <target state="translated">불필요한 데이터 복사본을 만들지 않으려면 '{2}'에서 '{1}' 기반 인덱서 대신 '{0}'을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAStringCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on a string</source>
        <target state="translated">문자열의 범위 기반 인덱서 대신 '{0}' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerOnAnArrayCodeFixTitle">
        <source>Use `{0}` instead of Range-based indexers on an array</source>
        <target state="translated">배열의 범위 기반 인덱서 대신 '{0}' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfRangeIndexerTitle">
        <source>Use AsSpan or AsMemory instead of Range-based indexers when appropriate</source>
        <target state="translated">적절한 경우 범위 기반 인덱서 대신 AsSpan 또는 AsMemory를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanInsteadOfStringRangeIndexerDescription">
        <source>The Range-based indexer on string values produces a copy of requested portion of the string. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">문자열 값에 대한 범위 기반 인덱서는 문자열의 요청된 부분의 복사본을 생성합니다. 이 복사본은 암시적으로 ReadOnlySpan 또는 ReadOnlyMemory 값으로 사용될 경우 대개 필요하지 않습니다. 불필요한 복사본이 생성되지 않도록 하려면 AsSpan 메서드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsSpanReadOnlyInsteadOfArrayRangeIndexerDescription">
        <source>The Range-based indexer on array values produces a copy of requested portion of the array. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.</source>
        <target state="translated">배열 값에 대한 범위 기반 인덱서는 배열의 요청된 부분의 복사본을 생성합니다. 이 복사본은 암시적으로 ReadOnlySpan 또는 ReadOnlyMemory 값으로 사용될 경우 대개 필요하지 않습니다. 불필요한 복사본이 생성되지 않도록 하려면 AsSpan 메서드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextDescription">
        <source>When inside a Task-returning method, use the async version of methods, if they exist.</source>
        <target state="translated">Task 반환 메서드 내부에서 메서드의 비동기 버전이 있는 경우 이를 사용합니다.</target>
        <note>{Locked="Task"}</note>
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextMessage">
        <source>'{0}' synchronously blocks. Await '{1}' instead.</source>
        <target state="translated">'{0}'은(는) 동기적으로 차단됩니다. 대신 '{1}'을(를) 기다리세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextMessage_NoAlternative">
        <source>'{0}' synchronously blocks. Use await instead.</source>
        <target state="translated">'{0}'은(는) 동기적으로 차단됩니다. 대신 대기를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncMethodInAsyncContextTitle">
        <source>Call async methods when in an async method</source>
        <target state="translated">비동기 메서드에 있을 때 비동기 메서드 호출</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryToken">
        <source>Use antiforgery tokens in ASP.NET Core MVC controllers</source>
        <target state="translated">ASP.NET Core MVC 컨트롤러에서 위조 방지 토큰 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenDescription">
        <source>Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</source>
        <target state="translated">위조 방지 토큰의 유효성을 검사하지 않고 POST, PUT, PATCH 또는 DELETE 요청을 처리하면 교차 사이트 요청 위조 공격에 취약할 수 있습니다. 교차 사이트 요청 위조 공격은 인증된 사용자의 악성 요청을 ASP.NET Core MVC 컨트롤러로 보낼 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAutoValidateAntiforgeryTokenMessage">
        <source>Method {0} handles a {1} request without performing antiforgery token validation. You also need to ensure that your HTML form sends an antiforgery token.</source>
        <target state="translated">{0} 메서드는 위조 방지 토큰 유효성 검사를 수행하지 않고 {1} 요청을 처리합니다. 또한 HTML 양식이 위조 방지 토큰을 보내는지 확인해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedCodeFixTitle">
        <source>Replace with 'CancellationToken.ThrowIfCancellationRequested'</source>
        <target state="translated">'CancellationToken.ThrowIfCancellationRequested'로 교체</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedDescription">
        <source>'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has.</source>
        <target state="translated">'ThrowIfCancellationRequested'는 토큰이 취소되었는지 자동으로 확인하고 취소된 경우 'OperationCanceledException'을 발생시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedMessage">
        <source>Use 'ThrowIfCancellationRequested' instead of checking 'IsCancellationRequested' and throwing 'OperationCanceledException'</source>
        <target state="translated">'IsCancellationRequested'를 확인하고 'OperationCanceledException'을 발생시키는 대신 'ThrowIfCancellationRequested'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCancellationTokenThrowIfCancellationRequestedTitle">
        <source>Use 'ThrowIfCancellationRequested'</source>
        <target state="translated">'ThrowIfCancellationRequested' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatDescription">
        <source>Cache and use a 'CompositeFormat' instance as the argument to this formatting operation, rather than passing in the original format string. This reduces the cost of the formatting operation.</source>
        <target state="translated">원래 형식 문자열을 전달하는 대신 이 서식 작업에 대한 인수로 'CompositeFormat' 인스턴스를 캐시하고 사용합니다. 이렇게 하면 서식 작업 비용이 절감됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatMessage">
        <source>Cache a 'CompositeFormat' for repeated use in this formatting operation</source>
        <target state="translated">이 서식 지정 작업에서 반복적으로 사용할 수 있도록 'CompositeFormat'을 캐시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCompositeFormatTitle">
        <source>Use 'CompositeFormat'</source>
        <target state="translated">'CompositeFormat' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeDescription">
        <source>Using concrete types avoids virtual or interface call overhead and enables inlining.</source>
        <target state="translated">구체적인 형식을 사용하면 가상 또는 인터페이스 호출 오버헤드를 방지하고 인라인을 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForFieldMessage">
        <source>Change type of field '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">성능 향상을 위해 '{0}' 필드 형식을 '{1}'에서 '{2}'(으)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForLocalMessage">
        <source>Change type of variable '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">성능 향상을 위해 '{0}' 변수 형식을 '{1}'에서 '{2}'(으)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForMethodReturnMessage">
        <source>Change return type of method '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">성능 향상을 위해 '{0}' 메서드 반환 형식을 '{1}'에서 '{2}'(으)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForParameterMessage">
        <source>Change type of parameter '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">성능 향상을 위해 '{0}' 매개 변수 형식을 '{1}'에서 '{2}'(으)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeForPropertyMessage">
        <source>Change type of property '{0}' from '{1}' to '{2}' for improved performance</source>
        <target state="translated">성능 향상을 위해 속성 형식 '{0}'을(를) '{1}'에서 '{2}'(으)로 변경</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConcreteTypeTitle">
        <source>Use concrete types when possible for improved performance</source>
        <target state="translated">성능 향상을 위해 가능한 경우 구체적인 형식 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="translated">컨테이너 수준 액세스 정책 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="translated">액세스 정책 식별자가 지정되지 않아 토큰을 해지 불가능으로 만듭니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS.</source>
        <target state="translated">가능한 경우 SAS(공유 액세스 서명) 대신 Azure의 역할 기반 액세스 제어를 사용하는 것이 좋습니다. 계속 SAS를 사용해야 하는 경우 SAS를 만들 때 컨테이너 수준 액세스 정책을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttribute">
        <source>Use DefaultDllImportSearchPaths attribute for P/Invokes</source>
        <target state="translated">P/Invokes에 DefaultDllImportSearchPaths 특성 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeDescription">
        <source>By default, P/Invokes using DllImportAttribute probe a number of directories, including the current working directory for the library to load. This can be a security issue for certain applications, leading to DLL hijacking.</source>
        <target state="translated">기본적으로 DllImportAttribute를 사용하는 P/Invokes는 로드할 라이브러리의 현재 작업 디렉터리를 비롯한 여러 디렉터리를 프로브합니다. 이는 특정 애플리케이션에서 DLL 하이재킹으로 이어지는 보안 문제가 될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultDllImportSearchPathsAttributeMessage">
        <source>The method {0} didn't use DefaultDllImportSearchPaths attribute for P/Invokes.</source>
        <target state="translated">{0} 메서드는 P/Invokes에 DefaultDllImportSearchPaths 특성을 사용하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDisabledMarshallingEquivalentCodeFix">
        <source>Use equivalent code that works when marshalling is disabled</source>
        <target state="translated">마샬링이 비활성화된 경우 작동하는 동등한 코드 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdDescription">
        <source>'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'.</source>
        <target state="translated">'Environment.CurrentManagedThreadId'는 'Thread.CurrentThread.ManagedThreadId'보다 간단하고 빠릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdFix">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="translated">'Environment.CurrentManagedThreadId' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdMessage">
        <source>Use 'Environment.CurrentManagedThreadId' instead of 'Thread.CurrentThread.ManagedThreadId'</source>
        <target state="translated">'Thread.CurrentThread.ManagedThreadId' 대신 'Environment.CurrentManagedThreadId' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentCurrentManagedThreadIdTitle">
        <source>Use 'Environment.CurrentManagedThreadId'</source>
        <target state="translated">'Environment.CurrentManagedThreadId' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdDescription">
        <source>'Environment.ProcessId' is simpler and faster than 'Process.GetCurrentProcess().Id'.</source>
        <target state="translated">'Environment.ProcessId'가 'Process.GetCurrentProcess().Id'보다 더 빠르고 간단합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdFix">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">'Environment.ProcessId' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdMessage">
        <source>Use 'Environment.ProcessId' instead of 'Process.GetCurrentProcess().Id'</source>
        <target state="translated">'Process.GetCurrentProcess().Id' 대신 'Environment.ProcessId'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessIdTitle">
        <source>Use 'Environment.ProcessId'</source>
        <target state="translated">'Environment.ProcessId' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathDescription">
        <source>'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'.</source>
        <target state="translated">'Environment.ProcessPath'는 'Process.GetCurrentProcess().MainModule.FileName'보다 간단하고 빠릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathFix">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="translated">'Environment.ProcessPath' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathMessage">
        <source>Use 'Environment.ProcessPath' instead of 'Process.GetCurrentProcess().MainModule.FileName'</source>
        <target state="translated">'Process.GetCurrentProcess().MainModule.FileName' 대신 'Environment.ProcessPath' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEnvironmentProcessPathTitle">
        <source>Use 'Environment.ProcessPath'</source>
        <target state="translated">'Environment.ProcessPath' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIndexer">
        <source>Use indexer</source>
        <target state="translated">인덱서 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseInvariantVersion">
        <source>Use an invariant version</source>
        <target state="translated">고정 버전 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">운영 체제 호출 메서드가 정의되었으며 동일한 기능의 메서드가 .NET Framework 클래스 라이브러리에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Win32 API에 있는 동일한 기능의 관리되는 항목을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Win32 API에 있는 동일한 기능의 관리되는 항목을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseObjectDisposedExceptionThrowHelperTitle">
        <source>Use ObjectDisposedException throw helper</source>
        <target state="translated">ObjectDisposedException throw 도우미 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">비언어적 문자열 비교 작업에서는 StringComparison 매개 변수를 서수 또는 OrdinalIgnoreCase로 설정하지 않습니다. 매개 변수를 명시적으로 StringComparison.Ordinal 또는 StringComparison.OrdinalIgnoreCase로 설정하면 코드의 속도가 빨라지고, 정확도와 신뢰도가 더 높아집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal string comparison</source>
        <target state="translated">서수 문자열 비교 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableDescription">
        <source>Enumerable.Count() potentially enumerates the sequence while a Length/Count property is a direct access.</source>
        <target state="translated">Length/Count 속성이 직접 액세스인 동안 Enumerable.Count()는 잠재적으로 시퀀스를 열거합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableMessage">
        <source>Use the "{0}" property instead of Enumerable.Count()</source>
        <target state="translated">Enumerable.Count() 대신 "{0}" 속성을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertyInsteadOfCountMethodWhenAvailableTitle">
        <source>Use Length/Count property instead of Count() when available</source>
        <target state="translated">사용 가능한 경우 Count() 대신 Length/Count 속성을 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest-Shamir-Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="translated">충분한 키 크기로 RSA(Rivest-Shamir-Adleman) 알고리즘 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="translated">사용되는 키 크기가 너무 작으면 암호화 알고리즘이 무차별 암호 대입 공격에 취약할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">비대칭 암호화 알고리즘 {0}의 키 크기가 2048보다 작습니다. 최소 2048 키 크기, ECDH 또는 ECDSA 알고리즘이 포함된 RSA로 전환하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountDescription">
        <source>'Regex.Count' is simpler and faster than 'Regex.Matches(...).Count'.</source>
        <target state="translated">'Regex.Count'는 'Regex.Matches(...)'보다 간단하고 빠릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountFix">
        <source>Use 'Regex.Count'</source>
        <target state="translated">'Regex.Count' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountMessage">
        <source>Use 'Regex.Count' instead of 'Regex.Matches(...).Count'</source>
        <target state="translated">'Regex.Matches(...)' 대신 'Regex.Count'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexCountTitle">
        <source>Use 'Regex.Count'</source>
        <target state="translated">'Regex.Count' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchDescription">
        <source>'Regex.IsMatch' is simpler and faster than 'Regex.Match(...).Success'.</source>
        <target state="translated">'Regex.IsMatch'는 'Regex.Match(...)'보다 간단하고 빠릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchFix">
        <source>Use 'Regex.IsMatch'</source>
        <target state="translated">'Regex.IsMatch'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchMessage">
        <source>Use 'Regex.IsMatch' instead of 'Regex.Match(...).Success'</source>
        <target state="translated">Use 'Regex.IsMatch' instead of 'Regex.Match(...).Success'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRegexIsMatchTitle">
        <source>Use 'Regex.IsMatch'</source>
        <target state="translated">'Regex.IsMatch'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesCodeFixTitle">
        <source>Use 'SearchValues'</source>
        <target state="translated">'SearchValues' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesDescription">
        <source>Using a cached 'SearchValues' instance is more efficient than passing values to 'IndexOfAny'/'ContainsAny' directly.</source>
        <target state="translated">'IndexOfAny'/'ContainsAny'에 직접 값을 전달하는 것보다 캐시된 'SearchValues' 인스턴스를 사용하는 것이 더 효율적입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesMessage">
        <source>Use a cached 'SearchValues' instance for improved searching performance</source>
        <target state="translated">향상된 검색 성능을 위해 캐시된 'SearchValues' 인스턴스 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSearchValuesTitle">
        <source>Use a cached 'SearchValues' instance</source>
        <target state="translated">캐시된 'SearchValues' 인스턴스 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="translated">HTTPS를 통해 사용할 수 있는 애플리케이션은 보안 쿠키를 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">SharedAccessProtocol HttpsOnly 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">HTTPS는 네트워크 트래픽을 암호화합니다. 중요한 데이터가 공개되지 않도록 하려면 HttpOrHttps 대신 HttpsOnly를 사용하여 네트워크 트래픽을 상시 암호화하도록 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly.</source>
        <target state="translated">가능한 경우 SAS(공유 액세스 서명) 대신 Azure의 역할 기반 액세스 제어를 사용하는 것이 좋습니다. 계속 SAS를 사용해야 하는 경우 SharedAccessProtocol.HttpsOnly를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatCodeFixTitle">
        <source>Use 'AsSpan' with 'string.Concat'</source>
        <target state="translated">'string.Concat'과 함께 'AsSpan' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatDescription">
        <source>It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator.</source>
        <target state="translated">'Substring' 및 연결 연산자 대신 'AsSpan' 및 'string.Concat'을 사용하는 것이 더 효율적입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatMessage">
        <source>Use span-based 'string.Concat' and 'AsSpan' instead of 'Substring'</source>
        <target state="translated">'Substring' 대신 스팬 기반 'string.Concat' 및 'AsSpan' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanBasedStringConcatTitle">
        <source>Use span-based 'string.Concat'</source>
        <target state="translated">범위 기반 'string.Concat' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillCodeFixTitle">
        <source>Use 'Clear()'</source>
        <target state="translated">'Clear()' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillDescription">
        <source>It is more efficient to use 'Clear', instead of 'Fill' with default value.</source>
        <target state="translated">기본값으로 'Fill' 대신 'Clear'를 사용하는 것이 더 효율적입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillMessage">
        <source>Prefer 'Span&lt;T&gt;.Clear()' instead of 'Span&lt;T&gt;.Fill(default)'</source>
        <target state="translated">'Span&lt;T&gt;.Fill(기본값)'보다 'Span&lt;T&gt;.Clear()' 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpanClearInsteadOfFillTitle">
        <source>Prefer 'Clear' over 'Fill'</source>
        <target state="translated">'채우기'보다 '지우기' 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFixTitle">
        <source>Use 'StartsWith'</source>
        <target state="translated">'StartsWith' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroDescription">
        <source>It is both clearer and faster to use 'StartsWith' instead of comparing the result of 'IndexOf' to zero.</source>
        <target state="translated">'IndexOf'의 결과를 0과 비교하는 대신 'StartsWith'를 사용하는 것이 더 명확하고 빠릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroMessage">
        <source>Use 'StartsWith' instead of comparing the result of 'IndexOf' to 0</source>
        <target state="translated">'IndexOf'의 결과를 0과 비교하는 대신 'StartsWith' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStartsWithInsteadOfIndexOfComparisonWithZeroTitle">
        <source>Use 'StartsWith' instead of 'IndexOf'</source>
        <target state="translated">'IndexOf' 대신 'StartsWith' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersDescription">
        <source>'string.Contains(char)' is available as a better performing overload for single char lookup.</source>
        <target state="translated">'string.Contains(char)'는 단일 문자 조회를 위한 더 나은 성능의 오버로드로 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.Contains(char)' instead of 'string.Contains(string)' when searching for a single character</source>
        <target state="translated">단일 문자 검색 시 'string.Contains(string)' 대신 'string.Contains(char)' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringContainsCharOverloadWithSingleCharactersTitle">
        <source>Use char literal for a single character lookup</source>
        <target state="translated">단일 문자 조회에 char 리터럴 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareCodeFixTitle">
        <source>Use 'string.Equals'</source>
        <target state="translated">'string.Equals' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareDescription">
        <source>It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero.</source>
        <target state="translated">'string.Compare'의 결과를 0과 비교하는 대신 'string.Equals'를 사용하는 것이 더욱 명확하고 빠를 가능성이 높습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareMessage">
        <source>Use 'string.Equals' instead of comparing the result of 'string.Compare' to 0</source>
        <target state="translated">'string.Compare'의 결과를 0과 비교하는 대신 'string.Equals'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringEqualsOverStringCompareTitle">
        <source>Use 'string.Equals'</source>
        <target state="translated">'string.Equals' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersDescription">
        <source>The char overload is a better performing overload than a string with a single char.</source>
        <target state="translated">문자 오버로드는 단일 문자가 포함된 문자열보다 성능이 뛰어난 오버로드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersMessage">
        <source>Use 'string.{0}(char)' instead of 'string.{0}(string)' when you have a string with a single char</source>
        <target state="translated">단일 문자가 포함된 문자열이 있는 경우 'string.{0}(string)' 대신 'string.{0}(char)'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseStringMethodCharOverloadWithSingleCharactersTitle">
        <source>Use char overload</source>
        <target state="translated">char 오버로드 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperDescription">
        <source>Throw helpers are simpler and more efficient than an if block constructing a new exception instance.</source>
        <target state="translated">throw 도우미는 새로운 예외 인스턴스를 구성하는 if 블록보다 간단하고 효율적입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperFix">
        <source>Use '{0}.{1}'</source>
        <target state="translated">'{0}.{1}' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseThrowHelperMessage">
        <source>Use '{0}.{1}' instead of explicitly throwing a new exception instance</source>
        <target state="translated">새 예외 인스턴스를 명시적으로 throw하는 대신 '{0}.{1}' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringDescription">
        <source>Platform compatibility analyzer requires a valid platform name and version.</source>
        <target state="translated">플랫폼 호환성 분석기에는 유효한 플랫폼 이름과 버전이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringInvalidVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Use a version with 2{2} parts for this platform.</source>
        <target state="translated">버전 '{0}'은(는) 플랫폼 '{1}'에 유효하지 않습니다. 이 플랫폼에는 2{2} 부분이 있는 버전을 사용하세요.</target>
        <note>Version '7' is not valid for platform 'windows'. Use a version with 2-4 parts for this platform.</note>
      </trans-unit>
      <trans-unit id="UseValidPlatformStringNoVersion">
        <source>Version '{0}' is not valid for platform '{1}'. Do not use versions for this platform.</source>
        <target state="translated">버전 '{0}'은(는) 플랫폼 '{1}'에 유효하지 않습니다. 이 플랫폼의 버전을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringTitle">
        <source>Use valid platform string</source>
        <target state="translated">유효한 플랫폼 문자열 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValidPlatformStringUnknownPlatform">
        <source>The platform '{0}' is not a known platform name</source>
        <target state="translated">플랫폼 '{0}'은(는) 알려진 플랫폼 이름이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyDescription">
        <source>ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</source>
        <target state="translated">멤버 호출에서 반환되는 ValueTasks는 바로 대기되기 위한 것입니다. ValueTask를 여러 번 사용하거나, 완료가 확인되기 전에 해당 결과에 바로 액세스하면 예외나 손상이 발생할 수 있습니다.  이러한 ValueTask를 무시하면 기능 버그가 발생하거나 성능이 저하될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_AccessingIncompleteResult">
        <source>ValueTask instances should not have their result directly accessed unless the instance has already completed. Unlike Tasks, calling Result or GetAwaiter().GetResult() on a ValueTask is not guaranteed to block until the operation completes. If you can't simply await the instance, consider first checking its IsCompleted property (or asserting it's true if you know that to be the case).</source>
        <target state="translated">ValueTask 인스턴스는 이미 완료된 경우를 제외하고는 결과에 직접 액세스할 수 없습니다. 작업과 달리 ValueTask의 Result 또는 GetAwaiter().GetResult() 호출은 작업이 완료될 때까지 차단된다고 보장되지 않습니다. 인스턴스를 대기할 수 없으면 먼저 해당 IsCompleted 속성을 확인하거나 경우에 따라 true인지 확인하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_DoubleConsumption">
        <source>ValueTask instances should only be consumed once, such as via an await. Consuming the same ValueTask instance multiple times can result in exceptions and data corruption.</source>
        <target state="translated">ValueTask 인스턴스는 대기를 통하는 등 한 번만 사용할 수 있습니다. 동일한 ValueTask 인스턴스를 여러 번 사용하면 예외와 데이터 손상이 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_General">
        <source>ValueTask instances returned from method calls should be directly awaited, returned, or passed as an argument to another method call. Other usage, such as storing an instance into a local or a field, is likely an indication of a bug, as ValueTask instances must only ever be consumed once.</source>
        <target state="translated">메서드 호출에서 반환되는 ValueTask 인스턴스는 바로 대기되거나, 반환되거나, 다른 메서드 호출의 인수로 전달되어야 합니다. ValueTask 인스턴스는 한 번만 사용되어야 하므로 인스턴스를 로컬 또는 필드에 저장하는 등의 다른 사용은 버그를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyMessage_Unconsumed">
        <source>ValueTask instances returned from method calls should always be used, typically awaited. Not doing so often represents a functional bug, but even if it doesn't, it can result in degraded performance if the target method pools objects for use with ValueTasks.</source>
        <target state="translated">메서드 호출에서 반환되는 ValueTask 인스턴스는 항상 사용되어야 하며, 일반적으로 대기됩니다. 그러지 않으면 기능 버그를 나타내는 경우가 많습니다. 그러지 않더라도 대상 메서드에서 ValueTasks와 함께 사용할 개체를 풀링하는 경우 성능이 저하될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseValueTasksCorrectlyTitle">
        <source>Use ValueTasks correctly</source>
        <target state="translated">올바르게 ValueTasks 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">신뢰할 수 없는 데이터의 XML을 처리하면 위험한 외부 참조가 로드될 수 있습니다. 위험한 외부 참조는 안전한 확인자와 함께 또는 DTD 처리를 사용하지 않도록 설정한 상태로 XmlReader를 사용하여 제한해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader for 'DataSet.ReadXml()'</source>
        <target state="translated">'DataSet.ReadXml()'에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader for 'XmlSerializer.Deserialize()'</source>
        <target state="translated">'XmlSerializer.Deserialize()'에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader for 'XmlSchema.Read()'</source>
        <target state="translated">'XmlSchema.Read()'에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader for XmlValidatingReader constructor</source>
        <target state="translated">XmlValidatingReader 생성자에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader for XPathDocument constructor</source>
        <target state="translated">XPathDocument 생성자에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the '{0}.{1}' method is potentially unsafe. It may enable Document Type Definition (DTD) which can be vulnerable to denial of service attacks, or might use an XmlResolver which can be vulnerable to information disclosure. Use an overload that takes a XmlReader instance instead, with DTD processing disabled and no XmlResolver.</source>
        <target state="translated">'{0}.{1}' 메서드의 이 오버로드는 잠재적으로 안전하지 않습니다. 서비스 거부 공격에 취약할 수 있는 DTD(문서 종류 정의)를 사용하도록 설정하거나 정보 공개에 취약할 수 있는 XmlResolver를 사용할 수 있습니다. 대신 DTD 처리를 사용할 수 없고 XmlResolver가 없는 XmlReader 인스턴스를 사용하는 오버로드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsesPreviewTypeParameterMessage">
        <source>'{0}' uses the preview type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">'{0}'은(는) 미리 보기 유형 '{1}'을(를) 사용하고 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}을(를) 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsesPreviewTypeParameterMessageWithCustomMessagePlaceholder">
        <source>{3} '{0}' uses the preview type '{1}' and needs to opt into preview features. See {2} for more information.</source>
        <target state="translated">{3} '{0}'은(는) 미리 보기 유형 '{1}'을(를) 사용하며 미리 보기 기능을 선택해야 합니다. 자세한 내용은 {2}(을)를 참조하세요.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>