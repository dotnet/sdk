<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../MicrosoftNetFrameworkAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidDuplicateAcceleratorsTitle">
        <source>Avoid duplicate accelerators</source>
        <target state="translated">避免快捷键重复</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateAcceleratorsDescription">
        <source>An access key, also known as an accelerator, enables keyboard access to a control by using the ALT key. When multiple controls have duplicate access keys, the behavior of the access key is not well defined.</source>
        <target state="translated">访问键也称为快捷键，它通过使用 Alt 键来实现对控件的键盘访问。如果多个控件具有重复的访问键，表示访问键的行为定义不正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateAcceleratorsMessage">
        <source>Avoid duplicate accelerators</source>
        <target state="translated">避免快捷键重复</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesTitle">
        <source>Set locale for data types</source>
        <target state="translated">设置数据类型的区域设置</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesDescription">
        <source>The locale determines culture-specific presentation elements for data, such as formatting that is used for numeric values, currency symbols, and sort order. When you create a DataTable or DataSet, you should explicitly set the locale.</source>
        <target state="translated">区域设置决定数据的区域性特定显示元素，例如，数值、货币符号和排序顺序所用的格式。在创建 DataTable 或 DataSet 时，应显式设置区域设置。</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesMessage">
        <source>Set locale for data types</source>
        <target state="translated">设置数据类型的区域设置</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodTitle">
        <source>Do not mark serviced components with WebMethod</source>
        <target state="translated">不要使用 WebMethod 标记服务组件</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodDescription">
        <source>A method in a type that inherits from System.EnterpriseServices.ServicedComponent is marked by using System.Web.Services.WebMethodAttribute. Because WebMethodAttribute and a ServicedComponent method have conflicting behavior and requirements for context and transaction flow, the behavior of the method will be incorrect in some scenarios.</source>
        <target state="translated">某类型中从 System.EnterpriseServices.ServicedComponent 继承的方法是使用 System.Web.Services.WebMethodAttribute 标记的。由于 WebMethodAttribute 和 ServicedComponent 方法在上下文和事务流方面的行为和要求有冲突，因此该方法的行为在某些情况下不正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodMessage">
        <source>Do not mark serviced components with WebMethod</source>
        <target state="translated">不要使用 WebMethod 标记服务组件</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesTitle">
        <source>Call base class methods on ISerializable types</source>
        <target state="translated">对 ISerializable 类型调用基类方法</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesDescription">
        <source>To fix a violation of this rule, call the base type GetObjectData method or serialization constructor from the corresponding derived type method or constructor.</source>
        <target state="translated">要解决与该规则的冲突，请从相应的派生类型方法或构造函数调用基类型 GetObjectData 方法或序列化构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesMessage">
        <source>Call base class methods on ISerializable types</source>
        <target state="translated">对 ISerializable 类型调用基类方法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptions">
        <source>Do Not Catch Corrupted State Exceptions</source>
        <target state="translated">不要捕获损坏状态异常</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsDescription">
        <source>Catching corrupted state exceptions could mask errors (such as access violations), resulting in inconsistent state of execution or making it easier for attackers to compromise system. Instead, catch and handle a more specific set of exception type(s) or re-throw the exception.</source>
        <target state="translated">捕获损坏状态异常可能会掩盖错误(例如访问冲突)，从而导致执行状态不一致或使攻击者更轻易地危害系统安全。相反，请捕获并处理一组更具体的异常类型或重新引发异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsMessage">
        <source>{0} is catching corrupted state exception</source>
        <target state="translated">{0} 正在捕获损坏状态异常</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesTitle">
        <source>Types should not extend certain base types</source>
        <target state="translated">类型不应扩展某些基类型</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesDescription">
        <source>An externally visible type extends certain base types. Use one of the alternatives.</source>
        <target state="translated">对外部可见的类型扩展某些基类型。使用其他替代项。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemXmlXmlDocument">
        <source>Change the base type of {0} so that it no longer extends {1}. The preferred design is to decouple the underlying XmlDocument representation from the type's interface by using containment instead of inheritance.</source>
        <target state="translated">更改 {0} 的基类型，使其不再扩展 {1}。首选设计是使用包含而不是继承将基础 XmlDocument 表示形式与类型的接口分离。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemApplicationException">
        <source>Change the base type of {0} so that it no longer extends {1}. This base exception type does not provide any additional value for framework classes. Extend 'System.Exception' or an existing unsealed exception type instead. Do not create a new exception base type unless there is specific value in enabling the creation of a catch handler for an entire class of exceptions.</source>
        <target state="translated">更改 {0} 的基类型，使其不再扩展 {1}。此异常基类型不为框架类提供任何附加值。请改为扩展 "System.Exception" 或现有非密封异常类型。不要新建异常基类型，除非在创建整个异常类的 catch 处理程序时存在特定的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsCollectionBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.Collection'.</source>
        <target state="translated">将 {0} 的基类型从 {1} 更改为等效的泛型 "System.Collections.ObjectModel.Collection"。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsDictionaryBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.KeyedCollection'.</source>
        <target state="translated">将 {0} 的基类型从 {1} 更改为等效的泛型 "System.Collections.ObjectModel.KeyedCollection"。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsQueue">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.Queue'.</source>
        <target state="translated">将 {0} 的基类型从 {1} 更改为等效的泛型 "System.Collections.Generic.Queue"。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsReadOnlyCollectionBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.ReadOnlyCollection'.</source>
        <target state="translated">将 {0} 的基类型从 {1} 更改为等效的泛型 "System.Collections.ObjectModel.ReadOnlyCollection"。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsSortedList">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.SortedList'.</source>
        <target state="translated">将 {0} 的基类型从 {1} 更改为等效的泛型 "System.Collections.Generic.SortedList"。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsStack">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.Stack'.</source>
        <target state="translated">将 {0} 的基类型从 {1} 更改为等效的泛型 "System.Collections.Generic.Stack"。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingDescription">
        <source>Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.</source>
        <target state="translated">使用 XmlTextReader.Load()、在调用 XmlReader.Create() 时创建不安全的 XmlReaderSettings 实例、设置 XmlDocument 的 InnerXml 属性以及使用 XmlUrlResolver 按非安全方式启用 DTD 处理都会导致信息泄露。请将其替换为对采用 XmlReader 实例的 Load()方法重载的调用，使用 XmlReader.Create()接受 XmlReaderSettings 参数，或者考虑对安全值进行显式设置。应始终从可靠来源分配 DataViewManager 的 DataViewSettingCollectionString 属性，应将 DtdProcessing 属性设置为 false，并将 XmlResolver 属性更改为 XmlSecureResolver 或 null。</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseDtdProcessingOverloadsMessage">
        <source>Unsafe overload of '{0}' method</source>
        <target state="translated">“{0}”方法的不安全重载</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseSetInnerXmlMessage">
        <source>Uses the unsafe setter of InnerXml property of System.Xml.XmlDocument.</source>
        <target state="translated">使用 System.Xml.XmlDocument 的 InnerXml 属性的不安全资源库。</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="InsecureXmlDtdProcessing">
        <source>Insecure DTD processing in XML</source>
        <target state="translated">XML 中不安全的 DTD 处理</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="ReviewDtdProcessingPropertiesMessage">
        <source>Property in {0} might be set from an untrusted source.</source>
        <target state="translated">{0} 中的属性可能是根据不受信任的源设置的。</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlDocumentWithNoSecureResolverMessage">
        <source>An XmlDocument instance is created without setting its XmlResolver property to a secure value</source>
        <target state="translated">在未将其 XmlResolver 属性设置为安全值的情况下创建了 XmlDocument 实例</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateInsecureConstructedMessage">
        <source>An insecure XmlReaderSettings instance is provided to XmlReader.Create method.</source>
        <target state="translated">向 XmlReader.Create 方法提供了不安全的 XmlReaderSettings 实例。</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateInsecureInputMessage">
        <source>A potentially insecure XmlReaderSettings instance is provided to XmlReader.Create method.</source>
        <target state="translated">向 XmlReader.Create 方法提供了可能不安全的 XmlReaderSettings 实例。</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateWrongOverloadMessage">
        <source>An insecure overload of XmlReader.Create which does not accept an XmlReaderSettings argument.</source>
        <target state="translated">XmlReader 的不安全重载，它不接受 XmlReaderSettings 参数。</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderConstructedWithNoSecureResolutionMessage">
        <source>XmlTextReader instance created with insecure default settings.</source>
        <target state="translated">使用不安全的默认设置创建的 XmlTextReader 实例。</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderSetInsecureResolutionMessage">
        <source>XmlTextReader instance is set with insecure values.</source>
        <target state="translated">使用不安全的值设置 XmlTextReader 实例。</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingGenericMessage">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="InsecureDtdProcessingInApiDesign">
        <source>Insecure Processing in API Design, XmlDocument and XmlTextReader</source>
        <target state="translated">API 设计、XmlDocument 和 XmlTextReader 中不安全的处理</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingInApiDesignDescription">
        <source>Enabling DTD processing on all instances derived from XmlTextReader or  XmlDocument and using XmlUrlResolver for resolving external XML entities may lead to information disclosure. Ensure to set the XmlResolver property to null, create an instance of XmlSecureResolver when processing untrusted input, or use XmlReader.Create method with a secure XmlReaderSettings argument. Unless you need to enable it, ensure the DtdProcessing property is set to false.</source>
        <target state="translated">对所有派生自 XmlTextReader 或  XmlDocument 的实例启用 DTD 处理，以及使用 XmlUrlResolver 解析外部 XML 实体，可能导致信息泄露。请确保将 XmlResolver 属性设置为 null、在处理不受信任的输入时创建 XmlSecureResolver 实例，或者使用具有安全 XmlReaderSettings 参数的 XmlReader.Create 方法。除非需要启用它，否则请确保将 DtdProcessing 属性设置为 false。</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassConstructorNoSecureXmlResolverMessage">
        <source>Constructor of XmlDocument derived class {0} implicitly uses insecure default value for DTD processing.</source>
        <target state="translated">XmlDocument 派生类 {0} 的构造函数隐式使用不安全的默认值进行 DTD 处理。</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassNoConstructorMessage">
        <source>XmlDocument derived class {0} doesn't explicitly define a constructor.</source>
        <target state="translated">XmlDocument 派生类 {0} 没有显式定义构造函数。</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassSetInsecureXmlResolverInMethodMessage">
        <source>Method {0} of XmlDocument derived class sets XmlResolver property to an insecure value.</source>
        <target state="translated">XmlDocument 派生类的方法 {0} 将 XmlResolver 属性设置为不安全的值。</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassConstructorNoSecureSettingsMessage">
        <source>Constructor of XmlTextReader derived class {0} uses insecure default values for DTD processing.</source>
        <target state="translated">XmlTextReader 派生类 {0} 的构造函数使用不安全的默认值进行 DTD 处理。</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassNoConstructorMessage">
        <source>XmlTextReader derived class {0} doesn't explicitly define a constructor.</source>
        <target state="translated">XmlTextReader 派生类 {0} 没有显式定义构造函数。</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassSetInsecureSettingsInMethodMessage">
        <source>{0} method of XmlTextReader derived class sets XmlResolver and/or DtdProcessing property to insecure value.</source>
        <target state="translated">XmlTextReader 派生类的方法 {0} 将 XmlResolver 和/或 DtdProcessing 属性设置为不安全的值。</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="InsecureXsltScriptProcessingMessage">
        <source>Insecure XSLT script processing</source>
        <target state="translated">XSLT 脚本处理不安全</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureXSLTScriptExecutionDescription">
        <source>Providing an insecure XsltSettings instance and an insecure XmlResolver instance to XslCompiledTransform.Load method is potentially unsafe as it allows processing script within XSL, which on an untrusted XSL input may lead to malicious code execution. Either replace the insecure XsltSettings argument with XsltSettings.Default or an instance that has disabled document function and script execution, or replace the XmlResolver argument with null or an XmlSecureResolver instance. This message may be suppressed if the input is known to be from a trusted source and external resource resolution from locations that are not known in advance must be supported.</source>
        <target state="translated">向 XslCompiledTransform.Load 方法提供不安全的 XsltSettings 实例和 XmlResolver 实例可能存在危害，因为它允许在 XSL 内处理脚本，这可能导致在不受信任的 XSL 输入上执行恶意代码。请将不安全的 XsltSettings 参数替换为 XsltSettings.Default 或已禁用文档函数和脚本执行的实例，或者将 XmlResolver 参数替换为 null 或 XmlSecureResolver 实例。如果已知该输入来自可靠来源，且必须支持来自事先未知位置的外部资源解析，则可能会禁止该消息。</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="XslCompiledTransformLoadInsecureConstructedMessage">
        <source>In {0} an insecure combination of XsltSettings and XmlResolver instances are provided to XslCompiledTransfor.Load as arguments.</source>
        <target state="translated">在 {0} 中，将 XsltSettings 和 XmlResolver 实例的非安全组合提供给 XslCompiledTransfor.Load 作为参数。</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="XslCompiledTransformLoadInsecureInputMessage">
        <source>In {0} an insecure combination of XsltSettings and XmlResolver instances are provided to XslCompiledTransfor.Load as arguments.</source>
        <target state="translated">在 {0} 中，将 XsltSettings 和 XmlResolver 实例的非安全组合提供给 XslCompiledTransfor.Load 作为参数。</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenGetAndOtherAndTokenMessage">
        <source>The ValidateAntiForgeryAttribute is defined with HttpVerbs.Get and at least one of HttpVerbs.Post, HttpVerbs.Put, HttpVerbs.Delete, or HttpVerbs.Patch on controller action {0}. The attribute will not be used when GET verb is used.</source>
        <target state="translated">ValidateAntiForgeryAttribute 是使用 HttpVerbs.Get 以及控制器操作 {0} 中的 HttpVerbs.Post、HttpVerbs.Put、HttpVerbs.Delete 或 HttpVerbs.Patch (至少其中之一)进行定义的。使用 GET 谓词时将不使用该属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenGetAndTokenMessage">
        <source>Using HttpVerbs.GET and ValidateAntiForgeryTokenAttribute is not supported by MVC on controller action {0}</source>
        <target state="translated">在控制器操作 {0} 上, MVC 不支持使用 HttpVerbs.GET 和 ValidateAntiForgeryTokenAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenNoVerbsMessage">
        <source>HTTP verb attributes attributes are missing on controller action {0}. The ValidateAntiForgeryTokenAttribute will not be used when GET verb is used.</source>
        <target state="translated">控制器操作 {0} 上缺少 HTTP 谓词属性。使用 GET 谓词时将不使用 ValidateAntiForgeryTokenAttribute。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenNoVerbsNoTokenMessage">
        <source>Missing ValidateAntiForgeryTokenAttribute on MVC controller action {0} which by default accepts POST requests</source>
        <target state="translated">MVC 控制器操作 {0} 上缺少默认接受 POST 请求的 ValidateAntiForgeryTokenAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenTitle">
        <source>Mark Verb Handlers With Validate Antiforgery Token</source>
        <target state="translated">具有验证防伪标记的标记谓词处理程序</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenVerbsAndNoTokenMessage">
        <source>Missing ValidateAntiForgeryTokenAttribute on controller action {0}</source>
        <target state="translated">控制器操作 {0} 上缺少 ValidateAntiForgeryTokenAttribute</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>