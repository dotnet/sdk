<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="es" original="../MicrosoftNetFrameworkAnalyzersResources.resx">
    <body>
      <trans-unit id="SpecifyMessageBoxOptionsTitle">
        <source>Specify MessageBoxOptions</source>
        <target state="translated">Especificar MessageBoxOptions</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMessageBoxOptionsDescription">
        <source>To correctly display a message box for cultures that use a right-to-left reading order, the RightAlign and RtlReading members of the MessageBoxOptions enumeration must be passed to the Show method.</source>
        <target state="translated">Para mostrar correctamente un cuadro de mensaje para las referencias culturales con escritura de derecha a izquierda, se deben pasar al método Show los miembros RightAlign y RtlReading de la enumeración MessageBoxOptions.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMessageBoxOptionsMessage">
        <source>Specify MessageBoxOptions</source>
        <target state="translated">Especificar MessageBoxOptions</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateAcceleratorsTitle">
        <source>Avoid duplicate accelerators</source>
        <target state="translated">Evitar aceleradores duplicados</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateAcceleratorsDescription">
        <source>An access key, also known as an accelerator, enables keyboard access to a control by using the ALT key. When multiple controls have duplicate access keys, the behavior of the access key is not well defined.</source>
        <target state="translated">Una tecla de acceso, también denominada acelerador, permite el acceso mediante teclado a un control utilizando la tecla ALT. Cuando varios controles tienen teclas de acceso duplicadas, no se define correctamente el comportamiento de la tecla de acceso.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateAcceleratorsMessage">
        <source>Avoid duplicate accelerators</source>
        <target state="translated">Evitar aceleradores duplicados</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesTitle">
        <source>Set locale for data types</source>
        <target state="translated">Establecer la configuración regional para tipos de datos</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesDescription">
        <source>The locale determines culture-specific presentation elements for data, such as formatting that is used for numeric values, currency symbols, and sort order. When you create a DataTable or DataSet, you should explicitly set the locale.</source>
        <target state="translated">La configuración regional determina los elementos de presentación específicos de la referencia cultural para los datos, como el formato para los valores numéricos, símbolos de moneda y criterio de ordenación. Cuando se crea DataTable o DataSet debe establecerse explícitamente la configuración regional.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesMessage">
        <source>Set locale for data types</source>
        <target state="translated">Establecer la configuración regional para tipos de datos</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodTitle">
        <source>Do not mark serviced components with WebMethod</source>
        <target state="translated">No marcar los componentes con servicio como WebMethod</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodDescription">
        <source>A method in a type that inherits from System.EnterpriseServices.ServicedComponent is marked by using System.Web.Services.WebMethodAttribute. Because WebMethodAttribute and a ServicedComponent method have conflicting behavior and requirements for context and transaction flow, the behavior of the method will be incorrect in some scenarios.</source>
        <target state="translated">Un método de un tipo que hereda de System.EnterpriseServices.ServicedComponent se marca con System.Web.Services.WebMethodAttribute. Dado que un método ServicedComponent y WebMethodAttribute tienen comportamientos y requisitos en conflicto para el flujo de transacción y el contexto, el comportamiento del método es incorrecto en algunas situaciones.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodMessage">
        <source>Do not mark serviced components with WebMethod</source>
        <target state="translated">No marcar los componentes con servicio como WebMethod</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkWindowsFormsEntryPointsWithStaThreadTitle">
        <source>Mark Windows Forms entry points with STAThread</source>
        <target state="translated">Marcar puntos de entrada de Windows Forms con STAThread</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkWindowsFormsEntryPointsWithStaThreadDescription">
        <source>STAThreadAttribute indicates that the COM threading model for the application is a single-threaded apartment. This attribute must be present on the entry point of any application that uses Windows Forms; if it is omitted, the Windows components might not work correctly.</source>
        <target state="translated">STAThreadAttribute indica que el modelo de subprocesos de COM para la aplicación es un contenedor uniproceso. Este atributo debe estar presente en el punto de entrada de cualquier aplicación que utilice Windows Forms; si se omite, los componentes de Windows podrían no funcionar correctamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkWindowsFormsEntryPointsWithStaThreadMessage">
        <source>Mark Windows Forms entry points with STAThread</source>
        <target state="translated">Marcar puntos de entrada de Windows Forms con STAThread</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesTitle">
        <source>Call base class methods on ISerializable types</source>
        <target state="translated">Llamar a métodos de clase base en tipos ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesDescription">
        <source>To fix a violation of this rule, call the base type GetObjectData method or serialization constructor from the corresponding derived type method or constructor.</source>
        <target state="translated">Para corregir una infracción de esta regla, llame al método del tipo base GetObjectData o al constructor de serialización desde el constructor o el método del tipo derivado correspondiente.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesMessage">
        <source>Call base class methods on ISerializable types</source>
        <target state="translated">Llamar a métodos de clase base en tipos ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlTitle">
        <source>Use XmlReader for DataSet ReadXml</source>
        <target state="translated">Usar XmlReader para DataSet ReadXml</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlDescription">
        <source>Do not use unsafe overloads of System.Data.DataSet.ReadXml. This API internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">No utilice sobrecargas no seguras de System.Data.DataSet.ReadXml. Esta API habilita internamente el procesado de DTD en la instancia utilizada del lector XML, y utiliza UrlResolver para resolver entidades XML externas. El resultado es la revelación de información. El contenido del sistema de archivos o los recursos compartidos de red de la máquina que procesa el XML pueden resultar expuestos al atacante. Además, un atacante puede usar esto como vector de denegación de servicio.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlMessage">
        <source>Use XmlReader for DataSet ReadXml</source>
        <target state="translated">Usar XmlReader para DataSet ReadXml</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlSchemaTitle">
        <source>Use XmlReader for DataSet ReadXmlSchema</source>
        <target state="translated">Usar XmlReader para DataSet ReadXmlSchema</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlSchemaDescription">
        <source>Do not use unsafe overloads of System.Data.DataSet.ReadXmlSchema. This API internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">No utilice sobrecargas no seguras de System.Data.DataSet.ReadXmlSchema. Esta API habilita internamente el procesado de DTD en la instancia utilizada del lector XML, y utiliza UrlResolver para resolver entidades XML externas. El resultado es la revelación de información. El contenido del sistema de archivos o los recursos compartidos de red de la máquina que procesa el XML pueden resultar expuestos al atacante. Además, un atacante puede usar esto como vector de denegación de servicio.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlSchemaMessage">
        <source>Use XmlReader for DataSet ReadXmlSchema</source>
        <target state="translated">Usar XmlReader para DataSet ReadXmlSchema</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewDataViewCollectionStringTitle">
        <source>Review DataView CollectionString</source>
        <target state="translated">Revisar DataView CollectionString</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewDataViewCollectionStringDescription">
        <source>Review code to insure that usage of System.Data.DataViewManager.DataViewSettingCollectionString input is sanitized to not contain DTD. Enabling DTD processing on the XML reader and using UrlResolver for resolving external XML entities may lead to information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Revise el código para asegurarse de que el uso de la entrada de System.Data.DataViewManager.DataViewSettingCollectionString está saneada para no contener DTD. La habilitación del procesamiento de DTD en el lector XML y el uso de UrlResolver para resolver las entidades XML externas puede provocar una revelación de información. El contenido del sistema de archivos o los recursos compartidos de red de la máquina que procesa el XML pueden resultar expuestos al atacante. Además, un atacante puede usar esto como vector de denegación de servicio.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewDataViewCollectionStringMessage">
        <source>Review DataView CollectionString</source>
        <target state="translated">Revisar DataView CollectionString</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlTitle">
        <source>Use XmlReader for DataTable ReadXml</source>
        <target state="translated">Usar XmlReader para DataTable ReadXml</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlDescription">
        <source>Do not use unsafe overloads of System.Data.DataTable.ReadXml. This API internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">No utilice sobrecargas no seguras de System.Data.DataTable.ReadXml. Esta API habilita internamente el procesado de DTD en la instancia utilizada del lector XML, y utiliza UrlResolver para resolver entidades XML externas. El resultado es la revelación de información. El contenido del sistema de archivos o los recursos compartidos de red de la máquina que procesa el XML pueden resultar expuestos al atacante. Además, un atacante puede usar esto como vector de denegación de servicio.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlMessage">
        <source>Use XmlReader for DataTable ReadXml</source>
        <target state="translated">Usar XmlReader para DataTable ReadXml</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlSchemaTitle">
        <source>Use XmlReader for DataTable ReadXmlSchema</source>
        <target state="translated">Usar XmlReader para DataTable ReadXmlSchema</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlSchemaDescription">
        <source>Checks for usage of an unsafe overload of  System.Data.DataTable.ReadXmlSchema. This API internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Comprobaciones para el uso de una sobrecarga no segura de System.Data.DataTable.ReadXmlSchema. Esta API habilita internamente el procesado de DTD en la instancia utilizada del lector XML, y utiliza UrlResolver para resolver entidades XML externas. El resultado es la revelación de información. El contenido del sistema de archivos o los recursos compartidos de red de la máquina que procesa el XML pueden resultar expuestos al atacante. Además, un atacante puede usar esto como vector de denegación de servicio.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlSchemaMessage">
        <source>Use XmlReader for DataTable ReadXmlSchema</source>
        <target state="translated">Usar XmlReader para DataTable ReadXmlSchema</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptions">
        <source>Do Not Catch Corrupted State Exceptions</source>
        <target state="translated">No tomar excepciones de estado dañado</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsDescription">
        <source>Catching corrupted state exceptions could mask errors (such as access violations), resulting in inconsistent state of execution or making it easier for attackers to compromise system. Instead, catch and handle a more specific set of exception type(s) or re-throw the exception.</source>
        <target state="needs-review-translation">La toma de excepciones de estado dañado podría enmascarar errores (como las infracciones de acceso), lo que podría originar un estado incoherente de ejecución o que los atacantes tuvieran más fácil poner el sistema en peligro. Lo que debe hacer es tomar y controlar un conjunto más específico de tipos de excepción o iniciar de nuevo la excepción.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsMessage">
        <source>{0} is catching corrupted state exception</source>
        <target state="needs-review-translation">{0} está tomando una excepción de estado dañado.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesTitle">
        <source>Types should not extend certain base types</source>
        <target state="translated">Los tipos no deben extender ciertos tipos base</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesDescription">
        <source>An externally visible type extends certain base types. Use one of the alternatives.</source>
        <target state="translated">Un tipo visible externamente extiende algunos tipos base. Use una de las alternativas.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemXmlXmlDocument">
        <source>Change the base type of {0} so that it no longer extends {1}. The preferred design is to decouple the underlying XmlDocument representation from the type's interface by using containment instead of inheritance.</source>
        <target state="translated">Cambie el tipo base de {0} de manera que deje de extender {1}. El diseño preferido es desasociar la representación de XmlDocument subyacente de la interfaz del tipo usando independencia en lugar de herencia.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemApplicationException">
        <source>Change the base type of {0} so that it no longer extends {1}. This base exception type does not provide any additional value for framework classes. Extend 'System.Exception' or an existing unsealed exception type instead. Do not create a new exception base type unless there is specific value in enabling the creation of a catch handler for an entire class of exceptions.</source>
        <target state="translated">Cambie el tipo base de {0} de manera que deje de extender {1}. Este tipo de excepción base no proporciona ningún valor adicional para las clases de marco. Extienda "System.Exception" o un tipo de excepción no sellada existente en su lugar. No cree un nuevo tipo de base de excepción a menos que haya un valor específico al permitir la creación de un controlador de catch para una clase completa de excepciones.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsCollectionBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.Collection'.</source>
        <target state="translated">Cambie el tipo base de {0} de {1} a su equivalente genérico "System.Collections.ObjectModel.Collection".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsDictionaryBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.KeyedCollection'.</source>
        <target state="translated">Cambie el tipo base de {0} de {1} a su equivalente genérico "System.Collections.ObjectModel.KeyedCollection".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsQueue">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.Queue'.</source>
        <target state="translated">Cambie el tipo base de {0} de {1} a su equivalente genérico "System.Collections.Generic.Queue".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsReadOnlyCollectionBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.ReadOnlyCollection'.</source>
        <target state="translated">Cambie el tipo base de {0} de {1} a su equivalente genérico "System.Collections.ObjectModel.ReadOnlyCollection".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsSortedList">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.SortedList'.</source>
        <target state="translated">Cambie el tipo base de {0} de {1} a su equivalente genérico "System.Collections.Generic.SortedList".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsStack">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.Stack'.</source>
        <target state="translated">Cambie el tipo base de {0} de {1} a su equivalente genérico "System.Collections.Generic.Stack".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingDescription">
        <source>Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null. </source>
        <target state="translated">El uso de XmlTextReader.Load(), la creación de una instancia no segura de XmlReaderSettings al invocar XmlReader.Create(), el establecimiento de la propiedad InnerXml de XmlDocument y la habilitación del procesamiento de DTD usando XmlUrlResolver de manera no segura puede conducir a la divulgación de información. Reemplácelo por una llamada a la sobrecarga del método Load() que toma una instancia de XmlReader, use XmlReader.Create() para aceptar argumentos de XmlReaderSettings o considere el establecimiento explícito de valores seguros. La propiedad DataViewSettingCollectionString de DataViewManager siempre debe asignarse desde un origen confiable, la propiedad DtdProcessing debe establecerse en false y la propiedad XmlResolver debe cambiarse a XmlSecureResolver o a un valor nulo. </target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseDtdProcessingOverloadsMessage">
        <source>Unsafe overload of '{0}' method</source>
        <target state="translated">Sobrecarga no segura del método "{0}"</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseDtdProcessingOverloads">
        <source>Insecure DTD Processing</source>
        <target state="translated">Procesamiento de DTD no seguro</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseSetInnerXmlMessage">
        <source>Uses the unsafe setter of InnerXml property of System.Xml.XmlDocument.</source>
        <target state="translated">Usa el establecedor no seguro de la propiedad InnerXml de System.Xml.XmlDocument.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="InsecureXmlDtdProcessing">
        <source>Insecure DTD processing in XML</source>
        <target state="translated">Procesamiento de DTD no seguro en XML</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="ReviewDtdProcessingPropertiesMessage">
        <source>Property in {0} might be set from an untrusted source.</source>
        <target state="translated">La propiedad de {0} puede establecerse a partir de un origen que no es de confianza.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlDocumentWithNoSecureResolverMessage">
        <source>An XmlDocument instance is created without setting its XmlResolver property to a secure value.</source>
        <target state="translated">Una instancia de XmlDocument se crea sin configurar su propiedad XmlResolver en un valor seguro.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateInsecureConstructedMessage">
        <source>An insecure XmlReaderSettings instance is provided to XmlReader.Create method.</source>
        <target state="translated">Se proporciona una instancia XmlReaderSettings no segura al método XmlReader.Create.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateInsecureInputMessage">
        <source>A potentially insecure XmlReaderSettings instance is provided to XmlReader.Create method.</source>
        <target state="translated">Se proporciona una instancia XmlReaderSettings potencialmente no segura al método XmlReader.Create.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateWrongOverloadMessage">
        <source>An insecure overload of XmlReader.Create which does not accept an XmlReaderSettings argument.</source>
        <target state="translated">Una sobrecarga no segura de XmlReader.Create que no acepta un argumento XmlReaderSettings.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderConstructedWithNoSecureResolutionMessage">
        <source>XmlTextReader instance created with insecure default settings.</source>
        <target state="translated">Instancia XmlTextReader creada con una configuración predeterminada no segura.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderSetInsecureResolutionMessage">
        <source>XmlTextReader instance is set with insecure values.</source>
        <target state="translated">La instancia XmlTextReader se establece con valores no seguros.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingGenericMessage">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="InsecureDtdProcessingInApiDesign">
        <source>Insecure Processing in API Design, XmlDocument and XmlTextReader</source>
        <target state="translated">Procesamiento no seguro en API Design, XmlDocument y XmlTextReader</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingInApiDesignDescription">
        <source>Enabling DTD processing on all instances derived from XmlTextReader or  XmlDocument and using XmlUrlResolver for resolving external XML entities may lead to information disclosure. Ensure to set the XmlResolver property to null, create an instance of XmlSecureResolver when processing untrusted input, or use XmlReader.Create method with a secure XmlReaderSettings argument. Unless you need to enable it, ensure the DtdProcessing property is set to false. </source>
        <target state="translated">La habilitación del procesamiento de DTD en todas las instancias derivadas de XmlTextReader o XmlDocument y el uso de UrlResolver para resolver las entidades XML externas puede provocar una revelación de información. Asegúrese de establecer la propiedad XmlResolver en un valor nulo, crear una instancia de XmlSecureResolver al procesar una entrada que no sea de confianza o utilizar el método XmlReader.Create con un argumento XmlReaderSettings seguro. A menos que necesite habilitarla, asegúrese de que la propiedad DtdProcessing se establece en false. </target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassConstructorNoSecureXmlResolverMessage">
        <source>Constructor of XmlDocument derived class {0} implicitly uses insecure default value for DTD processing.</source>
        <target state="translated">El constructor de la clase derivada de XmlDocument {0} usa de manera implícita el valor predeterminado no seguro para el procesamiento de DTD.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassNoConstructorMessage">
        <source>XmlDocument derived class {0} doesn't explictily define a constructor.</source>
        <target state="translated">La clase derivada de XmlDocument {0} no define explícitamente un constructor.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassSetInsecureXmlResolverInMethodMessage">
        <source>Method {0} of XmlDocument derived class sets XmlResolver property to an insecure value.</source>
        <target state="translated">El método {0} de la clase derivada de XmlDocument establece una propiedad XmlResolver en un valor no seguro.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassConstructorNoSecureSettingsMessage">
        <source>Constructor of XmlTextReader derived class {0} uses insecure default values for DTD processing.</source>
        <target state="translated">El constructor de la clase derivada de XmlTextReader {0} usa valores predeterminados no seguros para el procesamiento de DTD.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassNoConstructorMessage">
        <source>XmlTextReader derived class {0} doesn't explictily define a constructor.</source>
        <target state="translated">La clase derivada de XmlTextReader {0} no define explícitamente un constructor.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassSetInsecureSettingsInMethodMessage">
        <source>{0} method of XmlTextReader derived class sets XmlResolver and/or DtdProcessing property to insecure value.</source>
        <target state="translated">El método {0} de la clase derivada de XmlTextReader establece la propiedad XmlResolver o DtdProcessing en un valor no seguro.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="InsecureXsltScriptProcessingMessage">
        <source>Insecure XSLT script processing.</source>
        <target state="translated">Procesamiento no seguro de script de XSLT.</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureXSLTScriptExecutionDescription">
        <source>Providing an insecure XsltSettings instance and an insecure XmlResolver instance to XslCompiledTransform.Load method is potentially unsafe as it allows processing script within XSL, which on an untrusted XSL input may lead to malicious code execution. Either replace the insecure XsltSettings argument with XsltSettings.Default or an instance that has disabled document function and script execution, or replace the XmlResolver argurment with null or an XmlSecureResolver instance. This message may be suppressed if the input is known to be from a trusted source and external resource resolution from locations that are not known in advance must be supported.</source>
        <target state="translated">Provisión de una instancia de XsltSettings no segura y una instancia de XmlResolver no segura a XslCompiledTransform. El método de carga es potencialmente no seguro porque permite el procesamiento del script en XSL, sobre el que una entrada de XSL que no sea de confianza podría conducir a la ejecución de código malintencionado. Reemplace el argumento XsltSettings no seguro por XsltSettings.Default o una instancia que tenga deshabilitada la función de documento y la ejecución de script, o reemplace el argumento XmlResolver por un valor nulo o una instancia de XmlSecureResolver. Este mensaje se puede eliminar si se sabe que la entrada procede de un origen de confianza y debe admitirse la resolución de recursos externos procedentes de ubicaciones que no se conocen previamente.</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="XslCompiledTransformLoadInsecureConstructedMessage">
        <source>In {0} an insecure combination of XsltSettings and XmlResolver instances are provided to XslCompiledTransfor.Load as arguments.</source>
        <target state="translated">En {0}, se proporciona una combinación no segura de instancias de XsltSettings y XmlResolver a XslCompiledTransfor.Load como argumento.</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="XslCompiledTransformLoadInsecureInputMessage">
        <source>In {0} an insecure combination of XsltSettings and XmlResolver instances are provided to XslCompiledTransfor.Load as arguments.</source>
        <target state="translated">En {0}, se proporciona una combinación no segura de instancias de XsltSettings y XmlResolver a XslCompiledTransfor.Load como argumento.</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenGetAndOtherAndTokenMessage">
        <source>The ValidateAntiForgeryAttribute is defined with HttpVerbs.Get and at least one of HttpVerbs.Post, HttpVerbs.Put, HttpVerbs.Delete, or HttpVerbs.Patch on controller action {0}. The attribute will not be used when GET verb is used.</source>
        <target state="translated">El valor ValidateAntiForgeryAttribute se define con HttpVerbs.Get y al menos uno de HttpVerbs.Post, HttpVerbs.Put, HttpVerbs.Delete o HttpVerbs.Patch en la acción del controlador {0}. El atributo no se utilizará cuando se use el verbo GET.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenGetAndTokenMessage">
        <source>Using HttpVerbs.GET and ValidateAntiForgeryTokenAttribute is not supported by MVC on controller action {0}</source>
        <target state="needs-review-translation">El uso de HttpVerbs.GET y ValidateAntiForgeryTokenAttribute no es compatible con MVC en la acción del controlador {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenNoVerbsMessage">
        <source>HTTP verb attributes attributes are missing on controller action {0}. The ValidateAntiForgeryTokenAttribute will not be used when GET verb is used.</source>
        <target state="translated">Los atributos de verbo HTTP faltan en la acción del controlador {0}. El valor ValidateAntiForgeryTokenAttribute no se utilizará cuando se utilice el verbo GET.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenNoVerbsNoTokenMessage">
        <source>Missing ValidateAntiForgeryTokenAttribute on MVC controller action {0} which by default accepts POST requests</source>
        <target state="needs-review-translation">Falta ValidateAntiForgeryTokenAttribute en la acción {0} del controlador de MVC, que de manera predeterminada acepta solicitudes POST.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenTitle">
        <source>Mark Verb Handlers With Validate Antiforgery Token</source>
        <target state="translated">Marcar los controladores de verbos con validación de token antifalsificación</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkVerbHandlersWithValidateAntiforgeryTokenVerbsAndNoTokenMessage">
        <source>Missing ValidateAntiForgeryTokenAttribute on controller action {0}</source>
        <target state="needs-review-translation">Falta ValidateAntiForgeryTokenAttribute en la acción del controlador {0}.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>