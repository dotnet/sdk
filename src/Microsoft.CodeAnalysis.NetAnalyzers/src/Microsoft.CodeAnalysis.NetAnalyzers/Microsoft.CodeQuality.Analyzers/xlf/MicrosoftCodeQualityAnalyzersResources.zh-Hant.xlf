<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../MicrosoftCodeQualityAnalyzersResources.resx">
    <body>
      <trans-unit id="AppendConfigureAwaitTrue">
        <source>Append .ConfigureAwait(true)</source>
        <target state="translated">附加 .ConfigureAwait(true)</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementDescription">
        <source>Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements.</source>
        <target state="translated">不建議在相同的陳述式中指派給符號及其成員 (欄位/屬性)。如果成員存取要在指派之前使用符號的舊值，或在此陳述式的指派中有新值，則不明確。為清晰起見，請考慮將指派分割為不同的陳述式。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementMessage">
        <source>Symbol '{0}' and its member '{1}' are both assigned in the same statement. You are at risk of assigning the member of an unintended object.</source>
        <target state="translated">符號 '{0}' 及其成員 '{1}' 兩者都指派在相同的陳述式中。您有指派非預期物件成員的風險。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementTitle">
        <source>Assigning symbol and its member in the same statement</source>
        <target state="translated">在相同的陳述式中指派符號及其成員</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesDescription">
        <source>The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</source>
        <target state="translated">泛型型別包含的型別參數愈多，就愈難知道並記住每個型別參數所代表的意義。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesMessage">
        <source>Consider a design where '{0}' has no more than {1} type parameters</source>
        <target state="translated">請考慮設計成 '{0}' 最多僅有 {1} 個型別參數的樣子</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesTitle">
        <source>Avoid excessive parameters on generic types</source>
        <target state="translated">避免在泛型類型上包含過多參數</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionMessageMaybe">
        <source>Do not assign the property within its setter. This call might result in an infinite recursion.</source>
        <target state="translated">請不要在屬性的 setter 中指派屬性。此呼叫可能會導致無限遞迴。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionMessageSure">
        <source>Do not assign the property within its setter. This call will result in an infinite recursion.</source>
        <target state="translated">請不要在屬性的 setter 中指派屬性。此呼叫將會導致無限遞迴。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionTitle">
        <source>Avoid infinite recursion</source>
        <target state="translated">避免無限遞迴</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndCodeFixTitle">
        <source>Remove redundant length argument</source>
        <target state="translated">移除冗余的長度引數</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndDescription">
        <source>An explicit length calculation can be error-prone and can be avoided when slicing to end of the buffer.</source>
        <target state="translated">明確長度計算可能會造成錯誤，而可在切入緩衝區結尾時避免。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndMessage">
        <source>'{0}' uses a redundant length calculation that can be removed</source>
        <target state="translated">'{0}' 使用可移除的冗余長度計算</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndTitle">
        <source>Avoid redundant length argument</source>
        <target state="translated">避免冗余的長度引數</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidMultipleEnumerationsMessage">
        <source>Possible multiple enumerations of 'IEnumerable' collection. Consider using an implementation that avoids multiple enumerations.</source>
        <target state="translated">'IEnumerable' 集合可能有多個列舉。請考慮避免使用多個列舉的實作。</target>
        <note>{Locked="IEnumerable"}</note>
      </trans-unit>
      <trans-unit id="AvoidMultipleEnumerationsTitle">
        <source>Possible multiple enumerations of 'IEnumerable' collection</source>
        <target state="translated">'IEnumerable' 集合可能有多個列舉</target>
        <note>{Locked="IEnumerable"}</note>
      </trans-unit>
      <trans-unit id="AvoidOutParametersDescription">
        <source>Passing types by reference (using 'out' or 'ref') requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between 'out' and 'ref' parameters is not widely understood.</source>
        <target state="translated">藉傳址傳遞類型 (使用 'out' 或 'ref') 需有指標經驗、了解實值型別與參考型別之間的差異，以及處理具有多個傳回值的方法。而且，大家普遍不了解 'out' 與 'ref' 參數之間的差異。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersMessage">
        <source>Avoid 'out' parameters as they are not designed for general audience</source>
        <target state="translated">因為不是為一般對象設計，所以請避免使用 'out' 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersTitle">
        <source>Avoid out parameters</source>
        <target state="translated">避免使用 out 參數</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMultipleMessage">
        <source>Type '{0}' directly or indirectly inherits '{1}' without implementing any of '{2}'. Publicly-visible types should implement the generic version to broaden usability.</source>
        <target state="translated">類型 '{0}' 未實作任何 '{2}' 便直接或間接繼承 '{1}'。公開顯示的類型應實作一般版本以擴大可用性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesDescription">
        <source>A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught.</source>
        <target state="translated">在 catch 陳述式中捕捉到了 System.Exception 或 System.SystemException 等一般例外狀況或不允許的例外狀況類型，或是使用了一般 catch 子句。不應捕捉到一般例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesMessage">
        <source>Modify '{0}' to catch a more specific allowed exception type, or rethrow the exception</source>
        <target state="translated">請修改 '{0}' 來捕捉更具體的允許例外狀況型別，或重新擲回例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesTitle">
        <source>Do not catch general exception types</source>
        <target state="translated">不要攔截一般例外狀況類型</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesDescription">
        <source>Types declare protected members so that inheriting types can access or override the member. By definition, you cannot inherit from a sealed type, which means that protected methods on sealed types cannot be called.</source>
        <target state="translated">類型會宣告受保護的成員，讓繼承類型可以存取或覆寫該成員。根據定義，您無法從密封類型進行繼承，這表示無法呼叫密封類型上的受保護方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesMessage">
        <source>'{0}' is a new protected member in the 'NonInheritable' class '{1}'</source>
        <target state="translated">'{0}' 是 'NonInheritable' 類別 '{1}' 中新的受保護成員</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesTitle">
        <source>Do not declare protected member in sealed type</source>
        <target state="translated">不要在密封類型中宣告受保護成員</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageLinqMethod">
        <source>'{0}' calls '{1}' but does not use the value the method returns. Linq methods are known to not have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">'{0}' 呼叫了 '{1}'，但未使用方法傳回的值。LINQ 方法已知沒有副作用。請使用條件陳述式中的結果、將結果指派給變數，或將其以引數的形式傳遞給另一個方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageUserDefinedMethod">
        <source>'{0}' calls '{1}' but does not use the value the method returns. This method is defined as a user-option. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">'{0}' 呼叫了 '{1}'，但並未使用方法所傳回的值。此方法定義為使用者選項。請使用條件陳述式中的結果，再將結果指派給變數，或是將其以引數方式傳遞到另一個方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyFix">
        <source>Remove the unnecessary assignment.</source>
        <target state="translated">移除不必要的指派。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedDescription">
        <source>This rule assumes that an enumeration member that has a name that contains "reserved" is not currently used but is a placeholder to be renamed or removed in a future version. Renaming or removing a member is a breaking change.</source>
        <target state="translated">此規則假設名稱包含 "reserved" 的列舉成員目前並未使用，而是要在未來版本中重新命名或移除的預留位置。重新命名或移除成員為中斷性變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedMessage">
        <source>If '{0}.{1}' is not used in the current implementation, remove it. Otherwise give it a meaningful name.</source>
        <target state="translated">如果目前實作中並未使用 '{0}.{1}'，請將其移除。否則，請為其指定有意義的名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedTitle">
        <source>Do not name enum values 'Reserved'</source>
        <target state="translated">不要在列舉值名稱中包含 'Reserved'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsDescription">
        <source>System.Collections.Generic.List&lt;T&gt; is a generic collection that's designed for performance and not inheritance. List&lt;T&gt; does not contain virtual members that make it easier to change the behavior of an inherited class.</source>
        <target state="translated">System.Collections.Generic.List&lt;T&gt; 是為效能而非繼承所設計的泛型集合。List&lt;T&gt; 不包含讓已繼承類別行為更容易變更的虛擬成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsMessage">
        <source>Change '{0}' in '{1}' to use 'Collection&lt;T&gt;', 'ReadOnlyCollection&lt;T&gt;' or 'KeyedCollection&lt;K,V&gt;'</source>
        <target state="translated">將 '{1}' 中的 '{0}' 變更為使用 'Collection&lt;T&gt;'、'ReadOnlyCollection&lt;T&gt;' 或 'KeyedCollection&lt;K,V&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsTitle">
        <source>Do not expose generic lists</source>
        <target state="translated">不要公開泛型清單</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualDescription">
        <source>Do not declare virtual events in a base class. Overridden events in a derived class have undefined behavior. The C# compiler does not handle this correctly and it is unpredictable whether a subscriber to the derived event will actually be subscribing to the base class event.</source>
        <target state="translated">請勿在基底類別中宣告虛擬事件。在有未定義行為的衍生類別中覆寫事件。C# 編譯器無法正確地處理此事件，而且無法預期衍生事件的訂閱者是否會實際訂閱基底類別事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualMessage">
        <source>Event '{0}' should not be declared virtual</source>
        <target state="translated">事件 '{0}' 不應宣告為虛擬</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualTitle">
        <source>Do not declare event fields as virtual</source>
        <target state="translated">請勿將事件欄位宣告為虛擬</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesDescription">
        <source>For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. If the operator is providing meaningful value equality, the type should implement the generic 'System.IEquatable' interface.</source>
        <target state="translated">對參考型別而言，等號比較運算子的預設實作幾乎永遠正確。根據預設，只有當兩項參考都指向相同物件時才會相等。如果運算子提供有意義的值相等，則型別應實作泛型 'System.IEquatable' 介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesMessage">
        <source>'{0}' should not overload the equality operator</source>
        <target state="translated">'{0}' 不應該多載等號比較運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesTitle">
        <source>Do not overload equality operator on reference types</source>
        <target state="translated">請勿多載參考型別上的等號比較運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksDescription">
        <source>Unawaited tasks that use 'IDisposable' instances may use those instances long after they have been disposed. Ensure tasks using those instances are completed before the instances are disposed.</source>
        <target state="translated">未等候的工作如果使用 'IDisposable' 執行個體，處置這些執行個體後，可能仍會使用它們。請確保在處置這些執行個體之前，已完成使用這些執行個體的工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksMessage">
        <source>Ensure tasks using 'IDisposable' instances complete before the instances are disposed</source>
        <target state="translated">確保使用 'IDisposable' 執行個體的工作在處置執行個體之前完成</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksTitle">
        <source>Do not pass 'IDisposable' instances into unawaited tasks</source>
        <target state="translated">請勿將 'IDisposable' 執行個體傳遞至未等候的工作中</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceDescription">
        <source>Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Also, the difference between out and ref parameters is not widely understood.</source>
        <target state="translated">藉傳址傳遞類型 (使用 out 或 ref) 需有指標經驗、了解實值型別與參考型別之間的差異，以及處理具有多個傳回值的方法。而且，大家普遍不了解 out 與 ref 參數之間的差異。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceMessage">
        <source>Consider a design that does not require that '{0}' be a reference parameter</source>
        <target state="translated">請考慮設計成 '{0}' 不必是傳址參數的樣子</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceTitle">
        <source>Do not pass types by reference</source>
        <target state="translated">不要藉傳址方式傳遞類型</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameDescription">
        <source>An enumeration's values should not start with the type name of the enumeration.</source>
        <target state="translated">列舉值不應以列舉的類型名稱作為開頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameMessage">
        <source>Do not prefix enum values with the name of the enum type '{0}'</source>
        <target state="translated">請勿以列舉類型 '{0}' 的名稱作為列舉值的前置詞</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameTitle">
        <source>Do not prefix enum values with type name</source>
        <target state="translated">不要將類型名稱作為列舉值的前置詞</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesMessageDuplicatedBitwiseValuePart">
        <source>The field reference '{0}' is duplicated in this bitwise initialization</source>
        <target state="translated">欄位參考 '{0}' 在此位元初始化中重複</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesMessageDuplicatedValue">
        <source>The enum member '{0}' has the same constant value '{1}' as member '{2}'</source>
        <target state="translated">列舉成員 '{0}' 具有與成員 '{2}' 相同的常數值 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesTitle">
        <source>Enums values should not be duplicated</source>
        <target state="translated">列舉值不應重複</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixDescription">
        <source>Event names should describe the action that raises the event. To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions. For example, when naming a pair of events that is raised when closing a resource, you might name it 'Closing' and 'Closed', instead of 'BeforeClose' and 'AfterClose'.</source>
        <target state="translated">事件名稱應該描述引發該事件的動作。若要命名特定順序內引發的相關事件，請使用現在式或過去式來表示一系列動作中的相對位置。例如，要命名一組在關閉資源時所引發的事件，可以將其命名為 'Closing' 以及 'Closed'，而請勿使用 'BeforeClose' 和 'AfterClose'。</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixMessage">
        <source>Events should not have 'Before' or 'After' prefix</source>
        <target state="translated">事件開頭不應出現 'Before' 或 'After'</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixTitle">
        <source>Events should not have 'Before' or 'After' prefix</source>
        <target state="translated">事件開頭不應出現 'Before' 或 'After'</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageMultiple">
        <source>Rename {0} to end in either '{1}' or '{2}'</source>
        <target state="translated">重新命名 {0}，使其以 '{1}' 或 '{2}' 結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresCodeFixTitle">
        <source>Remove underscores</source>
        <target state="translated">移除底線</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeOverride">
        <source>Remove the finalizer from type '{0}', override Dispose(bool disposing), and put the finalization logic in the code path where 'disposing' is false. Otherwise, it might lead to duplicate Dispose invocations as the Base type '{1}' also provides a finalizer.</source>
        <target state="translated">從類型 '{0}' 移除完成項，覆寫 Dispose(bool disposing)，然後在程式碼路徑中放置完成項邏輯，其中 'disposing' 為 false。否則這可能導致 Dispose 引動過程重複，原因是基底類型 ‘{1}’ 也提供了完成項。</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringDescription">
        <source>The logging message template should not vary between calls.</source>
        <target state="translated">記錄訊息範本在不同呼叫之間不能改變。</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringMessage">
        <source>The logging message template should not vary between calls to '{0}'</source>
        <target state="translated">記錄訊息範本不應在與 '{0}' 通話期間改變</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringTitle">
        <source>Template should be a static expression</source>
        <target state="translated">範本應為靜態運算式</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchDescription">
        <source>Number of parameters supplied in the logging message template do not match the number of named placeholders.</source>
        <target state="translated">記錄訊息範本中提供的參數數目不符合已命名預留位置的數目。</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchMessage">
        <source>Number of parameters supplied in the logging message template do not match the number of named placeholders</source>
        <target state="translated">記錄訊息範本中提供的參數數目不符合已命名預留位置的數目</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchTitle">
        <source>Parameter count mismatch</source>
        <target state="translated">參數計數不符</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchDescription">
        <source>The braces present in the message template are invalid. Ensure any braces in the message template are valid opening/closing braces, or are escaped.</source>
        <target state="translated">顯示在訊息範本中的大括弧無效。請確保訊息範本中的任何大括弧都是有效的開啟/關閉大括弧，或已逸出。</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchMessage">
        <source>The braces present in the message template are invalid</source>
        <target state="translated">顯示在訊息範本中的大括弧無效</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchTitle">
        <source>Invalid braces in message template</source>
        <target state="translated">訊息範本中的大括號無效</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringDescription">
        <source>Named placeholders in the logging message template should not be comprised of only numeric characters.</source>
        <target state="translated">記錄訊息範本中命名的預留位置不能只包含數值字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringMessage">
        <source>Named placeholders in the logging message template should not be comprised of only numeric characters</source>
        <target state="translated">記錄訊息範本中命名的預留位置不能只包含數值字元</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringTitle">
        <source>Named placeholders should not be numeric values</source>
        <target state="translated">命名的預留位置不應為數值</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesDescription">
        <source>For improved performance, use the LoggerMessage delegates.</source>
        <target state="translated">為提高效能，請使用 LoggerMessage 委派。</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesMessage">
        <source>For improved performance, use the LoggerMessage delegates instead of calling '{0}'</source>
        <target state="translated">為提高效能，請使用 LoggerMessage 委派而不是呼叫 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesTitle">
        <source>Use the LoggerMessage delegates</source>
        <target state="translated">請使用 LoggerMessage 委派</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensDescription">
        <source>Use PascalCase for named placeholders in the logging message template.</source>
        <target state="translated">在記錄訊息範本中為命名的預留位置使用首字母大寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensMessage">
        <source>Use PascalCase for named placeholders in the logging message template</source>
        <target state="translated">在記錄訊息範本中為命名的預留位置使用首字母大寫</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensTitle">
        <source>Use PascalCase for named placeholders</source>
        <target state="translated">將 PascalCase 用於已命名的預留位置</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalCodeFixTitle">
        <source>Make the public type internal</source>
        <target state="translated">將公用類型設為內部</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalDescription">
        <source>Unlike a class library, an application's API isn't typically referenced publicly, so types can be marked internal.</source>
        <target state="translated">與類別庫不同，應用程式的 API 通常不會公開參照，因此可將類型標示為內部。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalMessage">
        <source>Because an application's API isn't typically referenced from outside the assembly, types can be made internal</source>
        <target state="translated">因為應用程式的 API 通常不是從組件外部參考，所以可以將類型設定為內部</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalTitle">
        <source>Consider making public types internal</source>
        <target state="translated">請考慮將公用類型設為內部</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageCodeFix">
        <source>Apply 'AttributeUsageAttribute'</source>
        <target state="translated">套用 'AttributeUsageAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesCodeFixTitle">
        <source>Add operator overload named alternate</source>
        <target state="translated">新增名稱為 alternate 的運算子多載</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantElementInitializationCodeFixTitle">
        <source>Remove redundant element initializer</source>
        <target state="translated">移除多餘的項目初始設定式</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableTitle">
        <source>Types that own disposable fields should be disposable</source>
        <target state="translated">擁有可處置欄位的類型，本身應為可處置</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableDescription">
        <source>A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</source>
        <target state="translated">類別會宣告及實作類型為 System.IDisposable 的執行個體欄位，且該類別不會實作 IDisposable。宣告 IDisposable 欄位的類別會間接擁有非受控資源，且應實作 IDisposable 介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking">
        <source>Type '{0}' owns disposable field(s) '{1}' but is not disposable</source>
        <target state="translated">類型 '{0}' 擁有可處置的欄位 '{1}' 但其本身並非可處置項目</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsCodeFixTitle">
        <source>Add 'System.Uri' overloads</source>
        <target state="translated">新增 'System.Uri' 多載</target>
        <note>{Locked="System.Uri"}</note>
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsDescription">
        <source>This rule detects usage of platform-specific intrinsics that can be replaced with an equivalent cross-platform intrinsic instead.</source>
        <target state="translated">此規則會偵測平台特定的內建使用情況，這些內建可以被對應的跨平台內建所取代。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opAddition">
        <source>The addition operator should be preferred</source>
        <target state="translated">應優先使用加法運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opBitwiseAnd">
        <source>The bitwise-and operator should be preferred</source>
        <target state="translated">應優先使用位元 AND 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opBitwiseOr">
        <source>The bitwise-or operator should be preferred</source>
        <target state="translated">應優先使用位元 OR 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opDivison">
        <source>The division operator should be preferred</source>
        <target state="translated">應優先使用除法運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opExclusiveOr">
        <source>The exclusive-or operator should be preferred</source>
        <target state="translated">應優先使用排除 OR 運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opLeftShift">
        <source>The left-shift operator should be preferred</source>
        <target state="translated">應優先使用左移運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opMultiply">
        <source>The multiply operator should be preferred</source>
        <target state="translated">應優先使用乘法運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opOnesComplement">
        <source>The ones-complement operator should be preferred</source>
        <target state="translated">應優先使用一補位運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opRightShift">
        <source>The right-shift operator should be preferred</source>
        <target state="translated">應優先使用右移運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opSubtraction">
        <source>The subtraction operator should be preferred</source>
        <target state="translated">應優先使用減法運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opUnaryNegation">
        <source>The unary-negation operator should be preferred</source>
        <target state="translated">應優先使用一元否定運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opUnsignedRightShift">
        <source>The unsigned right-shift operator should be preferred</source>
        <target state="translated">應優先使用未簽署右移運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsTitle">
        <source>Use cross-platform intrinsics</source>
        <target state="translated">使用跨平台的內建項目</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesTitle">
        <source>Use generic event handler instances</source>
        <target state="translated">使用泛型事件處理常式執行個體</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueTitle">
        <source>Enums should have zero value</source>
        <target state="translated">列舉應要零值</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueDescription">
        <source>The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.</source>
        <target state="translated">如同其他實值型別一般，未初始化的列舉之預設值為零。非旗標屬性的列舉應以使用零值的方法來定義成員，讓預設值成為列舉的有效值。若已套用 FlagsAttribute 屬性的列舉定義了零值成員，則其名稱應為 "None"，以表示列舉中未設定任何值。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsRename">
        <source>In enum {0}, change the name of {1} to 'None'</source>
        <target state="translated">在列舉 {0} 中，將 {1} 的名稱變更為 'None'</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsMultipleZeros">
        <source>Remove all members that have the value zero from {0} except for one member that is named 'None'</source>
        <target state="translated">從 {0} 中移除值為零的所有成員，但名為 'None' 的成員除外</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue">
        <source>Add a member to {0} that has a value of zero with a suggested name of 'None'</source>
        <target state="translated">將成員新增至值為零且建議名稱為 'None' 的 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsTitle">
        <source>Abstract types should not have public constructors</source>
        <target state="translated">抽象類型不應有公用建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsDescription">
        <source>Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</source>
        <target state="translated">只有衍生類型才可呼叫抽象類型上的建構函式。因為公用建構函式會建立類型的執行個體，而且您無法建立抽象類型的執行個體，所以具有公用建構函式的抽象類型設計不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsMessage">
        <source>Abstract type '{0}' should not have public constructors</source>
        <target state="translated">抽象類型 '{0}' 不應有公用建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantTitle">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">將組件標記為 CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantDescription">
        <source>The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.</source>
        <target state="translated">Common Language Specification (CLS) 會定義命名限制、資料類型及組件必須遵守的規則 (若組件會跨程式設計語言使用)。良好的設計會要求所有組件使用 CLSCompliantAttribute 明確地表示 CLS 合規性。若此屬性未出現於組件中，則表示組件不符合標準。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantMessage">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">將組件標記為 CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionTitle">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">將組件標記為版本組件</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionDescription">
        <source>The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.</source>
        <target state="translated">.NET Framework 使用版本號碼來唯一識別組件，且會繫結至強式具名組件中的類型。版本號碼會與版本以及發行者原則一起使用。根據預設，應用程式只可與原先建置它們的組件版本一起執行。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionMessage">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">將組件標記為版本組件</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleTitle">
        <source>Mark assemblies with ComVisible</source>
        <target state="translated">將組件標記為 ComVisible</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleDescription">
        <source>ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.</source>
        <target state="translated">ComVisibleAttribute 會判斷 COM 用戶端如何存取受控程式碼。良好的設計會要求組件明確表示 COM 的可見度。可以為整個組件設定COM 的可見度，然後再對個別的類型與類型成員進行覆寫。若此屬性不存在，則 COM 用戶端可以看到組件的內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageTitle">
        <source>Mark attributes with AttributeUsageAttribute</source>
        <target state="translated">將屬性標記為 AttributeUsageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageDefault">
        <source>Specify AttributeUsage on {0}</source>
        <target state="translated">在 {0} 上指定 AttributeUsage</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsTitle">
        <source>Define accessors for attribute arguments</source>
        <target state="translated">為屬性引數定義存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageDefault">
        <source>Add a public read-only property accessor for positional argument {0} of Attribute {1}</source>
        <target state="translated">為屬性 (Attribute) {1} 的位置引數 {0} 新增公用唯讀屬性 (Property) 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageRemoveSetter">
        <source>Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}</source>
        <target state="translated">因為屬性 setter 會對應到位置引數 {1}，所以請從 {0} 移除屬性 setter 或縮小其存取範圍</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility">
        <source>If {0} is the property accessor for positional argument {1}, make it public</source>
        <target state="translated">若 {0} 是位置引數 {1} 的屬性存取子，請將其設為公用</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateTitle">
        <source>Use properties where appropriate</source>
        <target state="translated">適當時機使用屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateDescription">
        <source>A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.</source>
        <target state="translated">公用或受保護的方法具有以 ""Get"" 開頭的名稱，該名稱沒有使用任何參數，且會傳回不是陣列的值。此方法可能很適合成為屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateMessage">
        <source>Use properties where appropriate</source>
        <target state="translated">適當時機使用屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsTitle">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">將列舉標記為 FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsDescription">
        <source>An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</source>
        <target state="translated">列舉是一種實值型別，用以定義一組相關的具名常數。當列舉的具名常數可以有意義地加以合併時，可將 FlagsAttribute 套用至此列舉。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsMessage">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">將列舉標記為 FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesTitle">
        <source>Interface methods should be callable by child types</source>
        <target state="translated">介面方法應可由子類型呼叫</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesDescription">
        <source>An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</source>
        <target state="translated">外部可見的非密封類型，可提供公用介面的明確方法實作，但不會提供外部可見的同名替代方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesMessage">
        <source>Make '{0}' sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of '{1}' and is visible to derived classes</source>
        <target state="translated">密封 '{0}' (若先前已發佈這個類別則為中斷變更)、以非明確的方式實作方法，或是實作會公開 '{1}' 功能並向衍生類別顯示的新方法</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesTitle">
        <source>Override methods on comparable types</source>
        <target state="translated">在 Comparable 類型上覆寫方法</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesDescription">
        <source>A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.</source>
        <target state="translated">公用或受保護的類型會實作 System.IComparable 介面。它不會覆寫 Object.Equals，也不會多載語言專屬的等號比較、不相等比較、小於、小於或等於、大於或是大於或等於運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageEquals">
        <source>{0} should override Equals since it implements IComparable</source>
        <target state="translated">因為 {0} 會實作 IComparable，所以應該覆寫 Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageOperator">
        <source>{0} should define operator(s) '{1}' since it implements IComparable</source>
        <target state="translated">因為 {0} 會實作 IComparable，所以應該定義運算子 '{1}'</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassTitle">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">將 PInvoke 移到原生方法類別</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassDescription">
        <source>Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</source>
        <target state="translated">平台引動過程方法 (例如，使用 System.Runtime.InteropServices.DllImportAttribute 屬性標記的方法，或在 Visual Basic 中使用 Declare 關鍵字定義的方法) 都會存取非受控程式碼。這些方法應為 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 類別。</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassMessage">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">將 PInvoke 移到原生方法類別</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseTitle">
        <source>Identifiers should differ by more than case</source>
        <target state="translated">識別項不應只靠大小寫區別</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseDescription">
        <source>Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</source>
        <target state="translated">因為以 Common Language Runtime 為目標的語言，不需要區分大小寫，所以命名空間、類型、成員以及參數的識別項不可只有大小寫不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseMessage">
        <source>Names of '{0}' and '{1}' should differ by more than case</source>
        <target state="translated">'{0}' 與 '{1}' 的名稱不應只靠大小寫區別</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixTitle">
        <source>Identifiers should have correct prefix</source>
        <target state="translated">識別項應該使用正確的前置詞</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixDescription">
        <source>The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".</source>
        <target state="translated">外部可見介面的名稱未以大寫 ""I"" 開頭。外部可見類型或方法上，泛型型別參數的名稱未以大寫 ""T"" 開頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageInterface">
        <source>Prefix interface name {0} with 'I'</source>
        <target state="translated">在介面名稱 {0} 前面加上 'I'</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageTypeParameter">
        <source>Prefix generic type parameter name {0} with 'T'</source>
        <target state="translated">在泛型型別參數名稱 {0} 前面加上 'T'</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleTitle">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">非常數欄位不應可見</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleDescription">
        <source>Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</source>
        <target state="translated">既非常數又非唯讀的靜態欄位，不是安全執行緒。必須小心控制對這類欄位的存取，且需要進階的程式設計技巧來同步對類別物件的存取。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleMessage">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">非常數欄位不應可見</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsTitle">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">請勿將列舉標記為 FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsDescription">
        <source>An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</source>
        <target state="translated">外部可見的列舉會使用 FlagsAttribute 加以標記，且有一或多個值不是二的次方或列舉上其他定義值的組合。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsMessage">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">請勿將列舉標記為 FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesTitle">
        <source>Operator overloads have named alternates</source>
        <target state="translated">運算子多載有具名的替代項</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesDescription">
        <source>An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</source>
        <target state="translated">偵測到運算子多載，且找不到應有的具名替代方法。具名替代成員可存取與運算子相同的功能，且可供以不支援多載運算子的語言設計程式之開發人員使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageDefault">
        <source>Provide a method named '{0}' as a friendly alternate for operator {1}</source>
        <target state="translated">請提供名為 '{0}' 的方法作為運算子 {1} 的易記替代項</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageProperty">
        <source>Provide a property named '{0}' as a friendly alternate for operator {1}</source>
        <target state="translated">請提供名為 '{0}' 的屬性作為運算子 {1} 的易記替代項</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageMultiple">
        <source>Provide a method named '{0}' or '{1}' as an alternate for operator {2}</source>
        <target state="translated">請提供名為 '{0}' 或 '{1}' 的方法作為運算子 {2} 的替代項</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageVisibility">
        <source>Mark {0} as public because it is a friendly alternate for operator {1}</source>
        <target state="translated">因為 {0} 是運算子 {1} 的易記替代項，所以將其標記為公用</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsTitle">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">運算子應有對稱的多載</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsDescription">
        <source>A type implements the equality or inequality operator and does not implement the opposite operator.</source>
        <target state="translated">類型會實作等號比較運算子或不等比較運算子，但不會實作相反運算子。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyTitle">
        <source>Collection properties should be read only</source>
        <target state="translated">集合屬性應為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyDescription">
        <source>A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.</source>
        <target state="translated">可寫入的集合屬性允許使用者以不同的集合來取代該集合。唯讀屬性會讓集合無法被取代，但是仍然允許設定個別成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyMessage">
        <source>Change '{0}' to be read-only by removing the property setter</source>
        <target state="translated">透過移除屬性 setter，將 '{0}' 變更為唯讀</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">覆寫實值型別 Equals 時，多載等號比較運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription">
        <source>In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals.</source>
        <target state="translated">在大多數的程式設計語言中，實值型別沒有等號比較運算子 (==) 的預設實作。若程式設計語言支援運算子多載，請考慮實作等號比較運算子。其行為與 Equals 完全相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage">
        <source>Implement the equality operators and make their behavior identical to that of the Equals method</source>
        <target state="translated">實作等號運算子，並使其行為與 Equals 方法的行為相同</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsTitle">
        <source>Pass system uri objects instead of strings</source>
        <target state="translated">傳遞系統 URI 物件而非傳遞字串</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsDescription">
        <source>A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</source>
        <target state="translated">呼叫其字串參數名稱包含 "uri"、"URI"、"urn"、"URN"、"url" 或 "URL" 的方法。此方法的宣告類型包含具有 System.Uri 參數的相對應方法多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsMessage">
        <source>Modify '{0}' to call '{1}' instead of '{2}'</source>
        <target state="translated">將 {0} 修改為呼叫 '{1}'，而非呼叫 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsTitle">
        <source>Implement IEquatable when overriding Object.Equals</source>
        <target state="translated">覆寫 Object.Equals 時實作 IEquatable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsMessage">
        <source>Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</source>
        <target state="translated">類型 {0} 應先實作 IEquatable&lt;T&gt;，因為它會覆寫 Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastTitle">
        <source>CancellationToken parameters must come last</source>
        <target state="translated">CancellationToken 參數必須位於最後</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastMessage">
        <source>Method '{0}' should take CancellationToken as the last parameter</source>
        <target state="translated">方法 '{0}' 應以 CancellationToken 作為最後一個參數</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesTitle">
        <source>Identifier contains type name</source>
        <target state="translated">識別項包含類型名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesDescription">
        <source>Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.</source>
        <target state="translated">參數與成員名稱最好可傳達其意義，而不是說明應由開發工具提供的類型。對於成員名稱而言，如果必須使用資料類型名稱，請使用和語言無關的名稱，而非使用語言專屬的名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesMessage">
        <source>Identifier '{0}' contains type name</source>
        <target state="translated">識別項 '{0}' 包含類型名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="CreatePropertyAccessorForParameter">
        <source>Create a property accessor.</source>
        <target state="translated">建立屬性存取子。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeGetterPublic">
        <source>Make the getter of the property public</source>
        <target state="translated">將屬性的 getter 設為公用</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeSetterNonPublic">
        <source>Make the setter of the property non-public</source>
        <target state="translated">將屬性的 setter 設為非公用</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAssemblyLevelComVisibleFalse">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true)</source>
        <target state="translated">因為 {0} 會公開外部可見的型別，所以請在組件層級將其標記為 ComVisible(false)，然後將應公開給 COM 用戶端之組件內的所有型別，標記為 ComVisible(true)</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeAssemblyLevelComVisibleToFalse">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level</source>
        <target state="translated">請考慮將 {0} 上的 ComVisible 屬性變更為 false，並於型別層級選擇加入</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementComparable">
        <source>Implement Equality and Comparison methods and operators</source>
        <target state="translated">實作 Equality 與 Comparison 方法以及運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementEquatable">
        <source>Implement IEquatable</source>
        <target state="translated">實作 IEquatable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableInterface">
        <source>Implement IDisposable Interface</source>
        <target state="translated">實作 IDisposable 介面</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsCodeFix">
        <source>Remove FlagsAttribute from enum.</source>
        <target state="translated">從列舉移除 FlagsAttribute。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsCodeFix">
        <source>Apply FlagsAttribute to enum.</source>
        <target state="translated">將 FlagsAttribute 套用至列舉。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsMultipleZeroCodeFix">
        <source>Remove all members that have the value zero except for one member that is named 'None'.</source>
        <target state="translated">移除值為零的所有成員，但名為 'None' 的成員除外。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsRenameCodeFix">
        <source>Rename zero-valued enum field to 'None'.</source>
        <target state="translated">將值為零的列舉欄位重新命名為 'None'。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix">
        <source>Add a zero-valued member 'None' to enum.</source>
        <target state="translated">將值為零的成員 'None' 新增至列舉。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHavePublicConstructorsCodeFix">
        <source>Change the accessibility of public constructors to protected.</source>
        <target state="translated">變更要保護之公用建構函式的存取範圍。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesTitle">
        <source>Do not declare static members on generic types</source>
        <target state="translated">請勿在泛型型別上宣告靜態成員</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesDescription">
        <source>When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.</source>
        <target state="translated">呼叫泛型型別的靜態成員時，必須為類型指定型別引數。呼叫了不支援介面的泛型執行個體成員時，必須為成員指定型別引數。在上述兩種情況下，指定型別引數的語法不同且容易混淆。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesMessage">
        <source>Do not declare static members on generic types</source>
        <target state="translated">請勿在泛型型別上宣告靜態成員</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceTitle">
        <source>Generic interface should also be implemented</source>
        <target state="translated">應同時實作一般介面</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceDescription">
        <source>To broaden the usability of a type, implement one of the generic interfaces. This is especially true for collections as they can then be used to populate generic collection types.</source>
        <target state="translated">若要擴大類型的可用性，請實作其中一個一般介面。這項做法特別適用於集合，原因是可以讓集合用於填入一般集合類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMessage">
        <source>Type '{0}' directly or indirectly inherits '{1}' without implementing '{2}'. Publicly-visible types should implement the generic version to broaden usability.</source>
        <target state="translated">類型 '{0}' 未實作 '{2}' 便直接或間接繼承 '{1}'。公開顯示的類型應實作一般版本以擴大可用性。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Title">
        <source>Enum Storage should be Int32</source>
        <target state="translated">列舉儲存體應為 Int32</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Description">
        <source>An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.</source>
        <target state="translated">列舉是一種實值型別，用以定義一組相關的具名常數。根據預設，System.Int32 資料類型會用於儲存常數值。雖然您可變更此基礎類型，但大多數的情況下仍不需要或不建議進行變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Message">
        <source>If possible, make the underlying type of {0} System.Int32 instead of {1}</source>
        <target state="translated">若是可能，請將 {0} 的基礎型別變更為 System.Int32，而非 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateTitle">
        <source>Use events where appropriate</source>
        <target state="translated">適當時機使用事件</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateDescription">
        <source>This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.</source>
        <target state="translated">此規則會偵測具有事件常用名稱的方法。若方法因為要回應清楚定義的狀態變更而被呼叫，應由事件處理常式叫用該方法。呼叫方法的物件應該要引發事件，而非直接呼叫方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateMessage">
        <source>Consider making '{0}' an event</source>
        <target state="translated">請考慮將 '{0}' 設為事件</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsTitle">
        <source>Implement standard exception constructors</source>
        <target state="translated">實作標準例外狀況建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsDescription">
        <source>Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</source>
        <target state="translated">無法提供整組的建構函式，有可能會導致難以正確地處理例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageMissingConstructor">
        <source>Add the following constructor to {0}: {1}</source>
        <target state="translated">將下列建構函式新增至 {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleTitle">
        <source>Nested types should not be visible</source>
        <target state="translated">巢狀型別不應可見</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleDescription">
        <source>A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.</source>
        <target state="translated">巢狀型別是在其他類型的範圍內宣告之類型。巢狀型別可用於封裝包含型別的私用實作詳細資料。因為用途如此，所以巢狀型別不應為外部可見。</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageDefault">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible.</source>
        <target state="translated">請勿將類型 {0} 巢狀化。或者，變更其存取範圍，使其非外部可見。</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageVisualBasicModule">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module.</source>
        <target state="translated">請勿將類型 {0} 巢狀化。或者，變更其存取範圍，使其非外部可見。若此類型定義於 Visual Basic 模組中，則其對於其他 .NET 語言而言會視作為巢狀型別。在這種情況下，請考慮將該類型移出模組。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesTitle">
        <source>Avoid empty interfaces</source>
        <target state="translated">避免空的介面</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesDescription">
        <source>Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</source>
        <target state="translated">介面是用以定義提供行為或使用合約的成員。不論類型出現在繼承階層中的何處，介面所描述的功能皆可供所有類型採用。類型會實作介面，方法是提供介面成員的實作。空的介面不會定義任何成員，因此也不會定義能夠實作的合約。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesMessage">
        <source>Avoid empty interfaces</source>
        <target state="translated">避免空的介面</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageTitle">
        <source>Provide ObsoleteAttribute message</source>
        <target state="translated">提供 ObsoleteAttribute 訊息</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageDescription">
        <source>A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.</source>
        <target state="translated">類型或成員使用並未指定其 ObsoleteAttribute.Message 屬性 (Property) 的 System.ObsoleteAttribute 屬性 (Attribute) 加以標記。編譯使用 ObsoleteAttribute 標記的類型或成員之後，會顯示屬性 (Attribute) 的 Message 屬性 (Property)，以便提供使用者有關過時類型或成員的資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageMessage">
        <source>Provide a message for the ObsoleteAttribute that marks {0} as Obsolete</source>
        <target state="translated">提供將 {0} 標記為 Obsolete 的 ObsoleteAttribute 之訊息</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyTitle">
        <source>Properties should not be write only</source>
        <target state="translated">屬性不應為唯寫屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyDescription">
        <source>Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</source>
        <target state="translated">雖然擁有唯讀屬性是可接受且也經常需要，但設計方針禁止使用唯寫屬性。這是因為讓使用者設定一個值，然後使其無法檢視該值，並不會提供任何安全性。此外，如果沒有讀取權限，就無法檢視共用物件的狀態，進而限制其實用性。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageAddGetter">
        <source>Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method</source>
        <target state="translated">因為屬性 {0} 是唯寫屬性，所以請以大於或等於其 setter 的存取範圍，新增屬性 getter，或是將此屬性轉換為方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible">
        <source>Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter</source>
        <target state="translated">因為 {0} 的屬性 getter 較其 setter 的可見性低，所以請加大其 getter 的存取範圍，或是縮小其 setter 的存取範圍</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesTitle">
        <source>Declare types in namespaces</source>
        <target state="translated">在命名空間中宣告類型</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesDescription">
        <source>Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</source>
        <target state="translated">類型會宣告於命名空間中，以避免名稱衝突，且可當作組織物件階層中相關類型的一種方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesMessage">
        <source>Declare types in namespaces</source>
        <target state="translated">在命名空間中宣告類型</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsTitle">
        <source>Do not declare visible instance fields</source>
        <target state="translated">請勿宣告可見的執行個體欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsDescription">
        <source>The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.</source>
        <target state="translated">欄位的主要用法應是作為實作詳細資料。欄位應為是私用或為內部使用，且應使用屬性公開。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsMessage">
        <source>Do not declare visible instance fields</source>
        <target state="translated">請勿宣告可見的執行個體欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsTitle">
        <source>URI-like parameters should not be strings</source>
        <target state="translated">類 URI 參數不應為字串</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsDescription">
        <source>This rule assumes that the parameter represents a Uniform Resource Identifier (URI). A string representation or a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. 'System.Uri' class provides these services in a safe and secure manner.</source>
        <target state="translated">此規則假設參數代表統一資源識別項 (URI)。字串表示法或 URI 容易發生剖析及編碼錯誤，且可能因此導致安全性弱點。'System.Uri' 類別以安全的方式提供這些服務。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsMessage">
        <source>Change the type of parameter '{0}' of method '{1}' from 'string' to 'System.Uri', or provide an overload to '{1}' that allows '{0}' to be passed as a 'System.Uri' object</source>
        <target state="translated">將方法 '{1}' 的參數 '{0}' 型別從 'string' 變更為 'System.Uri'，或是為 '{1}' 提供多載，允許將 '{0}' 以 'System.Uri' 物件的形式傳遞</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsTitle">
        <source>URI-like return values should not be strings</source>
        <target state="translated">類 URI 傳回值不應為字串</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsDescription">
        <source>This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">此規則假設方法會傳回 URI。URI 的字串表示法容易發生剖析及編碼錯誤，且可能因此導致安全性弱點。System.Uri 類別以安全的方式提供這些服務。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsMessage">
        <source>Change the return type of method '{0}' from 'string' to 'System.Uri'</source>
        <target state="translated">將方法 '{0}' 的傳回型別從 'string' 變更為 'System.Uri'</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsTitle">
        <source>URI-like properties should not be strings</source>
        <target state="translated">類 URI 屬性不應為字串</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsDescription">
        <source>This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">此規則假設屬性代表統一資源識別項 (URI)。URI 的字串表示法容易發生剖析及編碼錯誤，且可能因此導致安全性弱點。System.Uri 類別以安全的方式提供這些服務。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsMessage">
        <source>Change the type of property '{0}' from 'string' to 'System.Uri'</source>
        <target state="translated">將屬性 '{0}' 的類型從 'string' 變更為 'System.Uri'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyTitle">
        <source>Implement IDisposable Correctly</source>
        <target state="translated">正確實作 IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyDescription">
        <source>All IDisposable types should implement the Dispose pattern correctly.</source>
        <target state="translated">所有 IDisposable 類型都應正確地實作 Dispose 模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageIDisposableReimplementation">
        <source>Remove IDisposable from the list of interfaces implemented by '{0}' as it is already implemented by base type '{1}'</source>
        <target state="translated">從 '{0}' 實作的介面清單中移除 IDisposable，原因是基底類型 '{1}' 已實作該項</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeOverride">
        <source>Remove '{0}', override Dispose(bool disposing), and put the dispose logic in the code path where 'disposing' is true</source>
        <target state="translated">移除 '{0}'，覆寫 Dispose(bool disposing)，並在程式碼路徑中放置處置邏輯，其中 'disposing' 為 true</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeSignature">
        <source>Ensure that '{0}' is declared as public and sealed</source>
        <target state="translated">確保 '{0}' 已宣告為公用並密封</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageRenameDispose">
        <source>Rename '{0}' to 'Dispose' and ensure that it is declared as public and sealed</source>
        <target state="translated">將 '{0}' 重新命名為 'Dispose'，並確保其已宣告為公用並密封</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeBoolSignature">
        <source>Ensure that '{0}' is declared as protected, virtual, and unsealed</source>
        <target state="translated">確保 '{0}' 已宣告為受保護、虛擬和未密封</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeImplementation">
        <source>Modify '{0}' so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance ('this' or 'Me' in Visual Basic), and then returns</source>
        <target state="translated">修改 '{0}'，以便其呼叫 Dispose(true)，並在目前的物件執行個體 (Visual Basic 中的 'this' 或 'Me') 上呼叫 GC.SuppressFinalize，然後傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeImplementation">
        <source>Modify '{0}' so that it calls Dispose(false) and then returns</source>
        <target state="translated">修改 '{0}'，以便其呼叫 Dispose(false) 然後傳回</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageProvideDisposeBool">
        <source>Provide an overridable implementation of Dispose(bool) on '{0}' or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources.</source>
        <target state="translated">在 '{0}' 上提供 Dispose(bool) 的可覆寫實作，或將該類型標記為密封。呼叫 Dispose(false) 只能清除原生資源。呼叫 Dispose(true) 則能同時清除受控與原生資源。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicTitle">
        <source>Exceptions should be public</source>
        <target state="translated">例外狀況應為公用</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicDescription">
        <source>An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.</source>
        <target state="translated">內部例外狀況只有在其本身的內部範圍內才可看到。當例外狀況超出內部範圍之後，只能使用基底例外狀況來攔截例外狀況。若內部例外狀況繼承自 T:System.Exception、T:System.SystemException 或 T:System.ApplicationException，則外部程式碼將不會有足夠的資訊可以知道應如何處理此例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicMessage">
        <source>Exceptions should be public</source>
        <target state="translated">例外狀況應為公用</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsTitle">
        <source>Do not raise exceptions in unexpected locations</source>
        <target state="translated">請勿在非預期的位置中引發例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsDescription">
        <source>A method that is not expected to throw exceptions throws an exception.</source>
        <target state="translated">應不會擲回例外狀況的方法擲回了例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property's logic so that it no longer raises an exception.</source>
        <target state="translated">{0} 會建立類型 {1} 的例外狀況，而這種例外狀況類型不應在屬性中引發。若可能引發此例外狀況執行個體，請使用其他例外狀況類型，將這個屬性轉換為方法，或是變更這個屬性的邏輯，使其不會再引發例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method's logic so that it no longer raises an exception.</source>
        <target state="translated">{0} 會建立類型 {1} 的例外狀況，而這種例外狀況類型不應在此類型的方法中引發。若可能引發此例外狀況執行個體，請使用其他例外狀況類型，或是變更此方法的邏輯，使其不會再引發例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions">
        <source>{0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method's logic so it no longer raises an exception.</source>
        <target state="translated">{0} 會建立類型 {1} 的例外狀況。不應於此類型的方法中引發例外狀況。若可能引發此例外狀況執行個體，請變更這個方法的邏輯，使其不會再引發例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresTitle">
        <source>Identifiers should not contain underscores</source>
        <target state="translated">識別項不應包含底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresDescription">
        <source>By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.</source>
        <target state="translated">依照慣例，識別項名稱不包含底線 (_) 字元。此規則會檢查命名空間、類型、成員與參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageAssembly">
        <source>Remove the underscores from assembly name {0}</source>
        <target state="translated">移除組件名稱 {0} 中的底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageNamespace">
        <source>Remove the underscores from namespace name '{0}'</source>
        <target state="translated">移除命名空間名稱 '{0}' 中的底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageType">
        <source>Remove the underscores from type name {0}</source>
        <target state="translated">移除型別名稱 {0} 中的底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMember">
        <source>Remove the underscores from member name {0}</source>
        <target state="translated">移除成員名稱 {0} 中的底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter">
        <source>On type {0}, remove the underscores from generic type parameter name {1}</source>
        <target state="translated">在型別 {0} 上，移除泛型型別參數名稱 {1} 中的底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter">
        <source>On method {0}, remove the underscores from generic type parameter name {1}</source>
        <target state="translated">在方法 {0} 上，移除泛型型別參數名稱 {1} 中的底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMemberParameter">
        <source>In member {0}, remove the underscores from parameter name {1}</source>
        <target state="translated">在成員 {0} 中，移除參數名稱 {1} 中的底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageDelegateParameter">
        <source>In delegate {0}, remove the underscores from parameter name {1}</source>
        <target state="translated">在委派 {0} 中，移除參數名稱 {1} 中的底線</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixTitle">
        <source>Identifiers should have correct suffix</source>
        <target state="translated">識別項應使用正確的尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixDescription">
        <source>By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</source>
        <target state="translated">依照慣例，擴充特定基底類型或實作特定介面的類型名稱，或是從這些類型衍生的類型，其尾碼才可與基底類型或介面相關聯。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageDefault">
        <source>Rename {0} to end in '{1}'</source>
        <target state="translated">重新命名 {0}，使其以 '{1}' 結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixTitle">
        <source>Identifiers should not have incorrect suffix</source>
        <target state="translated">識別項不應使用不正確的尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixDescription">
        <source>By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.</source>
        <target state="translated">依照慣例，只有擴充特定基底類型或實作特定介面的類型名稱，或是從這些類型衍生的類型，才可用專屬的保留尾碼作為結尾。其他類型名稱不應使用這些保留尾碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate">
        <source>Rename type name {0} so that it does not end in '{1}'</source>
        <target state="translated">重新命名型別名稱 {0}，使其結尾不是 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion">
        <source>Either replace the suffix '{0}' in member name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the member it replaces</source>
        <target state="translated">以建議的數字替代項 '2' 取代成員名稱 {1} 中的尾碼 '{0}'，或是提供區分此成員與其所取代之成員而更具意義的尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion">
        <source>Either replace the suffix '{0}' in type name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the type it replaces</source>
        <target state="translated">以建議的數字替代項 '2' 取代型別名稱 {1} 中的尾碼 '{0}'，或是提供區分此型別與其所取代之型別而更具意義的尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate">
        <source>Either replace the suffix '{0}' in member name '{1}' with the suggested alternate '{2}' or remove the suffix completely</source>
        <target state="translated">以建議的替代項 '{2}' 取代成員名稱 '{1}' 中的尾碼 '{0}'，或是完全移除尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsTitle">
        <source>Identifiers should not match keywords</source>
        <target state="translated">識別項不應該與關鍵字相符</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsDescription">
        <source>A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</source>
        <target state="translated">命名空間名稱或類型名稱符合程式設計語言中的保留關鍵字。命名空間與類型的識別項，不應與以 Common Language Runtime 為目標之語言所定義的關鍵字相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMemberParameter">
        <source>In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword '{2}'. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">在虛擬/介面成員 {0} 中，重新命名參數 {1}，使其不再與保留的語言關鍵字 '{2}' 相衝突。將保留關鍵字用作為虛擬/介面成員上參數的名稱，會讓其他語言的消費者難以覆寫/實作該成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMember">
        <source>Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">重新命名虛擬/介面成員 {0}，使其不再與保留的語言關鍵字 '{1}' 相衝突。將保留關鍵字用作為虛擬/介面成員的名稱，會讓其他語言的消費者難以覆寫/實作該成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageType">
        <source>Rename type {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type.</source>
        <target state="translated">重新命名類型 {0}，使其不再與保留的語言關鍵字 '{1}' 相衝突。將保留關鍵字用作為類型的名稱，會讓其他語言的消費者難以使用該類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageNamespace">
        <source>Rename namespace {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace.</source>
        <target state="translated">重新命名命名空間 {0} ，使其不再與保留的語言關鍵字 '{1}' 相衝突。將保留關鍵字用作為命名空間的名稱，會讓其他語言的消費者難以使用該命名空間。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsTitle">
        <source>Property names should not match get methods</source>
        <target state="translated">屬性名稱不應與 get 方法相符</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsDescription">
        <source>The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.</source>
        <target state="translated">公用或受保護成員的名稱以 ""Get"" 開頭，否則需與公用或受保護屬性的名稱相符。""Get"" 方法與屬性的名稱，皆應該清楚區別其功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsMessage">
        <source>The property name '{0}' is confusing given the existence of method '{1}'. Rename or remove one of these members.</source>
        <target state="translated">若存在有方法 '{1}'，屬性名稱 '{0}' 易使人混淆。重新命名或移除其中一個成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesTitle">
        <source>Type names should not match namespaces</source>
        <target state="translated">類型名稱不應與命名空間相符</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesDescription">
        <source>Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.</source>
        <target state="translated">類型名稱不與 .NET Framework Class Library 中定義的命名空間名稱相符。違反此規則可能會降低程式庫的可用性。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageDefault">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}'. Change either name to eliminate the conflict.</source>
        <target state="translated">整個類型名稱 {0} 或其中的一部分，與命名空間名稱 '{1}' 相衝突。變更任一名稱以排除該衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageSystem">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}' defined in the .NET Framework. Rename the type to eliminate the conflict.</source>
        <target state="translated">整個類型名稱 {0} 或其中的一部分，與 .NET Framework 中定義的命名空間名稱 '{1}' 相衝突。重新命名類型以排除該衝突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationTitle">
        <source>Parameter names should match base declaration</source>
        <target state="translated">參數名稱應與基底類型宣告相符</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationDescription">
        <source>Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</source>
        <target state="translated">在覆寫階層中的參數命名方式一致，可增加方法覆寫的可用性。與基底宣告中的名稱不同之衍生方法內的參數名稱，可能會造成一些混淆，不確定方法為基底方法的覆寫或為方法的新多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationMessage">
        <source>In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}</source>
        <target state="translated">在成員 {0} 中，將參數名稱從 {1} 變更為 {2}，以符合已於 {3} 中宣告的識別項</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesTitle">
        <source>Override equals and operator equals on value types</source>
        <target state="translated">覆寫實值型別上的 Equals 與等號比較運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesDescription">
        <source>For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</source>
        <target state="translated">對於實值型別而言，Equals 的繼承實作會使用反映庫，並會比較所有欄位的內容。反映相當耗費運算資源，而且可能不需要比較每個欄位是否相等。若希望使用者比較或排序執行個體，或是將執行個體用作為雜湊資料表索引鍵，則您的實值型別應實作 Equals。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals">
        <source>{0} should override Equals</source>
        <target state="translated">{0} 應該覆寫 Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality">
        <source>{0} should override the equality (==) and inequality (!=) operators</source>
        <target state="translated">{0} 應該覆寫等號比較運算子 (==) 以及不等比較運算子 (!=)</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysTitle">
        <source>Properties should not return arrays</source>
        <target state="translated">屬性不應傳回陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysDescription">
        <source>Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.</source>
        <target state="translated">即使屬性是唯讀屬性，屬性會傳回的陣列也不會受到防寫保護。為避免陣列遭他人竄改，屬性必須傳回陣列的複本。一般而言，使用者不了解呼叫這類屬性所造成的不良效能影響。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysMessage">
        <source>Properties should not return arrays</source>
        <target state="translated">屬性不應傳回陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsTitle">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">覆寫 Equals 時覆寫 GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsDescription">
        <source>GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code.</source>
        <target state="translated">GetHashCode 會依據目前執行個體傳回值，適用於雜湊演算法以及像是雜湊資料表等的資料結構。兩個具有相同類型且相等的物件，必須傳回相同的雜湊碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsMessage">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">覆寫 Equals 時覆寫 GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsTitle">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">多載等號比較運算子時覆寫 Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsDescription">
        <source>A public type implements the equality operator but does not override Object.Equals.</source>
        <target state="translated">公用類型會實作等號比較運算子，但不會覆寫 Object.Equals。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsMessage">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">多載等號比較運算子時覆寫 Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="Since_0_redefines_operator_1_it_should_also_redefine_operator_2">
        <source>Since '{0}' redefines operator '{1}', it should also redefine operator '{2}'</source>
        <target state="translated">因為 '{0}' 會重新定義運算子 '{1}'，所以其應也會重新定義運算子 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_missing_operators">
        <source>Generate missing operators</source>
        <target state="translated">產生遺漏的運算子</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">覆寫 object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnImplementingIEquatableCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">覆寫 object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsCodeActionTitle">
        <source>Override object.GetHashCode</source>
        <target state="translated">覆寫 object.GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeExceptionPublic">
        <source>Make exception public</source>
        <target state="translated">將例外狀況設為公用</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix1">
        <source>Make '{0}' protected.</source>
        <target state="translated">將 '{0}' 設為受保護。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix2">
        <source>Change '{0}' to a public interface implementation.</source>
        <target state="translated">將 '{0}' 變更為公用介面實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix3">
        <source>Make the containing type '{0}' sealed.</source>
        <target state="translated">將包含類型 '{0}' 設為密封。</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypeIsNotStatic">
        <source>Type '{0}' is a static holder type but is neither static nor NotInheritable</source>
        <target state="translated">類型 '{0}' 是靜態預留位置類型，但並非 Static 或 NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypesShouldBeStaticOrNotInheritable">
        <source>Static holder types should be Static or NotInheritable</source>
        <target state="translated">靜態預留位置類型應為 Static 或 NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeClassStatic">
        <source>Make Class Static</source>
        <target state="translated">將類別設為靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsMessage">
        <source>Type {0} should override Equals because it implements IEquatable&lt;T&gt;</source>
        <target state="translated">因為類型 {0} 會實作 IEquatable&lt;T&gt;，所以其應覆寫 Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsTitle">
        <source>Override Object.Equals(object) when implementing IEquatable&lt;T&gt;</source>
        <target state="translated">實作 IEquatable&lt;T&gt; 時覆寫 Object.Equals(object)</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersDescription">
        <source>Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.</source>
        <target state="translated">索引子 (也就是索引屬性) 應使用整數或字串作為索引類型。這些類型通常用於編製資料結構的索引，且可以提升程式庫的可用性。使用 Object 類型應限於無法在設計階段指定特定整數或字串類型的情況。若設計為索引需要其他類型，請重新考慮該類型是否代表邏輯資料存放區。若不代表邏輯資料存放區，請使用方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersMessage">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">為索引子使用整數或字串引數</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersTitle">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">為索引子使用整數或字串引數</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskDescription">
        <source>When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.</source>
        <target state="translated">當非同步方法直接等候 Task 時，接續會發生在建立工作的同一個執行緒中。請考慮呼叫 Task.ConfigureAwait(Boolean) 以表示您打算接續。對工作呼叫 ConfigureAwait(false) 可對執行緒集區排程接續，從而避免 UI 執行緒上產生死結。傳遞 false 是適用於應用程式獨立程式庫的選項。對工作呼叫 ConfigureAwait(true) 的行為與未明確呼叫 ConfigureAwait 的行為相同。明確呼叫此方法，表示要讓讀取器知道您打算對原始同步內容執行接續。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskMessage">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">請考慮對等候的工作呼叫 ConfigureAwait</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskTitle">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">請考慮對等候的工作呼叫 ConfigureAwait</target>
        <note />
      </trans-unit>
      <trans-unit id="AppendConfigureAwaitFalse">
        <source>Append .ConfigureAwait(false)</source>
        <target state="translated">附加 .ConfigureAwait(false)</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsDescription">
        <source>When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.</source>
        <target state="translated">當類型 T 覆寫 Object.Equals(object) 時，實作必須將物件引數轉換為正確的類型 T，然後才可執行比較。如果此類型會實作 IEquatable&lt;T&gt;，因而提供方法 T.Equals(T)，且引數若在編譯時期即已知為類型 T，則編譯器可呼叫 IEquatable&lt;T&gt;.Equals(T) 而非 Object.Equals(object)，而不需要轉換，如此即可改進效能。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsDescription">
        <source>When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".</source>
        <target state="translated">當類型 T 實作介面 IEquatable&lt;T&gt; 時，會向在原始程式碼中看到 Equals 方法呼叫的使用者指出，此類型的執行個體可以視為等同於其他任一類型的執行個體。如果使用者嘗試將此類型視為等同於另一個類型的執行個體，卻無法編譯，可能會感到困惑。這違反「最少意外原則」。</target>
        <note />
      </trans-unit>
      <trans-unit id="RenameToTitle">
        <source>Rename to '{0}'</source>
        <target state="translated">重新命名為 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsDescription">
        <source>A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</source>
        <target state="translated">只有在衍生方法的參數簽章因類型衍生時，較基底方法參數簽章中的類型來得弱時，基底類型中的方法才會被衍生類型中相同的具名方法所隱藏。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsMessage">
        <source>Change or remove '{0}' because it hides a more specific base class method: '{1}'</source>
        <target state="translated">變更或移除 '{0}'，因為其會隱藏較特殊的基底類別方法: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsTitle">
        <source>Do not hide base class methods</source>
        <target state="translated">請勿隱藏基底類別方法</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateMessage">
        <source>Remove '{0}' and replace its usage with a generic EventHandler, for example EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">移除 '{0}'，並以泛型 EventHandler 取代其用法，例如 EventHandler&lt;T&gt;，其中的 T 是有效的 EventArgs</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateDescription">
        <source>A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">類型包含傳回 void 的委派，其簽章包含兩個參數 (第一個參數是物件，第二個參數則是可指派給 EventArgs 的類型)，而內含的組件則以 Microsoft .NET Framework 2.0 為目標。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventMessage">
        <source>Change the event '{0}' to replace the type '{1}' with a generic EventHandler, for example EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">變更事件 '{0}' 來取代具有泛型 EventHandler 的型別 '{1}'，例如 EventHandler&lt;T&gt;，其中的 T 是有效的 EventArgs</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventDescription">
        <source>A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.</source>
        <target state="translated">處理公開或受保護事件的委派沒有正確的簽章、傳回類型或參數名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Message">
        <source>Change the event '{0}' to use a generic EventHandler by defining the event type explicitly, for e.g. Event MyEvent As EventHandler(Of MyEventArgs).</source>
        <target state="translated">明確定義事件類型，以將事件 '{0}' 變更為使用泛型 EventHandler，例如 Event MyEvent As EventHandler(Of MyEventArgs)。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Description">
        <source>A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">類型包含的事件會宣告傳回 void 的 EventHandler 委派，其簽章內含兩個參數 (第一個為物件，第二個為可指派至 EventArgs 的類型)，而內含的組件則以 Microsoft .NET Framework 2.0 為目標。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageBoth">
        <source>{0} should define operator(s) '{1}' and Equals since it implements IComparable</source>
        <target state="translated">因為 {0} 會實作 IComparable，所以應該定義運算子 '{1}' 與 Equals</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixTitle">
        <source>Avoid using cref tags with a prefix</source>
        <target state="translated">避免使用有前置詞的 cref 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixDescription">
        <source>Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax.</source>
        <target state="translated">應避免使用有前置詞的 cref 標籤，因為如此會導致編譯器無法驗證參考，並導致 IDE 無法於重構期間更新參考。如果因為編譯器無法找到提及的類型，而讓 cref 必須使用前置詞時，您可在單一文件網站上隱藏此錯誤。例如，如果 cref 提及完整架構中的某個特殊屬性，但您檔案的編譯對象為可攜式架構，或若想參考 Roslyn 更高層的類型，即不應出現此錯誤。即使只是單純求快而不想使用完整語法，也不應隱藏此項錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixMessage">
        <source>Avoid using cref tags with a prefix</source>
        <target state="translated">避免使用有前置詞的 cref 標籤</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">'{0}' 一律是 '{1}'。請移除條件或重構條件，避免使用無作用程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">'{0}' 一律不會是 '{1}'。請移除條件或重構條件，避免使用無作用程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="translated">避免使用無作用條件式程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">此規則會計算符號包含的唯一類型參考數目來衡量類別結合程度。類別結合程度高的符號可能難以維護。建議讓類型與方法的結合程度低而內聚程度高。若要修正此違規，請嘗試重新設計程式碼，減少其結合的類型數目。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">'{0}' 已與來自 '{2}' 個不同命名空間中的 '{1}' 個不同類型結合。請重寫或重構程式碼，以將其類別結合程度降低至 '{3}' 以下。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">避免過度的類別結合</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">循環複雜度會透過方法來測量線性獨立路徑的數目，而其取決於條件分支的數目及複雜度。循環複雜度較低通常表示方法很容易明瞭、測試及維護。循環複雜度由方法的控制流程圖進行計算，同時假設: '循環複雜度 = 邊緣數目 - 節點數目 + 1'，而節點則代表邏輯分支點，同時邊緣代表節點之間的線條。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">‘{0}’ 的循環複雜度為 ‘{1}’。請重寫或重構程式碼，以將其複雜度降低至 ‘{2}’ 以下。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">避免過度複雜</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">深度巢狀類型階層可能難以遵循、了解及維護。此規則會限制對同一個模組中階層的分析。若要修正違規，請從繼承階層較淺層的基底類型衍生類型，或去除部分中層基底類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'.</source>
        <target state="translated">'{0}' 的物件階層 '{1}' 層級，位於定義模組深層。請盡可能去除階層中的基底類別，以將其階層層級降低至 '{2}': '{3}' 以下。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">避免過度繼承</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">使用下列度量可計算維護性指數: 程式碼行數、程式量以及循環複雜度。從程式量可測出了解符號的困難度，而其取決於程式碼中的運算子與運算元數目。而循環複雜度可測出類型或方法的結構性複雜度。維護指數低，表示程式碼的維護可能較困難，而重新設計會是比較好的選擇。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">'{0}' 的可維護性指數為 '{1}'。請重寫或重構程式碼，以將其可維護性指數 (MI) 提高到 '{2}' 以上。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">避免無法維護的程式碼</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file.</source>
        <target state="translated">程式碼度量規則規格檔案中的項目無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">程式碼度量規則規格檔案 ‘{1}’ 中的項目 ‘{0}’ 無效</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">程式碼度量規則規格檔案中的項目無效</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">請勿略過方法結果</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">已建立但從未使用的新物件; 或是會建立並傳回呼叫的新字串之方法，以及從未使用過的新字串; 或是傳回 HRESULT 或從未使用過的錯誤碼之 COM 或 P/Invoke。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">{0} 建立了 {1} 的新執行個體，但從未使用過。請將執行個體以引數方式傳遞到另一個方法、將執行個體指派到變數，或是移除該物件建立 (若不需要的話)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">{0} 呼叫了 {1}，但未使用方法傳回的新字串執行個體。請將執行個體以引數方式傳遞到另一個方法、將執行個體指派到變數，或是移除該呼叫 (若不需要的話)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} 呼叫了 {1}，但未使用方法傳回的 HRESULT 或錯誤碼。如此可能會導致錯誤情況或資源不足時出現非預期的行為。請使用條件陳述式中的結果、將結果指派到變數，或將其以引數方式傳遞到另一個方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">{0} 呼叫了 {1}，但未明確地檢查轉換是否成功。請在條件陳述式中使用傳回值，或確認呼叫位置在轉換失敗時，預期會將 out 引數設為預設值。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">避免未具現化的內部類別</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">組件層級類型的執行個體，並非由組件中的程式碼所建立。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>'{0}' is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it 'static' (Module in Visual Basic).</source>
        <target state="translated">'{0}' 是明顯從未具現化的內部類別。若是如此，請從組件中移除該程式碼。如果此類別預計只會包含靜態成員，請將其設為 'static' (在 Visual Basic 中為 Module )。</target>
        <note>{Locked="Module"}</note>
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">避免未使用的私用欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">偵測到似乎無法於組件內存取的私用欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'</source>
        <target state="translated">未使用的欄位 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} 呼叫了 {1}，但未使用方法傳回的值。因為 {1} 標記為 Pure 方法，所以不能有副作用。請使用條件陳述式中的結果、將結果指派到變數，或將其以引數方式傳遞到另一個方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">使用 nameof 可以協助您於重構時保持程式碼的有效性。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">使用 nameof 取代字串常值 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">使用 nameof 表示符號名稱</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself</source>
        <target state="translated">不應將屬性 {0} 指派給屬性自身</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself</source>
        <target state="translated">請勿將屬性指派給屬性自身</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">使其變成靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">無法修正對 '{0}' 的某些參考，應予以手動修正。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">適當時機使用常值</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at runtime.</source>
        <target state="translated">宣告為靜態及唯讀的欄位 (在 Visual Basic 中為 Shared 及 ReadOnly)，使用編譯時期可計算的值初始化。因為指派給目標欄位的值，可於編譯期間進行計算，將宣告變更為 Const (在 Visual Basic 中為 Const) 欄位，所以此值可於編譯期間計算，而非於執行階段計算。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">欄位 '{0}' 宣告為 'readonly'，但卻使用了常數值進行初始化。將此欄位改標記為 'const'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">欄位 '{0}' 宣告為 'readonly'，但卻使用了空字串 ("") 進行初始化。將此欄位改標記為 'const'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">請勿進行非必要的初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The .NET runtime initializes all fields of reference types to their default values before running the constructor. In most cases, explicitly initializing a field to its default value in a constructor is redundant, adding maintenance costs and potentially degrading performance (such as with increased assembly size), and the explicit initialization can be removed.  In some cases, such as with static readonly fields that permanently retain their default value, consider instead changing them to be constants or properties.</source>
        <target state="translated">.NET 執行階段在執行建構函式之前，會先將所有參考型別欄位初始化為其預設值。在多數情況下，將建構函式中的欄位明確地初始化為其預設值是多餘的動作，不僅增加維護成本，而且可能會降低效能 (例如增加了組件大小)，因此可以將明確初始化移除。在某些情況 (例如會永久保留預設值的靜態唯讀欄位) 下，應考慮將其變更為常數或屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Member '{0}' is explicitly initialized to its default value</source>
        <target state="translated">已明確將成員 '{0}' 初始化為其預設值</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">多維度上建議使用不規則陣列</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">不規則陣列是其元素為陣列的陣列。構成元素的這些陣列可能大小不一，讓某些資料集可以少浪費一些空間。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} 是多維度陣列。如果可能，請用不規則陣列取代它。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} 會傳回多維度陣列 {1}。如果可能，請用不規則陣列取代它。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} 使用多維度陣列 {1}。如果可能，請用不規則陣列取代它。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">將成員標記為靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static. After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">不會存取執行個體資料或呼叫執行個體方法的成員，可標記為靜態。當您將方法標記為靜態之後，編譯器會對這些成員發出非虛擬呼叫位置。您如此即可針對重視效能的程式碼，取得可衡量的效能提升。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member '{0}' does not access instance data and can be marked as static</source>
        <target state="translated">成員 '{0}' 不會存取執行個體資料，因而可標記為靜態</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">密封滿足私用介面的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">可繼承的公用型別提供內部 (在 Visual Basic 中為 Friend) 介面的可覆寫方法實作。若要修正此規則的違規，請讓方法無法於組件之外進行覆寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">密封滿足私用介面的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">移除空的完成項</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">請盡量不要使用完成項，以避免在追蹤物件存留期時產生了額外的效能負荷。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">請勿呼叫建構函式中的可覆寫方法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">不應從建構函式呼叫類別上定義的虛擬方法。若衍生的類別覆寫了此方法，就會 (在呼叫衍生類別建構函式之前) 呼叫此衍生類別版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information</source>
        <target state="translated">重新擲回攔截到的例外狀況變更堆疊資訊</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">重新擲回以保存堆疊詳細資料</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">將宣告類型設內部類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">將宣告類型設為密封類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">將成員設為不可覆寫。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">當 Finally 子句中引發例外狀況時，新的例外狀況會隱藏作用中的例外狀況。這會讓原始錯誤的偵測與偵錯更加困難。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause</source>
        <target state="translated">請勿在 finally 子句中引發例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">請勿在 finally 子句中引發例外狀況</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">變更為常數</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">物件初始設定式中的索引元素必須將唯一元素初始化。重複的索引可能會覆寫先前的元素初始化。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>Redundant element initialization at index '{0}'. Object initializer has another element initializer with the same index that overwrites this value.</source>
        <target state="translated">索引 '{0}' 有多餘的項目初始設定。物件初始設定式有另一個項目初始設定式具備相同的索引，該索引會覆寫此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">請勿複製索引元素初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is 'null' ('Nothing' in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against 'null'. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">外部可見的方法，會解除參照其中一個它的參考引數，而會不確認該引數是否為 'null' (Visual Basic 中的 'Nothing')。但所有傳遞到外部可見方法的參考引數，都應檢查是否為 'null'。若可行的話，當引數為 'null' 時請擲回 'ArgumentNullException'。若該方法設計為只可由已知組件呼叫，則應將該方法設為內部方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'.</source>
        <target state="translated">在外部可見方法 '{0}' 中，驗證參數 '{1}' 在使用前會是非 null。若可行的話，當引數為 'null' 時請擲回 'ArgumentNullException'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">必須驗證公用方法的引數</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>