<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../MicrosoftCodeQualityAnalyzersResources.resx">
    <body>
      <trans-unit id="AppendConfigureAwaitTrue">
        <source>Append .ConfigureAwait(true)</source>
        <target state="translated">.ConfigureAwait(true) を追加します</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementDescription">
        <source>Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements.</source>
        <target state="translated">同じステートメントにシンボルとそのメンバー (フィールドとプロパティ) を代入することは推奨されていません。メンバー アクセスが、代入前のシンボルの古い値を使用するのか、このステートメントの代入からの新しい値を使用するのかが明確ではありません。わかりやすくするために、代入を個別のステートメントに分割することをご検討ください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementMessage">
        <source>Symbol '{0}' and its member '{1}' are both assigned in the same statement. You are at risk of assigning the member of an unintended object.</source>
        <target state="translated">シンボル '{0}' とそのメンバー '{1}' の両方が同じステートメントに割り当てられています。意図しないオブジェクトのメンバーが割り当てられているおそれがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementTitle">
        <source>Assigning symbol and its member in the same statement.</source>
        <target state="translated">同じステートメントにシンボルとそのメンバーを割り当てています。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidTitle">
        <source>Avoid Async Void</source>
        <target state="translated">Async Void を使用しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidMessage">
        <source>Avoid Async Void</source>
        <target state="translated">Async Void を使用しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncTitle">
        <source>Async Method Names Should End in Async</source>
        <target state="translated">非同期メソッド名は Async で終わる必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncMessage">
        <source>Async Method Names Should End in Async</source>
        <target state="translated">非同期メソッド名は Async で終わる必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionMessageMaybe">
        <source>Do not assign the property within its setter. This call might result in an infinite recursion.</source>
        <target state="translated">プロパティをそのセッター内に割り当てないでください。この呼び出しにより、無限再帰が発生する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionMessageSure">
        <source>Do not assign the property within its setter. This call will result in an infinite recursion.</source>
        <target state="translated">プロパティをそのセッター内に割り当てないでください。この呼び出しにより、無限再帰が発生します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionTitle">
        <source>Avoid infinite recursion</source>
        <target state="translated">無限再帰の回避</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersDescription">
        <source>Passing types by reference (using 'out' or 'ref') requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between 'out' and 'ref' parameters is not widely understood.</source>
        <target state="translated">('out' または 'ref' を使用して) 型を参照によって渡すには、ポインターの使用経験、値型と参照型の違いの理解、および複数の戻り値を持つ処理メソッドが必要です。また、'out' と 'ref' のパラメーターの違いはあまり理解されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersMessage">
        <source>Avoid 'out' parameters as they are not designed for general audience.</source>
        <target state="translated">一般向けに設計されていないため、'out' パラメーターは使用しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersTitle">
        <source>Avoid out parameters</source>
        <target state="translated">out パラメーターを使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesDescription">
        <source>A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught.</source>
        <target state="translated">System.Exception や System.SystemException などの一般的な例外、または許可されていない例外の種類は catch ステートメントでキャッチされます。または一般的な catch 句を使用します。一般的な例外と許可されていない例外をキャッチしないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesMessage">
        <source>Modify '{0}' to catch a more specific allowed exception type, or rethrow the exception.</source>
        <target state="translated">'{0}' を変更して特定の許可された例外の種類をさらにキャッチするか、例外を再スローします。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesTitle">
        <source>Do not catch general exception types</source>
        <target state="translated">一般的な例外の種類はキャッチしません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageLinqMethod">
        <source>{0} calls {1} but does not use the value the method returns. Linq methods are known to not have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="new">{0} calls {1} but does not use the value the method returns. Linq methods are known to not have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesTitle">
        <source>Don't Pass Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">デリゲート型を返す Void として非同期ラムダを渡さないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesMessage">
        <source>Don't Pass Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">デリゲート型を返す Void として非同期ラムダを渡さないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceDescription">
        <source>Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Also, the difference between out and ref parameters is not widely understood.</source>
        <target state="new">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Also, the difference between out and ref parameters is not widely understood.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceMessage">
        <source>Consider a design that does not require that '{0}' be a reference parameter.</source>
        <target state="new">Consider a design that does not require that '{0}' be a reference parameter.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceTitle">
        <source>Do not pass types by reference</source>
        <target state="new">Do not pass types by reference</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameDescription">
        <source>An enumeration's values should not start with the type name of the enumeration.</source>
        <target state="translated">列挙値は、列挙型名で始まらないようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameMessage">
        <source>Do not prefix enum values with the name of the enum type '{0}'. </source>
        <target state="translated">列挙値の前に列挙型 '{0}' の名前を付けないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameTitle">
        <source>Do not prefix enum values with type name</source>
        <target state="translated">列挙値の前に型名を付けないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesTitle">
        <source>Don't Store Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">デリゲート型を返す Void として非同期ラムダを格納しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesMessage">
        <source>Don't Store Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">デリゲート型を返す Void として非同期ラムダを格納しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesMessageDuplicatedBitwiseValuePart">
        <source>The field reference '{0}' is duplicated in this bitwise initialization.</source>
        <target state="translated">フィールド参照 '{0}' は、このビット単位の初期化で重複しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesMessageDuplicatedValue">
        <source>The enum member '{0}' has the same constant value '{1}' as member '{2}'.</source>
        <target state="translated">列挙型メンバー '{0}' の定数値 '{1}' がメンバー '{2}' と同じです。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesTitle">
        <source>Enums values should not be duplicated</source>
        <target state="translated">列挙値を重複させることはできない</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeOverride">
        <source>Remove the finalizer from type '{0}', override Dispose(bool disposing), and put the finalization logic in the code path where 'disposing' is false. Otherwise, it might lead to duplicate Dispose invocations as the Base type '{1}' also provides a finalizer.</source>
        <target state="translated">型 '{0}' からファイナライザーを削除し、Dispose(bool disposing) をオーバーライドします。その後、'disposing' が false のコード パスに finalization 論理を配置します。その他の場合、基本型 '{1}' でもファイナライザーが提供されるため、Dispose 呼び出しが重複する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleTitle">
        <source>Propagate CancellationTokens When Possible</source>
        <target state="translated">可能な場合は CancellationToken を伝達してください</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleMessage">
        <source>Propagate CancellationTokens When Possible</source>
        <target state="translated">可能な場合は CancellationToken を伝達してください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncTitle">
        <source>Don't Mix Blocking and Async</source>
        <target state="translated">ブロッキングと非同期を組み合わせないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncMessage">
        <source>Don't Mix Blocking and Async</source>
        <target state="translated">ブロッキングと非同期を組み合わせないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableTitle">
        <source>Types that own disposable fields should be disposable</source>
        <target state="translated">破棄可能なフィールドを所有する型は、破棄可能でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableDescription">
        <source>A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</source>
        <target state="translated">クラスが System.IDisposable 型であるインスタンス フィールドを宣言および実装していますが、IDisposable を実装していません。IDisposable フィールドを宣言するクラスは間接的にアンマネージ リソースを所有しているため、IDisposable インターフェイスを実装する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking">
        <source>Type '{0}' owns disposable field(s) '{1}' but is not disposable</source>
        <target state="translated">型 '{0}' は破棄可能なフィールド '{1}' を所有しますが、破棄可能ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesTitle">
        <source>Use generic event handler instances</source>
        <target state="translated">汎用イベント ハンドラーのインスタンスを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueTitle">
        <source>Enums should have zero value</source>
        <target state="translated">列挙型は 0 値を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueDescription">
        <source>The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.</source>
        <target state="translated">初期化されていない列挙型の既定値は、他の値型と同様に、ゼロです。Flags 属性以外が指定された列挙型では、既定値が有効な列挙値になるように、値 0 を使用してメンバーを定義する必要があります。FlagsAttribute 属性が適用されている列挙型で 0 値のメンバーを定義する場合は、その名前を ""None"" にして、列挙型に値が設定されていないことを示す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsRename">
        <source>In enum {0}, change the name of {1} to 'None'.</source>
        <target state="translated">列挙型 {0} では、{1} の名前を 'None' に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsMultipleZeros">
        <source>Remove all members that have the value zero from {0} except for one member that is named 'None'.</source>
        <target state="translated">'None' という名前の 1 つのメンバーを除き、値 0 を含むすべてのメンバーを {0} から削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue">
        <source>Add a member to {0} that has a value of zero with a suggested name of 'None'.</source>
        <target state="translated">提案された名前 'None' を伴う、値 0 を含む {0} にメンバーを追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsTitle">
        <source>Abstract types should not have constructors</source>
        <target state="translated">抽象型はコンストラクターを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsDescription">
        <source>Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</source>
        <target state="translated">抽象型のコンストラクターは、派生型からのみ呼び出すことができます。パブリック コンストラクターによって型のインスタンスが作成され、抽象型のインスタンスを自分で作成できないため、パブリック コンストラクターを含む抽象型は正しく設計されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsMessage">
        <source>Abstract type {0} should not have constructors</source>
        <target state="translated">抽象型 {0} はコンストラクターを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantTitle">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">アセンブリに CLSCompliant を設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantDescription">
        <source>The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.</source>
        <target state="translated">共通言語仕様 (CLS) では、名前付け制限、データ型、規則が定義されています。アセンブリは、複数のプログラミング言語で使用する場合、これらに準拠する必要があります。すべてのアセンブリに CLSCompliantAttribute を使用して CLS への準拠を明示することをお勧めします。この属性がアセンブリに存在しない場合、そのアセンブリは CLS に準拠しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantMessage">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">アセンブリに CLSCompliant を設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionTitle">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">アセンブリにアセンブリ バージョンを設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionDescription">
        <source>The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.</source>
        <target state="translated">.NET Framework では、バージョン番号を使用してアセンブリを一意に識別し、厳密な名前が指定されたアセンブリの型にバインドします。バージョン番号は、バージョンと発行者ポリシーと共に使用されます。既定で、アプリケーションは、ビルドに使用されたアセンブリ バージョンでのみ実行されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionMessage">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">アセンブリにアセンブリ バージョンを設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleTitle">
        <source>Mark assemblies with ComVisible</source>
        <target state="translated">アセンブリに ComVisible を設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleDescription">
        <source>ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.</source>
        <target state="translated">ComVisibleAttribute によって、COM クライアントからマネージ コードにアクセスする方法を決定します。この場合、アセンブリが COM の参照可能性を明示的に示すことが推奨されます。COM の参照可能性は、アセンブリ全体で設定した後、個々の型と型メンバーに対してオーバーライドできます。この属性が存在しない場合、アセンブリのコンテンツは COM クライアントから参照できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleMessageNoAttribute">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</source>
        <target state="translated">{0} は外部から参照可能な型を公開するため、アセンブリ レベルで ComVisible(false) に設定し、COM クライアントに公開する必要があるアセンブリ内のすべての型を ComVisible(true) に設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleMessageAttributeTrue">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</source>
        <target state="translated">{0} の ComVisible 属性を false に変更してから、各型レベルで調節することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageTitle">
        <source>Mark attributes with AttributeUsageAttribute</source>
        <target state="translated">属性を AttributeUsageAttribute に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageDescription">
        <source>When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code.</source>
        <target state="translated">カスタム属性を定義する場合、AttributeUsageAttribute を使用して、ソース コード内でカスタム属性を適用できる位置を示すように設定します。属性の意味と用途により、コード内での有効な位置が決まります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageDefault">
        <source>Specify AttributeUsage on {0}.</source>
        <target state="translated">AttributeUsage を {0} で指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageInherited">
        <source>Even though attribute {0} inherits AttributeUsage from its base type, you should consider explicitly specifying AttributeUsage on the type to improve code readability and documentation.</source>
        <target state="translated">属性 {0} がその基本データ型から AttributeUsage を継承した場合でも、コードの読みやすさ、ドキュメントを改善するために、AttributeUsage をその型で明示的に指定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsTitle">
        <source>Define accessors for attribute arguments</source>
        <target state="translated">属性引数にアクセサーを定義します</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsDescription">
        <source>Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</source>
        <target state="translated">属性は、対象に適用するときに指定する必要のある必須の引数を定義できます。これらは、属性コンストラクターに位置指定パラメーターとして指定されるため、位置指定引数とも呼ばれます。必須の属性ごとに、属性は、引数の値を実行時に取得できるように、対応する読み取り専用プロパティも提供する必要があります。また、属性は省略可能な引数も定義できます。これは名前付き引数とも呼ばれます。これらの引数は、名前で属性コンストラクターに指定され、対応する読み取り/書き込みプロパティが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageDefault">
        <source>Add a public read-only property accessor for positional argument {0} of Attribute {1}.</source>
        <target state="translated">属性 {1} の位置引数 {0} 用にパブリックな読み取り専用プロパティ アクセサーを追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageRemoveSetter">
        <source>Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}.</source>
        <target state="translated">プロパティ set アクセス操作子が位置引数 {1} に対応しているため、これを {0} から削除するか、アクセシビリティを下げてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility">
        <source>If {0} is the property accessor for positional argument {1}, make it public.</source>
        <target state="translated">{0} が位置引数 {1} のプロパティ アクセサーである場合は、パブリックにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateTitle">
        <source>Use properties where appropriate</source>
        <target state="translated">適切な場所にプロパティを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateDescription">
        <source>A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.</source>
        <target state="translated">パブリック メソッドまたは保護されたメソッドは、""Get"" で始まる名前を持ち、パラメーターを受け取らず、配列ではない値を返します。このメソッドは、プロパティに変更できる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateMessage">
        <source>Use properties where appropriate</source>
        <target state="translated">適切な場所にプロパティを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsTitle">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">列挙型を FlagsAttribute に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsDescription">
        <source>An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</source>
        <target state="translated">列挙型は、関連する一連の名前付き定数を定義する値型です。名前付き定数を意味を持つように組み合わせることができる場合は、列挙型に FlagsAttribute を適用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsMessage">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">列挙型を FlagsAttribute に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesTitle">
        <source>Interface methods should be callable by child types</source>
        <target state="translated">インターフェイス メソッドは、子型によって呼び出し可能でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesDescription">
        <source>An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</source>
        <target state="translated">外部から参照可能なアンシールド型により、メソッドによるパブリック インターフェイスの明示的な実装が提供されます。また、同じ名前が付いた外部から参照可能な代替のメソッドは提供されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesMessage">
        <source>Make '{0}' sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of '{1}' and is visible to derived classes.</source>
        <target state="translated">'{0}' をシールドにするか (このクラスが以前に出荷されている場合は重大な変更)、メソッドを非明示的に実装するか、'{1}' の機能を公開して派生クラスに表示される新しいメソッドを実装します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesTitle">
        <source>Override methods on comparable types</source>
        <target state="translated">比較可能な型でメソッドをオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesDescription">
        <source>A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.</source>
        <target state="translated">パブリック型または保護された型で System.IComparable インターフェイスを実装します。これにより、Object.Equals はオーバーライドされません。また、"等しい"、"等しくない"、"未満"、"以下"、"より大きい"、または "以上" を示す言語固有の演算子はオーバーロードされません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageEquals">
        <source>{0} should override Equals since it implements IComparable.</source>
        <target state="translated">{0} は、IComparable を実装しているため、Equals をオーバーライドしなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageOperator">
        <source>{0} should define operator(s) '{1}' since it implements IComparable.</source>
        <target state="translated">{0} は、IComparable を実装しているため、演算子 '{1}' を定義しなければなりません。</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassTitle">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">pinvoke をネイティブ メソッド クラスに移動します</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassDescription">
        <source>Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</source>
        <target state="translated">プラットフォーム呼び出しメソッド (System.Runtime.InteropServices.DllImportAttribute 属性を使用してマークされているメソッドなど) または Visual Basic で Declare キーワードを使用して定義されているメソッドが、アンマネージ コードにアクセスしています。これらのメソッドは、NativeMethods、SafeNativeMethods、または UnsafeNativeMethods クラスに属している必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassMessage">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">pinvoke をネイティブ メソッド クラスに移動します</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseTitle">
        <source>Identifiers should differ by more than case</source>
        <target state="translated">識別子は、大文字と小文字の区別以外にも相違していなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseDescription">
        <source>Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</source>
        <target state="translated">名前空間、型、メンバー、およびパラメーターの識別子は、大文字/小文字だけを変更しても区別できません。共通言語ランタイムを対象とする言語は、大文字と小文字を区別する必要がないためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseMessage">
        <source>Names of '{0}' and '{1}' should differ by more than case.</source>
        <target state="translated">名前 '{0}' および '{1}' は、大文字と小文字の区別以外にも相違させる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixTitle">
        <source>Identifiers should have correct prefix</source>
        <target state="translated">識別子は正しいプレフィックスを含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixDescription">
        <source>The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".</source>
        <target state="translated">外部から参照可能なインターフェイスの名前は大文字の ""I"" で始まりません。外部から参照可能な型またはメソッドのジェネリック型パラメーターの名前は大文字の ""T"" で始まりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageInterface">
        <source>Prefix interface name {0} with 'I'.</source>
        <target state="translated">インターフェイス名 {0} にプレフィックスとして 'I' を指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageTypeParameter">
        <source>Prefix generic type parameter name {0} with 'T'.</source>
        <target state="translated">ジェネリック型パラメーター名 {0} にプレフィックスとして 'T' を指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleTitle">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">非定数フィールドは表示されません</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleDescription">
        <source>Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</source>
        <target state="translated">定数でも読み取り専用でもない静的フィールドは、スレッドセーフではありません。このようなフィールドへのアクセスは慎重に制御する必要があります。また、クラス オブジェクトへのアクセスを同期するには、高度なプログラミング技術が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleMessage">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">非定数フィールドは表示されません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsTitle">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">列挙型を FlagsAttribute に設定しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsDescription">
        <source>An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</source>
        <target state="translated">外部から参照可能な列挙型が FlagsAttribute を使用してマークされ、その列挙型に、2 の累乗でもその列挙型で定義されている他の値の組み合わせでもない値が 1 つ以上含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsMessage">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">列挙型を FlagsAttribute に設定しません</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesTitle">
        <source>Operator overloads have named alternates</source>
        <target state="translated">演算子オーバーロードには名前付けされた代替が存在します</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesDescription">
        <source>An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</source>
        <target state="translated">演算子オーバーロードが検出され、予想される名前の代替メソッドが検出されませんでした。名前付きの代替メンバーは、演算子と同じ機能へアクセスを提供し、オーバーロードされた演算子をサポートしていない言語でプログラミングを行う開発者にも提供されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageDefault">
        <source>Provide a method named '{0}' as a friendly alternate for operator {1}.</source>
        <target state="translated">'{0}' という名前のメソッドを演算子 {1} の代替として指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageProperty">
        <source>Provide a property named '{0}' as a friendly alternate for operator {1}.</source>
        <target state="translated">'{0}' という名前のプロパティを演算子 {1} の代替として指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageMultiple">
        <source>Provide a method named '{0}' or '{1}' as an alternate for operator {2}.</source>
        <target state="translated">'{0}' または '{1}' という名前のメソッドを演算子 {2} の代替として指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageVisibility">
        <source>Mark {0} as public because it is a friendly alternate for operator {1}.</source>
        <target state="translated">演算子 {1} の代替であるため {0} をパブリックに設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsTitle">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">演算子は対称型オーバーロードを含まなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsDescription">
        <source>A type implements the equality or inequality operator and does not implement the opposite operator.</source>
        <target state="translated">型で等値演算子または非等値演算子を実装し、逆の働きをする演算子を実装しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsMessage">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">演算子は対称型オーバーロードを含まなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyTitle">
        <source>Collection properties should be read only</source>
        <target state="translated">コレクション プロパティは読み取り専用でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyDescription">
        <source>A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.</source>
        <target state="translated">書き込み可能なコレクション プロパティにより、ユーザーはコレクションを別のコレクションに置き換えることができます。読み取り専用のプロパティでは、コレクションを置き換えることはできませんが、引き続き個々のメンバーは設定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyMessage">
        <source>Change '{0}' to be read-only by removing the property setter.</source>
        <target state="translated">プロパティ set アクセス操作子を削除して '{0}' を読み取り専用に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">値型 Equals のオーバーライドで、演算子 equals をオーバーロードします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription">
        <source>In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals</source>
        <target state="translated">ほとんどのプログラミング言語では、値型に対する等値演算子 (==) の既定の実装がありません。プログラミング言語で演算子のオーバーロードがサポートされている場合は、等値演算子の実装を検討してください。その動作は、Equals の動作と同じである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">値型 Equals のオーバーライドで、演算子 equals をオーバーロードします</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsTitle">
        <source>Pass system uri objects instead of strings</source>
        <target state="translated">文字列ではなくシステム uri オブジェクトを渡します</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsDescription">
        <source>A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</source>
        <target state="translated">名前に "uri"、"URI"、"urn"、"URN"、"url"、または "URL" が含まれている文字列パラメーターが指定されたメソッドが呼び出されます。そのメソッドの宣言する型には、System.Uri パラメーターが指定されている対応するメソッド オーバーロードが含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsMessage">
        <source>Modify '{0}' to call '{1}' instead of '{2}'.</source>
        <target state="translated">'{2}' ではなく '{1}' を呼び出すように '{0}' を変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsTitle">
        <source>Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</source>
        <target state="translated">型 {0} は Equals をオーバーライドするため、IEquatable&lt;T&gt; を実装する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsMessage">
        <source>Implement IEquatable when overriding Object.Equals</source>
        <target state="translated">Object.Equals をオーバーライドする際に IEquatable を実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastTitle">
        <source>CancellationToken parameters must come last</source>
        <target state="translated">CancellationToken パラメーターは最後に指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastMessage">
        <source>Method '{0}' should take CancellationToken as the last parameter</source>
        <target state="translated">メソッド '{0}' は、CancellationToken を最後のパラメーターとして受け取る必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableTitle">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="translated">コンストラクターにより、継承不可能な基底クラスが継承可能になります</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableDescription">
        <source>When a base class is noninheritable because its constructor is internal, a derived class should not make it inheritable by having a public or protected constructor.</source>
        <target state="translated">コンストラクターが内部であるために基底クラスが継承不可能な場合は、派生クラスは、パブリック コンストラクターまたは保護されたコンストラクターを設定して基底クラスを継承可能にしないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableMessage">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="translated">コンストラクターにより、継承不可能な基底クラスが継承可能になります</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesTitle">
        <source>Identifier contains type name</source>
        <target state="translated">識別子に型名が含まれます</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesDescription">
        <source>Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.</source>
        <target state="translated">パラメーターとメンバーの名前では、パラメーターとメンバーの型ではなく意味を伝えるようにします。パラメーターとメンバーの型は、開発ツールで表示されるためです。メンバー名では、データ型名を使用する必要がある場合、言語固有の名前ではなく、言語に依存しない名前を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesMessage">
        <source>Identifier '{0}' contains type name</source>
        <target state="translated">識別子 '{0}' に型名が含まれます</target>
        <note />
      </trans-unit>
      <trans-unit id="CreatePropertyAccessorForParameter">
        <source>Create a property accessor.</source>
        <target state="translated">プロパティ アクセサーを作成します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeGetterPublic">
        <source>Make the getter of the property public</source>
        <target state="translated">プロパティのゲッターをパブリックにします</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeSetterNonPublic">
        <source>Make the setter of the property non-public</source>
        <target state="translated">プロパティのセッターを非パブリックにします</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAssemblyLevelComVisibleFalse">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</source>
        <target state="translated">{0} は外部から参照可能な型を公開するため、アセンブリ レベルで ComVisible(false) に設定し、COM クライアントに公開する必要があるアセンブリ内のすべての型を ComVisible(true) に設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeAssemblyLevelComVisibleToFalse">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</source>
        <target state="translated">{0} の ComVisible 属性を false に変更してから、各型レベルで調節することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementComparable">
        <source>Implement Equality and Comparison methods and operators</source>
        <target state="translated">等値および比較メソッドおよび演算子を実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementEquatable">
        <source>Implement IEquatable</source>
        <target state="translated">IEquatable を実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableInterface">
        <source>Implement IDisposable Interface</source>
        <target state="translated">IDisposable インターフェイスを実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsCodeFix">
        <source>Remove FlagsAttribute from enum.</source>
        <target state="translated">FlagsAttribute を列挙型から削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsCodeFix">
        <source>Apply FlagsAttribute to enum.</source>
        <target state="translated">FlagsAttribute を列挙型に適用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsMultipleZeroCodeFix">
        <source>Remove all members that have the value zero except for one member that is named 'None'.</source>
        <target state="translated">'None' という名前の 1 つのメンバー以外の、値 0 を含むすべてのメンバーを削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsRenameCodeFix">
        <source>Rename zero-valued enum field to 'None'.</source>
        <target state="translated">0 値の列挙型フィールドの名前を 'None' に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix">
        <source>Add a zero-valued member 'None' to enum.</source>
        <target state="translated">0 値のメンバー 'None' を列挙型に追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHavePublicConstructorsCodeFix">
        <source>Change the accessibility of public constructors to protected.</source>
        <target state="translated">パブリック コンストラクターのアクセシビリティを protected に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesTitle">
        <source>Do not declare static members on generic types</source>
        <target state="translated">ジェネリック型の静的メンバーを宣言しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesDescription">
        <source>When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.</source>
        <target state="translated">ジェネリック型の静的メンバーを呼び出すときには、その型の型引数も指定する必要があります。推論をサポートしない汎用インスタンス メンバーが呼び出されるときに、そのメンバーに型引数を指定する必要があります。この 2 つのケースでは、型引数を指定するための構文は異なりますが、混同されることがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesMessage">
        <source>Do not declare static members on generic types</source>
        <target state="translated">ジェネリック型の静的メンバーを宣言しません</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceTitle">
        <source>Generic interface should also be implemented</source>
        <target state="translated">ジェネリック インターフェイスも実装する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceDescription">
        <source>To broaden the usability of a type, implement one of the generic interfaces. This is especially true for collections as they can then be used to populate generic collection types.</source>
        <target state="translated">型の操作性を拡充するには、ジェネリック インターフェイスの 1 つを実装します。これは特にコレクションの場合に有効です。これらを使用してジェネリック コレクション型にデータを設定できるようになるためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMessage">
        <source>Type '{0}' directly or indirectly inherits '{1}' without implementing '{2}'. Publicly-visible types should implement the generic version to broaden usability.</source>
        <target state="translated">型 '{0}' は、'{2}' を実装することなく '{1}' を直接または間接的に継承します。公開されている型は、操作性の拡充のためジェネリック バージョンを実装する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Title">
        <source>Enum Storage should be Int32</source>
        <target state="translated">列挙ストレージは Int32 でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Description">
        <source>An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.</source>
        <target state="translated">列挙型は、関連する一連の名前付き定数を定義する値型です。既定では、System.Int32 データ型は、定数値の格納に使用されます。この基になる型を変更することはできますが、ほとんどの場合、変更する必要はなく、また推奨もされません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Message">
        <source>If possible, make the underlying type of {0} System.Int32 instead of {1}.</source>
        <target state="translated">可能な場合は、基になる型 {0} を {1} ではなく System.Int32 にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateTitle">
        <source>Use events where appropriate</source>
        <target state="translated">適切な場所にイベントを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateDescription">
        <source>This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.</source>
        <target state="translated">この規則では、通常はイベントに使用される名前の付いたメソッドを検出します。明示的に定義された状態変化に応答してメソッドが呼び出される場合、メソッドはイベント ハンドラーから呼び出す必要があります。メソッドを呼び出すオブジェクトは、メソッドを直接呼び出すのではなく、イベントを発生させる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateMessage">
        <source>Consider making '{0}' an event.</source>
        <target state="translated">'{0}' をイベントにすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsTitle">
        <source>Implement standard exception constructors</source>
        <target state="translated">標準例外コンストラクターを実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsDescription">
        <source>Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</source>
        <target state="translated">すべてのコンストラクターを指定できなかった場合、例外を正しく処理することが困難になる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageMissingConstructor">
        <source>Add the following constructor to {0}: {1}.</source>
        <target state="translated">次のコンストラクターを {0} に追加します: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageAccessibility">
        <source>Change the accessibility of {0} to {1}.</source>
        <target state="translated">{0} のアクセシビリティを {1} に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleTitle">
        <source>Nested types should not be visible</source>
        <target state="translated">入れ子にされた型を参照可能にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleDescription">
        <source>A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.</source>
        <target state="translated">入れ子にされた型とは、別の型のスコープ内で宣言された型のことです。入れ子にされた型は、それを含む型のプライベート実装の詳細をカプセル化するときに便利です。このような用途のため、入れ子にされた型は外部から参照できないようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageDefault">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible.</source>
        <target state="translated">型 {0} を入れ子にしないでください。外部から参照できなくするために、そのアクセシビリティを変更することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageVisualBasicModule">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module.</source>
        <target state="translated">型 {0} を入れ子にしないでください。外部から参照できなくするために、そのアクセシビリティを変更することもできます。この型は、Visual Basic モジュールで定義されている場合、他の .NET 言語への入れ子にされた型と見なされます。その場合、その型をモジュールの外部へ移動することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesTitle">
        <source>Avoid empty interfaces</source>
        <target state="translated">空のインターフェイスは使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesDescription">
        <source>Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</source>
        <target state="translated">インターフェイスは、動作や使用のコントラクトを提供するメンバーを定義します。インターフェイスで示される機能は、継承階層内に型が存在するかどうかにかかわらず、どの型からも適用できます。型ではインターフェイスのメンバーに実装を提供することで、インターフェイスが実装されます。空のインターフェイスではメンバーが定義されません。そのため、実装できるコントラクトも定義されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesMessage">
        <source>Avoid empty interfaces</source>
        <target state="translated">空のインターフェイスは使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageTitle">
        <source>Provide ObsoleteAttribute message</source>
        <target state="translated">ObsoleteAttribute メッセージを指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageDescription">
        <source>A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.</source>
        <target state="translated">型またはメンバーが System.ObsoleteAttribute 属性でマークされていますが、この属性では ObsoleteAttribute.Message プロパティが指定されていません。ObsoleteAttribute でマークされている型またはメンバーをコンパイルすると、属性の Message プロパティが表示されます。これにより、古いの型またはメンバーに関する情報がユーザーに表示されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageMessage">
        <source>Provide a message for the ObsoleteAttribute that marks {0} as Obsolete</source>
        <target state="translated">{0} を Obsolete に設定する ObsoleteAttribute のメッセージを指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyTitle">
        <source>Properties should not be write only</source>
        <target state="translated">プロパティを書き込み専用にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyDescription">
        <source>Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</source>
        <target state="translated">これは許容されており、読み取り専用プロパティが必要になる場合もよくありますが、デザイン ガイドラインでは、書き込み専用プロパティの使用が禁止されています。これは、ユーザーが値を設定した後にその値を参照できないようにすると、セキュリティが確保されないためです。また、読み取りアクセスがないと、共有オブジェクトのステータスを参照できないため、実用性が制限されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageAddGetter">
        <source>Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method.</source>
        <target state="translated">プロパティ {0} は書き込み専用であるため、アクセシビリティがプロパティ セッター以上のプロパティ ゲッターを追加するか、このプロパティをメソッドに変換してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible">
        <source>Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter.</source>
        <target state="translated">{0} のプロパティ ゲッターがプロパティ セッターよりも参照範囲が小さいため、ゲッターのアクセシビリティを上げるか、セッターのアクセシビリティを下げてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesTitle">
        <source>Declare types in namespaces</source>
        <target state="translated">名前空間で型を宣言します</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesDescription">
        <source>Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</source>
        <target state="translated">型を名前空間内で宣言するのは、名前の競合を防ぎ、関連する型をオブジェクト階層で編成するためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesMessage">
        <source>Declare types in namespaces</source>
        <target state="translated">名前空間で型を宣言します</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsTitle">
        <source>Do not declare visible instance fields</source>
        <target state="translated">参照可能なインスタンス フィールドを宣言しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsDescription">
        <source>The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.</source>
        <target state="translated">フィールドの主な用途は、実装の詳細を示すことです。フィールドは private または internal に設定し、プロパティを使用して公開する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsMessage">
        <source>Do not declare visible instance fields</source>
        <target state="translated">参照可能なインスタンス フィールドを宣言しません</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsTitle">
        <source>Uri parameters should not be strings</source>
        <target state="translated">URI パラメーターを文字列にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsDescription">
        <source>If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</source>
        <target state="translated">メソッドで URI の文字列表現を使用する場合、URI クラスのインスタンスを取得する、対応するオーバーロードを指定する必要があります。これにより、安全な方法でこれらのサービスが提供されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsMessage">
        <source>Change the type of parameter {0} of method {1} from string to System.Uri, or provide an overload to {1} that allows {0} to be passed as a System.Uri object.</source>
        <target state="translated">メソッド {1} のパラメーター {0} の型を文字列から System.Uri に変更するか、または {1} のオーバーロードを指定してください。そうすると、{0} を System.Uri オブジェクトとして渡すことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsTitle">
        <source>Uri return values should not be strings</source>
        <target state="translated">URI 戻り値を文字列にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsDescription">
        <source>This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">この規則では、メソッドから URI が返されることを前提としています。URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。System.Uri クラスを使用すると、安全な方法でこれらのサービスが提供されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsMessage">
        <source>Change the return type of method {0} from string to System.Uri.</source>
        <target state="translated">メソッド {0} の戻り値の型を文字列から System.Uri に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsTitle">
        <source>Uri properties should not be strings</source>
        <target state="translated">URI プロパティを文字列にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsDescription">
        <source>This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">この規則では、プロパティが Uniform Resource Identifier (URI) を表すことを前提としています。URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。System.Uri クラスを使用すると、安全な方法でこれらのサービスが提供されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsMessage">
        <source>Change the type of property {0} from string to System.Uri.</source>
        <target state="translated">プロパティ {0} の型を文字列から System.Uri に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyTitle">
        <source>Implement IDisposable Correctly</source>
        <target state="translated">IDisposable を正しく実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyDescription">
        <source>All IDisposable types should implement the Dispose pattern correctly.</source>
        <target state="translated">すべての IDisposable 型は、Dispose パターンを正しく実装しなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageIDisposableReimplementation">
        <source>Remove IDisposable from the list of interfaces implemented by '{0}' as it is already implemented by base type '{1}'.</source>
        <target state="translated">'{0}' によって実行されたインターフェイスの一覧から IDisposable を削除します。基本型 '{1}' によって既に実装されているためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeOverride">
        <source>Remove '{0}', override Dispose(bool disposing), and put the dispose logic in the code path where 'disposing' is true.</source>
        <target state="translated">'{0}' を削除し、Dispose(bool disposing) をオーバーライドします。その後、'disposing' が true のコード パスで dispose 論理を配置します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeSignature">
        <source>Ensure that '{0}' is declared as public and sealed.</source>
        <target state="translated">'{0}' が public および sealed.として宣言されていることを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageRenameDispose">
        <source>Rename '{0}' to 'Dispose' and ensure that it is declared as public and sealed.</source>
        <target state="translated">名前を '{0}' から 'Dispose' に変更し、public および sealed として宣言されていることを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeBoolSignature">
        <source>Ensure that '{0}' is declared as protected, virtual, and unsealed.</source>
        <target state="translated">'{0}' が protected、virtual、unsealed として宣言されていることを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeImplementation">
        <source>Modify '{0}' so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance ('this' or 'Me' in Visual Basic), and then returns.</source>
        <target state="translated">'{0}' を変更し、Dispose(true) を呼び出したのちに現在のオブジェクト インスタンスで GC.SuppressFinalize (Visual Basic の 'this' または 'Me') を呼び出して、結果を戻すようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeImplementation">
        <source>Modify '{0}' so that it calls Dispose(false) and then returns.</source>
        <target state="translated">'{0}' を変更し、Dispose(false) を呼び出して結果を返すようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageProvideDisposeBool">
        <source>Provide an overridable implementation of Dispose(bool) on '{0}' or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources.</source>
        <target state="translated">'{0}' で Dispose(bool) のオーバーライド可能な実装を提供するか、型を sealed としてマークします。Dispose(false) を呼び出す場合は、ネイティブ リソースのみがクリーンアップされます。Dispose(true) を呼び出す場合には、マネージド リソースとネイティブ リソースの両方がクリーンアップされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicTitle">
        <source>Exceptions should be public</source>
        <target state="translated">例外は public として設定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicDescription">
        <source>An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.</source>
        <target state="translated">内部例外を参照できるのは、それ独自の内部スコープ内でのみです。例外が内部スコープ外にあると、基本例外を使用しなければキャッチできません。内部例外が System.Exception、System.SystemException、または System.ApplicationException から継承されている場合、外部コードはその例外の処理に関する十分な情報を取得できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicMessage">
        <source>Exceptions should be public</source>
        <target state="translated">例外は public として設定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsTitle">
        <source>Do not raise exceptions in unexpected locations</source>
        <target state="translated">予期しない場所に例外を発生させません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsDescription">
        <source>A method that is not expected to throw exceptions throws an exception.</source>
        <target state="translated">例外をスローすることが想定されていないメソッドが例外をスローします。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property's logic so that it no longer raises an exception.</source>
        <target state="translated">{0} は型 {1} の例外を作成します。これは、プロパティで発生させることができない例外の種類です。この例外インスタンスが発生する可能性がある場合は、別の例外の種類を使用するか、このプロパティをメソッドに変換するか、例外が発生しないようにこのプロパティのロジックを変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method's logic so that it no longer raises an exception.</source>
        <target state="translated">{0} は型 {1} の例外を作成します。これは、この型のメソッドで発生させることができない例外の種類です。この例外インスタンスが発生する可能性がある場合は、別の例外の種類を使用するか、例外が発生しないようにこのメソッドのロジックを変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions">
        <source>{0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method's logic so it no longer raises an exception.</source>
        <target state="translated">{0} は型 {1} の例外を作成します。この型のメソッドでは例外を発生させることはできません。この例外インスタンスが発生する可能性がある場合は、例外が発生しないようにこのメソッドのロジックを変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresTitle">
        <source>Identifiers should not contain underscores</source>
        <target state="translated">識別子はアンダースコアを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresDescription">
        <source>By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.</source>
        <target state="translated">規則により、識別子名にアンダースコア (_) 文字を含めることができません。この規則では名前空間、型、メンバー、およびパラメーターをチェックします。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageAssembly">
        <source>Remove the underscores from assembly name {0}.</source>
        <target state="translated">アンダースコアをアセンブリ名 {0} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageNamespace">
        <source>Remove the underscores from namespace name '{0}'.</source>
        <target state="translated">アンダースコアを名前空間 '{0}' から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageType">
        <source>Remove the underscores from type name {0}.</source>
        <target state="translated">アンダースコアを型名 {0} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMember">
        <source>Remove the underscores from member name {0}.</source>
        <target state="translated">アンダースコアをメンバー名 {0} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter">
        <source>On type {0}, remove the underscores from generic type parameter name {1}.</source>
        <target state="translated">型 {0} で、アンダースコアをジェネリック型パラメーター名 {1} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter">
        <source>On method {0}, remove the underscores from generic type parameter name {1}.</source>
        <target state="translated">メソッド {0} で、アンダースコアをジェネリック型パラメーター名 {1} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMemberParameter">
        <source>In member {0}, remove the underscores from parameter name {1}.</source>
        <target state="translated">メンバー {0} で、アンダースコアをパラメーター名 {1} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageDelegateParameter">
        <source>In delegate {0}, remove the underscores from parameter name {1}.</source>
        <target state="translated">デリゲート {0} で、アンダースコアをパラメーター名 {1} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixTitle">
        <source>Identifiers should have correct suffix</source>
        <target state="translated">識別子は、正しいサフィックスを含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixDescription">
        <source>By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</source>
        <target state="translated">規則によると、特定の基本型を拡張する型、特定のインターフェイスを実装する型、またはそのような型から派生した型の名前には、基本型またはインターフェイスに関連付けられているサフィックスが付きます。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageDefault">
        <source>Rename {0} to end in '{1}'.</source>
        <target state="translated">{0} の名前が '{1}' で終わるように変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageSpecialCollection">
        <source>Rename {0} to end in either 'Collection' or '{1}'.</source>
        <target state="translated">{0} の名前が 'Collection' または '{1}' で終わるように変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixTitle">
        <source>Identifiers should not have incorrect suffix</source>
        <target state="translated">識別子は、不適切なサフィックスを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixDescription">
        <source>By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.</source>
        <target state="translated">規則によると、特定の基本型を拡張する型、特定のインターフェイスを実装する型、またはそのような型から派生した型の名前のみ、末尾に特定の予約済みサフィックスが付きます。その他の型名では、これらの予約済みサフィックスを使用しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate">
        <source>Rename type name {0} so that it does not end in '{1}'.</source>
        <target state="translated">型名 '{0}' が '{1}' で終わらないように変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion">
        <source>Either replace the suffix '{0}' in member name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the member it replaces.</source>
        <target state="translated">メンバー名 '{1}' のサフィックス '{0}' を推奨される数値 '2' で置き換えるか、意味のあるサフィックスを指定して置き換えるメンバーと区別してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion">
        <source>Either replace the suffix '{0}' in type name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the type it replaces.</source>
        <target state="translated">型名 '{1}' のサフィックス '{0}' を推奨される数値 '2' で置き換えるか、意味のあるサフィックスを指定して置き換える型と区別してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate">
        <source>Either replace the suffix '{0}' in member name '{1}' with the suggested alternate '{2}' or remove the suffix completely.</source>
        <target state="translated">メンバー名 '{1}' のサフィックス '{0}' を推奨される '{2}' で置き換えるか、サフィックスをすべて削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesTitle">
        <source>Flags enums should have plural names</source>
        <target state="translated">フラグ列挙型は、複数形の名前を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesDescription">
        <source>A public enumeration has the System.FlagsAttribute attribute, and its name does not end in ""s"". Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified.</source>
        <target state="translated">パブリック列挙型に System.FlagsAttribute 属性があり、その名前の末尾に ""s"" がありません。FlagsAttribute を使用してマークされた型には複数形の名前が付きます。これは、この属性に複数の値を指定できることを示すためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesMessage">
        <source>Flags enums should have plural names</source>
        <target state="translated">フラグ列挙型は、複数形の名前を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsTitle">
        <source>Identifiers should not match keywords</source>
        <target state="translated">識別子はキーワードと同一にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsDescription">
        <source>A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</source>
        <target state="translated">名前空間名または型名が、プログラミング言語の予約済みのキーワードと一致します。名前空間と型の識別子は、共通言語ランタイムを対象とする言語で定義されているキーワードと一致しないようにする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMemberParameter">
        <source>In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword '{2}'. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">仮想メンバーまたはインターフェイス メンバー {0} のパラメーター {1} の名前を変更して、予約されている言語キーワード '{2}' と競合しないようにしてください。仮想メンバーまたはインターフェイス メンバーのパラメーター名として、予約されているキーワードを使用すると、他の言語を使用するユーザーがそのメンバーをオーバーライドまたは実装することが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMember">
        <source>Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">仮想メンバーまたはインターフェイス メンバー {0} の名前を変更して、予約されている言語キーワード '{1}' と競合しないようにしてください。仮想メンバーまたはインターフェイス メンバーの名前として、予約されているキーワードを使用すると、他の言語を使用するユーザーがそのメンバーをオーバーライドまたは実装することが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageType">
        <source>Rename type {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type.</source>
        <target state="translated">型 {0} の名前を変更して、予約されている言語キーワード '{1}' と競合しないようにしてください。型の名前として、予約されているキーワードを使用すると、他の言語を使用するユーザーがその型を使用することが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageNamespace">
        <source>Rename namespace {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace.</source>
        <target state="translated">名前空間 {0} の名前を変更して、予約されている言語キーワード '{1}' と競合しないようにしてください。名前空間の名前として、予約されているキーワードを使用すると、他の言語を使用するユーザーがその名前空間を使用することが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesTitle">
        <source>Only FlagsAttribute enums should have plural names</source>
        <target state="translated">FlagsAttribute 列挙型のみが複数形の名前を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesDescription">
        <source>Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time.</source>
        <target state="translated">名前付け規則では、列挙型の複数形の名前は同時に複数の列挙型を指定できることを意味します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesMessage">
        <source>Only FlagsAttribute enums should have plural names</source>
        <target state="translated">FlagsAttribute 列挙型のみが複数形の名前を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsTitle">
        <source>Property names should not match get methods</source>
        <target state="translated">プロパティ名は get メソッドと同一にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsDescription">
        <source>The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.</source>
        <target state="translated">パブリック メンバーまたは保護されたメンバーの名前が、""Get"" から始まっているか、パブリック プロパティまたは保護されたプロパティの名前と一致します。""Get"" メソッドおよびプロパティには、その機能を明確に区別する名前が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsMessage">
        <source>The property name '{0}' is confusing given the existence of method '{1}'. Rename or remove one of these members.</source>
        <target state="translated">メソッド '{1}' の存在が指定されているため、プロパティ名 '{0}' は混乱を招きます。これらのメンバーの 1 つの名前を変更するか、削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesTitle">
        <source>Type names should not match namespaces</source>
        <target state="translated">型名は名前空間と同一にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesDescription">
        <source>Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.</source>
        <target state="translated">型名は、.NET Framework クラス ライブラリで定義されている名前空間の名前と一致しないようにする必要があります。この規則に違反すると、ライブラリが使いにくくなります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageDefault">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}'. Change either name to eliminate the conflict.</source>
        <target state="translated">型名 {0} は、名前空間の名前 '{1}' と全体または部分的に競合します。競合を解消するには、どちらかの名前を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageSystem">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}' defined in the .NET Framework. Rename the type to eliminate the conflict.</source>
        <target state="translated">型名 {0} は、.NET Framework で定義されている名前空間の名前 '{1}' と全体または部分的に競合します。競合を解消するには、型名を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationTitle">
        <source>Parameter names should match base declaration</source>
        <target state="translated">パラメーター名は基本宣言と同一でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationDescription">
        <source>Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</source>
        <target state="translated">オーバーライド階層でのパラメーターに対する一貫した名前付けにより、メソッド オーバーライドの使いやすさが向上します。派生メソッドのパラメーター名が基本宣言のパラメーター名と異なると、メソッドが基本メソッドのオーバーライドかメソッドの新しいオーバーロードかに関して混乱が生じる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationMessage">
        <source>In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}.</source>
        <target state="translated">{3} で宣言されている識別子と一致するように、メンバー {0} のパラメーター名 {1} を {2} に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsTitle">
        <source>Use preferred terms</source>
        <target state="translated">適切な用語を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsDescription">
        <source>The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the term ""Flag"" or ""Flags"".</source>
        <target state="translated">外部から参照可能な識別子の名前には、代わりとなる適切な用語が存在する用語が含まれています。または、名前に ""Flag"" または ""Flags"" という語が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageAssembly">
        <source>Replace the term '{0}' in assembly name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">アセンブリ名 {1} の用語 '{0}' を適切な用語 '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageNamespace">
        <source>Replace the term '{0}' in namespace name '{1}' with the preferred alternate '{2}'.</source>
        <target state="translated">名前空間の名前 '{1}' の用語 '{0}' を適切な用語 '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberParameter">
        <source>In member {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">メンバー {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語 '{3}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageDelegateParameter">
        <source>In delegate {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">デリゲート {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語 '{3}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeTypeParameter">
        <source>On type {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">型 {0} で、ジェネリック型パラメーター名 {2} の用語 '{1}' を適切な用語 '{3}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMethodTypeParameter">
        <source>On method {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">メソッド {0} で、ジェネリック型パラメーター名 {2} の用語 '{1}' を適切な用語 '{3}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageType">
        <source>Replace the term '{0}' in type name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">型名 {1} の用語 '{0}' を適切な用語 '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMember">
        <source>Replace the term '{0}' in member name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">メンバー名 {1} の用語 '{0}' を適切な用語 '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageAssemblyNoAlternate">
        <source>Replace the term '{0}' in assembly name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">アセンブリ名 {1} の用語 '{0}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageNamespaceNoAlternate">
        <source>Replace the term '{0}' in namespace name '{1}' with an appropriate alternate or remove it entirely.</source>
        <target state="translated">名前空間の名前 '{1}' の用語 '{0}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberParameterNoAlternate">
        <source>In member {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">メンバー {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageDelegateParameterNoAlternate">
        <source>In delegate {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">デリゲート {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeTypeParameterNoAlternate">
        <source>On type {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">型 {0} で、ジェネリック型パラメーター名 {2} の用語 '{1}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMethodTypeParameterNoAlternate">
        <source>On method {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">メソッド {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeNoAlternate">
        <source>Replace the term '{0}' in type name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">型名 {1} の用語 '{0}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberNoAlternate">
        <source>Replace the term '{0}' in member name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">メンバー名 {1} の用語 '{0}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesTitle">
        <source>Override equals and operator equals on value types</source>
        <target state="translated">equals および operator equals を値型でオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesDescription">
        <source>For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</source>
        <target state="translated">値型の場合、Equals を継承した実装が Reflection ライブラリを使用して、すべてのフィールドの内容を比較します。Reflection は計算コストが高いため、場合によってはすべてのフィールドで等値性を比較する必要はありません。ユーザーがインスタンスの比較または並べ替えを行うことや、ハッシュ テーブル キーとしてインスタンスを使用することが予想される場合には、値型に Equals を実装する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals">
        <source>{0} should override Equals.</source>
        <target state="translated">{0} は Equals をオーバーライドしなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality">
        <source>{0} should override the equality (==) and inequality (!=) operators.</source>
        <target state="translated">{0} は、等値演算子 (==) および非等値演算子 (!=) をオーバーライドしなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysTitle">
        <source>Properties should not return arrays</source>
        <target state="translated">プロパティは配列を返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysDescription">
        <source>Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.</source>
        <target state="translated">プロパティが読み取り専用であっても、プロパティで返される配列は書き込み禁止ではありません。配列の改ざんを防ぐには、プロパティで配列のコピーを返す必要があります。一般に、このようなプロパティを呼び出すときのパフォーマンス低下は理解されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysMessage">
        <source>Properties should not return arrays</source>
        <target state="translated">プロパティは配列を返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesTitle">
        <source>Assemblies should have valid strong names</source>
        <target state="translated">アセンブリには有効な厳密な名前が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesDescription">
        <source>The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her computer.</source>
        <target state="translated">厳密な名前によって、改ざんされたアセンブリをクライアントが知らないうちに読み込むことを防ぐことができます。厳密な名前のないアセンブリが配置される状況は限定されます。適切に署名されていないアセンブリを共有または配布すると、アセンブリが改ざんされたり、共通言語ランタイムでアセンブリが読み込まれなくなったりする可能性があるほか、ユーザーは自身のコンピューターで検証を無効にすることが必要になる場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesMessageNoStrongName">
        <source>Sign {0} with a strong name key.</source>
        <target state="translated">{0} を厳密な名前キーで署名します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesMessageNotValid">
        <source>Verify that {0} has a valid strong name before deploying.</source>
        <target state="translated">配置する前に、{0} に有効な厳密な名前が指定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsTitle">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">オーバーライドする Equals で GetHashCode をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsDescription">
        <source>GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code.</source>
        <target state="translated">GetHashCode は、現在のインスタンスに基づいて、ハッシュ アルゴリズムとデータ構造 (ハッシュ テーブルなど) に適した値を返します。同じ型で等しい 2 つのオブジェクトは、同じハッシュ コードを返す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsMessage">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">オーバーライドする Equals で GetHashCode をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsTitle">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">オーバーロードする演算子 equals で Equals をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsDescription">
        <source>A public type implements the equality operator but does not override Object.Equals.</source>
        <target state="translated">パブリック型では等値演算子が実装されますが、Object.Equals はオーバーライドされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsMessage">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">オーバーロードする演算子 equals で Equals をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="Since_0_redefines_operator_1_it_should_also_redefine_operator_2">
        <source>Since '{0}' redefines operator '{1}', it should also redefine operator '{2}'</source>
        <target state="translated">'{0}' は演算子 '{1}' を再定義するため、演算子 '{2}' も再定義しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_missing_operators">
        <source>Generate missing operators</source>
        <target state="translated">不足している演算子を生成します</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">object.Equals をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnImplementingIEquatableCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">object.Equals をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsCodeActionTitle">
        <source>Override object.GetHashCode</source>
        <target state="translated">object.GetHashCode をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeExceptionPublic">
        <source>Make exception public</source>
        <target state="translated">例外を public に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix1">
        <source>Make '{0}' protected.</source>
        <target state="translated">'{0}' を protected に設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix2">
        <source>Change '{0}' to a public interface implementation.</source>
        <target state="translated">'{0}' をパブリック インターフェイスの実装に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix3">
        <source>Make the containing type '{0}' sealed.</source>
        <target state="translated">含んでいる型 '{0}' をシールドに設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypeIsNotStatic">
        <source>Type '{0}' is a static holder type but is neither static nor NotInheritable</source>
        <target state="translated">型 '{0}' はスタティック ホルダー型ですが、static でも NotInheritable でもありません</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypesShouldBeStaticOrNotInheritable">
        <source>Static holder types should be Static or NotInheritable</source>
        <target state="translated">スタティック ホルダー型は Static または NotInheritable でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeClassStatic">
        <source>Make Class Static</source>
        <target state="translated">クラスを静的にします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsMessage">
        <source>Type {0} should override Equals because it implements IEquatable&lt;T&gt;</source>
        <target state="translated">型 {0} は IEquatable&lt;T&gt; を実装するため、Equals をオーバーライドする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsTitle">
        <source>Override Object.Equals(object) when implementing IEquatable&lt;T&gt;</source>
        <target state="translated">IEquatable&lt;T&gt; を実装するときに Object.Equals(object) をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersDescription">
        <source>Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.</source>
        <target state="translated">インデクサー (インデックス付きのプロパティ) は、インデックスに整数型または文字列型を使用する必要があります。一般に、これらの型は、データ構造のインデックス作成に使用されます。また、ライブラリの操作感が改善されます。Object 型の使用は、デザイン時に特定の整数型または文字列型を指定できない場合に限定してください。デザインによってインデックスに他の型が必要な場合は、該当する型が論理的なデータ ストアを表しているかどうかを再検討してください。論理的なデータ ストアを表していない場合、メソッドを使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersMessage">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">インデクサーには整数または文字列引数を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersTitle">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">インデクサーには整数または文字列引数を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskDescription">
        <source>When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.</source>
        <target state="translated">非同期メソッドがタスクを直接待機すると、タスクを作成したのと同じスレッドで継続が発生します。継続の意図を示すには、Task.ConfigureAwait(Boolean) の呼び出しを検討してください。タスクで ConfigureAwait(false) を呼び出して、スレッド プールへの継続をスケジュールします。その結果、UI スレッドのデッドロックを回避できます。アプリに依存しないライブラリでは、false を渡すことが適切なオプションです。タスクで ConfigureAwait(true) を呼び出すと、ConfigureAwait を明示的に呼び出さない場合と動作が同じになります。このメソッドを明示的に呼び出すことにより、元の同期コンテキストで意図的に継続を実行していることを閲覧者に示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskMessage">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">待機中のタスクでの ConfigureAwait の呼び出しを検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskTitle">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">待機中のタスクでの ConfigureAwait の呼び出しを検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="AppendConfigureAwaitFalse">
        <source>Append .ConfigureAwait(false)</source>
        <target state="translated">.ConfigureAwait(false) を追加します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsDescription">
        <source>When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.</source>
        <target state="translated">型 T が Object.Equals(object) をオーバーライドする場合、この実装は、比較を行う前にオブジェクトの引数を正しい型 T にキャストする必要があります。型が IEquatable&lt;T&gt; を実装してメソッド T.Equals(T) を提供する場合、およびコンパイル時に引数が型 T であることがわかっている場合、コンパイラは Object.Equals(object) の代わりに IEquatable&lt;T&gt;.Equals(T) を呼び出すことができ、キャストは必要ではなくなるため、パフォーマンスが向上します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsDescription">
        <source>When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".</source>
        <target state="translated">型 T がインターフェイスの IEquatable&lt;T&gt; を実装することは、ソース コード内の Equals メソッドへの呼び出しを見るユーザーにとって、型のインスタンスを他の任意の型のインスタンスと結びつけることができることを意味しています。ユーザーが型を他の型のインスタンスに結びつけようとしてコンパイルが失敗すると、ユーザーは混乱する可能性があります。これは、「驚き最小の原則」に違反しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="RenameToTitle">
        <source>Rename to '{0}'</source>
        <target state="translated">名前を '{0}' に変更する</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsDescription">
        <source>A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</source>
        <target state="translated">派生メソッドのパラメーター シグネチャ内のある型が、基本メソッドのパラメーター シグネチャ内のそれに対応する型より弱く型指定されていることが、両者の唯一の相違点である場合、基本型内のメソッドが派生型内の同じ名前のメソッドによって隠されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsMessage">
        <source>Change or remove '{0}' because it hides a more specific base class method: '{1}'.</source>
        <target state="translated">より特定の基底クラス メソッドを隠しているため、'{0}' を変更または削除してください: '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsTitle">
        <source>Do not hide base class methods</source>
        <target state="translated">基底クラス メソッドを非表示にしません</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateMessage">
        <source>Remove '{0}' and replace its usage with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">'{0}' を削除して、それを EventHandler&lt;T&gt; (T は有効な EventArgs) などのジェネリックの EventHandler と置き換えます</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateDescription">
        <source>A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">型に void を返すデリゲートが含まれており、デリゲートのシグネチャに 2 つのパラメーター (1 つはオブジェクト、もう 1 つは EventArgs に割り当て可能な型) が含まれ、包含アセンブリの対象が .NET Framework 2.0 です。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventMessage">
        <source>Change the event '{0}' to replace the type '{1}' with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">イベント '{0}' を変更して、型 '{1}' を EventHandler&lt;T&gt; (T は有効な EventArgs) などのジェネリックの EventHandler と置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventDescription">
        <source>A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.</source>
        <target state="translated">公開イベントまたは保護されたイベントを処理するデリゲートに正しいシグネチャがないか、型またはパラメーター名を返します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Message">
        <source>Change the event '{0}' to use a generic EventHandler by defining the event type explicitly, for e.g. Event MyEvent As EventHandler(Of MyEventArgs).</source>
        <target state="translated">汎用 EventHandler を使用するために、イベント型を明示的に定義して、イベント '{0}' を変更します。例: Event MyEvent As EventHandler(Of MyEventArgs)</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Description">
        <source>A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">型に void を返す EventHandler デリゲートを宣言するイベントが含まれており、デリゲートのシグネチャに 2 つのパラメーター (1 つはオブジェクト、もう 1 つは EventArgs に割り当て可能な型) が含まれ、包含アセンブリの対象が .NET Framework 2.0 です。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageBoth">
        <source>{0} should define operator(s) '{1}' and Equals since it implements IComparable.</source>
        <target state="translated">{0} は、IComparable を実装しているため、演算子 '{1}' と Equals を定義しなければなりません。</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsTitle">
        <source>Avoid calling problematic methods</source>
        <target state="translated">問題が発生する可能性のあるメソッドは呼び出しません</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsDescription">
        <source>A member calls a potentially dangerous or problematic method.</source>
        <target state="translated">メンバーが危険性または問題のあるメソッドを呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemGCCollect">
        <source>Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</source>
        <target state="translated">GC.Collect への呼び出しを {0} から削除します。通常、ガベージ コレクションを強制する必要はありません。ガベージ コレクションを行うと、パフォーマンスが大幅に低下する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume">
        <source>Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Thread.Resume への呼び出しを {0} から削除します。重要なシステム型のクラス コンストラクターを実行中である、または共有アセンブリのセキュリティを解決中であるなどの重大な操作をシステムが実行している場合、スレッドの中断および再開には危険性が伴います。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend">
        <source>Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Thread.Suspend への呼び出しを {0} から削除します。重要なシステム型のクラス コンストラクターを実行中である、または共有アセンブリのセキュリティを解決中であるなどの重大な操作をシステムが実行している場合、スレッドの中断および再開には危険性が伴います。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember">
        <source>Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</source>
        <target state="translated">BindingFlags.NonPublic を伴う System.Type.InvokeMember への呼び出しを {0} から削除します。プライベート メンバーの依存関係を取得すると、今後のコードに対する重大な変更が発生する可能性を高めます。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoInitializeSecurity">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</source>
        <target state="translated">{0} は、ランタイムが初期化された後に正しく呼び出すことができない OLE32 API への P/Invoke 宣言です。次善策としては、そのルーチンを呼び出してからマネージ コードをアクティブ化し、そのマネージ コードに呼び出しを行うアンマネージ shim を書き込むことです。COM によって使用するためにマネージ コンポーネントを登録することによって、またはランタイムをホストする API を使用することによって、混合モードの C++ DLL からのエクスポートを使用してこの動作を行うことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoSetProxyBlanket">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</source>
        <target state="translated">{0} は、ランタイム呼び出しラッパー (COM オブジェクトをラップするマネージ オブジェクト) に対して正しく呼び出すことができない OLE32 API への P/Invoke 宣言です。ランタイム呼び出しラッパーはインターフェイス ポインターを動的に取得するため、呼び出しの結果は任意に失われます。特定の COM オブジェクトの呼び出しラッパーがアプリケーション ドメインで共有されることもあるため、呼び出しが他のユーザーに影響する可能性もあります。この呼び出しを、適切な CoSetProxyBlanket 呼び出しを行う、インターフェイス ポインターのネイティブ ラッパー COM オブジェクトで置き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle">
        <source>Remove the call to SafeHandle.DangerousGetHandle from {0}.</source>
        <target state="translated">SafeHandle.DangerousGetHandle への呼び出しを {0} から削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom">
        <source>Remove the call to Assembly.LoadFrom from {0}.</source>
        <target state="translated">Assembly.LoadFrom への呼び出しを {0} から削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile">
        <source>Remove the call to Assembly.LoadFile from {0}.</source>
        <target state="translated">Assembly.LoadFile への呼び出しを {0} から削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName">
        <source>Remove the call to Assembly.LoadWithPartialName from {0}.</source>
        <target state="translated">Assembly.LoadWithPartialName への呼び出しを {0} から削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="translated">信頼性</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixTitle">
        <source>Avoid using cref tags with a prefix</source>
        <target state="translated">cref タグをプレフィックスと共に使用しない</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixDescription">
        <source>Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax.</source>
        <target state="translated">cref タグをプレフィックスと共に使用しないでください。リファクタリング中に、コンパイラが参照を検証したり、IDE が参照を更新したりできなくなります。指定されている型をコンパイラが検出できないことが原因で cref でプレフィックスを使用する必要がある場合は、単一のドキュメント サイトでこのエラーを抑制することは許容されます。たとえば、cref に完全なフレームワークの特殊な属性を指定している一方で、移植可能なフレームワークを対象にコンパイルするファイルを使用している場合や、Roslyn の上位レイヤーの型を参照する場合は、このエラーが表示されないようにする必要があります。完全な構文の使用を避けて手軽な方法を使用したいというだけの理由でこのエラーが表示されないようにしないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixMessage">
        <source>Avoid using cref tags with a prefix</source>
        <target state="translated">cref タグをプレフィックスと共に使用しない</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">'{0}' は常に '{1}' です。実行されないコードを回避するには、条件を削除するかリファクターします。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">'{0}' は '{1}' ではありません。実行されないコードを回避するには、条件を削除するかリファクターします。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="translated">使用されない条件付きコードを回避する</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">このルールは、シンボルが含まれる一意の型参照の数をカウントすることによってクラス結合度を測定します。クラス結合度の高いシンボルは保守が困難になることがあります。低い結合度と高い凝集度を指定する型とメソッドを含めることをお勧めします。この違反を修正するには、コードを書き直し、結合する型の数を減らします。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">'{0}' は、異なる名前空間 '{2}' の中の異なる型 '{1}' と結合しています。コードを書き直すかリファクタリングを行って、'{3}' の下のクラス間結合を小さくしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">過剰なクラス結合を避ける</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">サイクロマティック複雑度は、メソッドにより線形的に独立したパスの数を測定します。これは、条件分岐の数と複雑さによって決定されます。低いサイクロマティック複雑度は一般的に、メソッドの理解、テスト、維持が容易であることを示しています。サイクロマティック複雑度は、メソッドの制御フロー グラフから計算され、次のように表されます。`サイクロマティック複雑度 = エッジの数 - ノードの数 + 1`。ここでノードはロジック ブランチ ポイントを表しており、エッジはノード間のラインを表しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">'{0}' のサイクロマティック複雑度は '{1}' です。コードを書き換えるか、リファクタリングし、複雑度を '{2}' 未満に緩和します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">複雑にしすぎない</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">入れ子の深度が深い型階層はフォロー、理解、保守が難しくなることがあります。このルールは、同じモジュールの階層にのみ分析対象を制限します。このルール違反を修正するには、継承階層にある深度の深くない基本型から型を派生させるか、一部の中間基本型を削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="translated">'{0}' の定義モジュールには深さが '{1}' のオブジェクト階層レベルが含まれています。可能な場合には、階層レベルを '{2}' 未満になるよう階層内の基本クラスを減らしてください: '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">継承を使用しすぎない</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">保守容易性指数は、メトリックスとして、コード行、プログラム ボリューム、サイクロマティック複雑度を使用して計算されます。プログラム ボリュームは、コード内の演算子やオペランドの数に基づく、シンボルを理解する難しさの度合いです。サイクロマティック複雑度は、型またはメソッドの構造的な複雑さの度合いです。保守容易性指数が低いと、コードの保守が難しい可能性が高く、再設計の候補になり得ることを示しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">'{0}' の保守容易性指数は '{1}' です。コードを書き直すかリファクタリングを行い、保守容易性指数 (MI) が '{2}' より大きくなるようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">メンテナンスできないコードを使用しない</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">コード メトリック ルール仕様ファイル内のエントリが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">コード メトリック ルール仕様ファイル '{1}' のエントリ '{0}' が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">コード メトリック ルール仕様ファイル内のエントリが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="translated">変数名はフィールド名と同一にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="translated">インスタンス メソッドで、宣言する型のインスタンス フィールドと名前が一致するパラメーターまたはローカル変数を宣言すると、エラーの原因となります。</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{1} で宣言された変数 {0} には、型のインスタンス フィールドと同じ名前が指定されています。これらの項目のうちの 1 つの名前を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{1} で宣言されたパラメーター {0} には、型のインスタンス フィールドと同じ名前が指定されています。これらの項目のうちの 1 つの名前を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="translated">使用されていないパラメーターの確認</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>Avoid unused paramereters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</source>
        <target state="translated">コード内に使用されないパラメーターを指定しないでください。パラメーターを削除できない場合は、パラメーターの名前をアンダースコアの後にオプションで整数が続く名前 ('_'、'_1'、'_2' など) に変更してください。これらは、特別なディスカード シンボル名として扱われます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="translated">{1} のパラメーター {0} は使用されていません。パラメーターを削除するか、メソッド本体で使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="translated">使用されていないパラメーターの削除</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">メソッドの結果を無視しない</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">新しいオブジェクトが作成されても使用されていないか、新しい文字列を作成して返すメソッドが呼び出されても新しい文字列が使用されていないか、COM メソッドまたは P/Invoke メソッドから返された HRESULT またはエラー コードが使用されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">{0} では使用されない {1} の新しいインスタンスが作成されます。インスタンスを引数として他のメソッドに渡すか、インスタンスを変数に割り当てるか、不要な場合はオブジェクト作成を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">{0} は {1} を呼び出しますが、メソッドから返される新しい文字列インスタンスは使用されません。インスタンスを引数として他のメソッドに渡すか、インスタンスを変数に割り当てるか、不要な場合は呼び出しを削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} は {1} を呼び出しますが、メソッドから返される HRESULT またはエラー コードは使用されません。このため、エラー条件での予期しない動作やリソース不足が発生する可能性があります。条件ステートメントで結果を使用するか、結果を変数に割り当てるか、引数として他のメソッドに渡してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">{0} は {1} を呼び出しますが、変換が成功したかどうかを明示的に確認しません。戻り値を条件ステートメントで使用するか、または、変換が失敗した場合に out 引数が既定値に設定されることを呼び出しサイトで想定するようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">インスタンス化されていない内部クラスを使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">アセンブリレベルの型のインスタンスが、アセンブリ内のコードから作成されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="translated">{0} は、インスタンス化されていない内部クラスです。その場合、コードをアセンブリから削除してください。このクラスが静的メンバーのみを含むことを意図している場合は、このクラスを static (Visual Basic の場合は Shared) にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">使用されていないプライベート フィールドを使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">アセンブリ内でアクセスされていないと思われるプライベート フィールドが検出されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="translated">未使用のフィールド '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} は {1} を呼び出しますが、メソッドから返される値は使用されません。{1} は Pure メソッドとしてマークされているため、副作用は発生しません。条件ステートメントで結果を使用するか、結果を変数に割り当てるか、引数として他のメソッドに渡してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">nameof を使用するとリファクタリング時にコードを有効な状態に保つ上で役立ちます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">文字列リテラル '{0}' の代わりに nameof を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">nameof を使用してシンボル名を表現します</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself.</source>
        <target state="translated">プロパティ {0} をそれ自体に割り当てることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself.</source>
        <target state="translated">プロパティをそれ自体に割り当てないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">静的にする</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">'{0}' への参照を修正できませんでした。手動で修正する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">適切な場所にリテラルを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="translated">フィールドが static および read-only (Visual Basic では Shared および ReadOnly) として宣言され、コンパイル時に計算できる値によって初期化されています。対象フィールドに代入された値はコンパイル時に計算できるため、宣言を const (Visual Basic では Const) フィールドに変更して、値が実行時ではなくコンパイル時にコンピューティングされるようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">フィールド '{0}' は 'readonly' として宣言されていますが、定数値を指定して初期化されています。代わりに、このフィールドを 'const' として設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">フィールド '{0}' は 'readonly' として宣言されていますが、空の文字列 ("") を指定して初期化されています。代わりに、このフィールドを 'const' として設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">不必要に初期化しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="translated">共通言語ランタイムは、コンストラクターを実行する前にすべてのフィールドを既定値に初期化します。ほとんどの場合、コンストラクターでフィールドを既定値に初期化する処理は冗長です。これにより、パフォーマンスが低下し、保守コストが増加します。冗長でない 1 つの例として、コンストラクターが、同じクラスの別コンストラクターまたは基底クラスのコンストラクターを呼び出し、そのコンストラクターがフィールドを既定以外の値に初期化する場合があります。この場合、フィールドの値を変更して既定値に戻すのが適切なこともあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">不必要に初期化しません</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">複数次元の配列ではなくジャグ配列を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">ジャグ配列とは、その要素も配列である配列です。要素を構成する配列のサイズは異なる場合があるため、データ セットによっては無駄な空間が少なくなります。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} は多次元配列です。可能である場合、ジャグ配列で置き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} は {1} の多次元配列を返します。可能である場合、ジャグ配列で置き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} は {1} の多次元配列を使用します。可能である場合、ジャグ配列で置き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">メンバーを static に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static. After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">インスタンス データにアクセスしないメンバーまたはインスタンス メソッドを呼び出さないメンバーは、static にマークできます。メソッドを static にマークすると、コンパイラではこれらのメンバーに対する非仮想呼び出しサイトを出力します。これにより、パフォーマンスを要求されるコードでは、大幅にパフォーマンスが改善されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member '{0}' does not access instance data and can be marked as static</source>
        <target state="translated">メンバー '{0}' はインスタンス データにアクセスしないため、static にマークできます</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="translated">表示するイベント ハンドラーを確認します</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="translated">パブリックまたは保護されたイベント処理メソッドが検出されました。イベント処理メソッドは、どうしても必要な場合を除いて公開しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="translated">{0} の外部からの参照を不可能に設定することを検討するか、害のないコードであることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="translated">{0} の外部からの参照を不可能に設定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">プライベート インターフェイスを満たすメソッドをシールします</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">継承可能なパブリック型により、internal (Visual Basic では Friend) インターフェイスのオーバーライド可能なメソッド実装が提供されます。この規則の違反を修正するには、アセンブリの外側でメソッドがオーバーライドされないようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">プライベート インターフェイスを満たすメソッドをシールします</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">空のファイナライザーを削除します</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">オブジェクトの有効期間の追跡に関連するパフォーマンスの低下を避けるために、可能な場合は、ファイナライザーの使用を避けてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">コンストラクターのオーバーライド可能なメソッドを呼び出しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">クラスで定義された仮想メソッドはコンストラクターから呼び出すことができません。派生クラスがメソッドをオーバーライドした場合、派生クラス コンストラクターの前に、派生クラス バージョンが呼び出されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="translated">キャッチされた例外が再スローされると、スタック情報が変更されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="translated">スタック詳細を保持するために再スローします。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">宣言する型を internal に設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">宣言する型をシールドに設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">メンバーをオーバーライド不可能にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">finally 句で例外が発生すると、新しい例外によってアクティブな例外が隠れます。これにより、元のエラーの検出およびデバッグが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="translated">finally 句内から例外を発生させないでください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">finally 句で例外を発生させません</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">定数に変更します</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">オブジェクト初期化子のインデックス付き要素は、一意の要素を初期化する必要があります。インデックスが重複していると、先に行われた要素の初期化が上書きされる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="translated">インデックス [{0}] の要素は既に初期化されています。先に行われたこの要素の初期化が上書きされる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">インデックス付き要素の初期化を重複させないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">外部から参照できるメソッドが、引数が null (Visual Basic では Nothing) であるかどうかを確認せずに参照引数の 1 つを逆参照しています。外部から参照できるメソッドに渡されるすべての参照引数は、null でないかどうかを確認する必要があります。適切であれば、引数が null の場合は ArgumentNullException をスローするか、非 null の引数をアサートするコード コントラクトの必須条件を追加します。メソッドが既知のアセンブリからのみ呼び出されるように設計されている場合、メソッドを internal にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</source>
        <target state="translated">外部から参照できるメソッド '{0}' において、検証パラメーター '{1}' は使用前は非 null です。適切であれば、引数が null の場合に ArgumentNullException をスローするか、非 null の引数をアサートするコード コントラクトの必須条件を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">パブリック メソッドの引数の検証</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>