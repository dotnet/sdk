<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../MicrosoftCodeQualityAnalyzersResources.resx">
    <body>
      <trans-unit id="AppendConfigureAwaitTrue">
        <source>Append .ConfigureAwait(true)</source>
        <target state="translated">Добавить .ConfigureAwait(true)</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementDescription">
        <source>Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements.</source>
        <target state="translated">Присваивать значения символу и его элементу (полю/свойству) в одном операторе не рекомендуется. При обращении к элементу не ясно, следует ли использовать старое значение символа до присвоения в этом операторе или новое значение. Для ясности рекомендуется присваивать значения в отдельных операторах.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementMessage">
        <source>Symbol '{0}' and its member '{1}' are both assigned in the same statement. You are at risk of assigning the member of an unintended object.</source>
        <target state="translated">Символу "{0}" и его элементу "{1}" присваиваются значения в одном операторе. Есть риск, что значение будет присвоено элементу не требуемого объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementTitle">
        <source>Assigning symbol and its member in the same statement</source>
        <target state="translated">Присвоение значения символу и его элементу в одном операторе</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesDescription">
        <source>The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</source>
        <target state="translated">Чем больше параметров типа содержит универсальный тип, тем сложнее определить и запомнить, что представляет каждый параметр типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesMessage">
        <source>Consider a design where '{0}' has no more than {1} type parameters</source>
        <target state="translated">Измените архитектуру, так чтобы число параметров типа в "{0}" не превышало {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesTitle">
        <source>Avoid excessive parameters on generic types</source>
        <target state="translated">Не используйте слишком много параметров в универсальных типах</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionMessageMaybe">
        <source>Do not assign the property within its setter. This call might result in an infinite recursion.</source>
        <target state="translated">Не присваивайте свойство в его методе задания. Такой вызов может привести к бесконечной рекурсии.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionMessageSure">
        <source>Do not assign the property within its setter. This call will result in an infinite recursion.</source>
        <target state="translated">Не присваивайте свойство в его методе задания. Такой вызов приведет к бесконечной рекурсии.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionTitle">
        <source>Avoid infinite recursion</source>
        <target state="translated">Избегайте бесконечной рекурсии</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndCodeFixTitle">
        <source>Remove redundant length argument</source>
        <target state="translated">Удалить избыточный аргумент длины</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndDescription">
        <source>An explicit length calculation can be error-prone and can be avoided when slicing to end of the buffer.</source>
        <target state="translated">Явное вычисление длины может быть подвержено ошибкам, и его можно избегать при срезе до конца буфера.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndMessage">
        <source>'{0}' uses a redundant length calculation that can be removed</source>
        <target state="translated">"{0}" использует избыточное вычисление длины, которое можно удалить</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndTitle">
        <source>Avoid redundant length argument</source>
        <target state="translated">Избегайте избыточного аргумента длины</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidMultipleEnumerationsMessage">
        <source>Possible multiple enumerations of 'IEnumerable' collection. Consider using an implementation that avoids multiple enumerations.</source>
        <target state="translated">Возможно несколько перечислений коллекции IEnumerable. Рассмотрите возможность использования реализации без нескольких перечислений.</target>
        <note>{Locked="IEnumerable"}</note>
      </trans-unit>
      <trans-unit id="AvoidMultipleEnumerationsTitle">
        <source>Possible multiple enumerations of 'IEnumerable' collection</source>
        <target state="translated">Возможно несколько перечислений коллекции IEnumerable</target>
        <note>{Locked="IEnumerable"}</note>
      </trans-unit>
      <trans-unit id="AvoidOutParametersDescription">
        <source>Passing types by reference (using 'out' or 'ref') requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between 'out' and 'ref' parameters is not widely understood.</source>
        <target state="translated">Для передачи типов по ссылке (с использованием "out" или "ref") необходим опыт работы с указателями, понимание различий между типами значений и ссылочными типами, а также использование методов с несколькими возвращаемыми значениями. Кроме того, разница между параметрами "out" и "ref" не является очевидной.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersMessage">
        <source>Avoid 'out' parameters as they are not designed for general audience</source>
        <target state="translated">Избегайте параметров "out", так как они не предназначены для общей аудитории.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersTitle">
        <source>Avoid out parameters</source>
        <target state="translated">Не используйте параметры out</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMultipleMessage">
        <source>Type '{0}' directly or indirectly inherits '{1}' without implementing any of '{2}'. Publicly-visible types should implement the generic version to broaden usability.</source>
        <target state="translated">Тип "{0}" прямо или косвенно наследует "{1}" без реализации какого-либо из "{2}". Общедоступные типы должны реализовывать универсальную версию для повышения удобства использования.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesDescription">
        <source>A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught.</source>
        <target state="translated">Общее исключение, такое как System.Exception, System.SystemException или недопустимый тип исключения, перехватывается в выражении catch либо используется общее выражение catch. Общие и недопустимые исключения не должны перехватываться.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesMessage">
        <source>Modify '{0}' to catch a more specific allowed exception type, or rethrow the exception</source>
        <target state="translated">Измените "{0}", чтобы перехватывать исключение более конкретного типа или выдать исключение повторно.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesTitle">
        <source>Do not catch general exception types</source>
        <target state="translated">Не перехватывать исключения общих типов</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesDescription">
        <source>Types declare protected members so that inheriting types can access or override the member. By definition, you cannot inherit from a sealed type, which means that protected methods on sealed types cannot be called.</source>
        <target state="translated">Типы объявляют защищенные члены, чтобы наследующие типы могли получить доступ к члену или переопределить его. По определению вы не можете наследовать от запечатанного типа, то есть невозможно вызывать защищенные методы в запечатанных типах.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesMessage">
        <source>'{0}' is a new protected member in the 'NonInheritable' class '{1}'</source>
        <target state="translated">"{0}" — новый защищенный элемент в "ненаследуемом" классе "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesTitle">
        <source>Do not declare protected member in sealed type</source>
        <target state="translated">Не объявляйте защищенный член в запечатанном типе</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageLinqMethod">
        <source>'{0}' calls '{1}' but does not use the value the method returns. Linq methods are known to not have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">"{0}" вызывает "{1}", но не использует значение, возвращаемое методом. Методы Linq не имеют известных побочных эффектов. Используйте результат в условном операторе, присвойте его переменной или передайте его в качестве аргумента другому методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageUserDefinedMethod">
        <source>'{0}' calls '{1}' but does not use the value the method returns. This method is defined as a user-option. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">"{0}" вызывает "{1}", но не использует значение, возвращаемое методом. Этот метод определен как пользовательский. Используйте результат в условном операторе, присвойте его переменной или передайте его в качестве аргумента другому методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyFix">
        <source>Remove the unnecessary assignment.</source>
        <target state="translated">Удалите ненужное назначение.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedDescription">
        <source>This rule assumes that an enumeration member that has a name that contains "reserved" is not currently used but is a placeholder to be renamed or removed in a future version. Renaming or removing a member is a breaking change.</source>
        <target state="translated">Это правило предполагает, что элемент перечисления, имя которого содержит "reserved", сейчас не используется, но является заполнителем, который будет переименован или удален в будущей версии. Переименование или удаление элемента является критическим изменением.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedMessage">
        <source>If '{0}.{1}' is not used in the current implementation, remove it. Otherwise give it a meaningful name.</source>
        <target state="translated">Если "{0}.{1}" не используется в текущей реализации, удалите его. В противном случае присвойте ему осмысленное имя.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedTitle">
        <source>Do not name enum values 'Reserved'</source>
        <target state="translated">Не присваивайте перечисляемым значениям имя "Reserved"</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsDescription">
        <source>System.Collections.Generic.List&lt;T&gt; is a generic collection that's designed for performance and not inheritance. List&lt;T&gt; does not contain virtual members that make it easier to change the behavior of an inherited class.</source>
        <target state="translated">System.Collections.Generic.List&lt;T&gt; является универсальной коллекцией, которая предназначена для повышения производительности, а не для наследования. List&lt;T&gt; не содержит виртуальные члены, которые упрощают изменение поведения наследуемого класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsMessage">
        <source>Change '{0}' in '{1}' to use 'Collection&lt;T&gt;', 'ReadOnlyCollection&lt;T&gt;' or 'KeyedCollection&lt;K,V&gt;'</source>
        <target state="translated">Измените "{0}" в "{1}" так, чтобы использовать "Collection&lt;T&gt;", "ReadOnlyCollection&lt;T&gt;" или "KeyedCollection&lt;K,V&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsTitle">
        <source>Do not expose generic lists</source>
        <target state="translated">Не предоставляйте универсальные списки</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualDescription">
        <source>Do not declare virtual events in a base class. Overridden events in a derived class have undefined behavior. The C# compiler does not handle this correctly and it is unpredictable whether a subscriber to the derived event will actually be subscribing to the base class event.</source>
        <target state="translated">Не объявляйте виртуальные события в базовом классе. Переопределенные события в производном классе имеют неопределенное поведение. Компилятор C# не обрабатывает такие события корректно, поэтому невозможно предсказать, будет ли подписчик на событие производного класса действительно подписан на событие базового класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualMessage">
        <source>Event '{0}' should not be declared virtual</source>
        <target state="translated">Событие "{0}" не следует объявлять как виртуальное.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualTitle">
        <source>Do not declare event fields as virtual</source>
        <target state="translated">Не объявляйте поля событий как виртуальные</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesDescription">
        <source>For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. If the operator is providing meaningful value equality, the type should implement the generic 'System.IEquatable' interface.</source>
        <target state="translated">Для ссылочных типов реализация оператора равенства по умолчанию почти всегда является правильной. По умолчанию две ссылки равны только в том случае, если они указывают на один и тот же объект. Если оператор предоставляет осмысленное равенство значений, тип должен реализовывать универсальный интерфейс "System.IEquatable".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesMessage">
        <source>'{0}' should not overload the equality operator</source>
        <target state="translated">В "{0}" не следует перегружать оператор равенства.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesTitle">
        <source>Do not overload equality operator on reference types</source>
        <target state="translated">Не перегружайте оператор равенства для ссылочных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksDescription">
        <source>Unawaited tasks that use 'IDisposable' instances may use those instances long after they have been disposed. Ensure tasks using those instances are completed before the instances are disposed.</source>
        <target state="translated">Неожидаемые задачи, использующие экземпляры IDisposable, могут продолжать использовать эти экземпляры долго после их удаления. Убедитесь, что задачи, использующие эти экземпляры, завершены перед удалением экземпляров.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksMessage">
        <source>Ensure tasks using 'IDisposable' instances complete before the instances are disposed</source>
        <target state="translated">Убедитесь, что задачи, использующие экземпляры IDisposable, завершены перед удалением экземпляров</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksTitle">
        <source>Do not pass 'IDisposable' instances into unawaited tasks</source>
        <target state="translated">Не передавайте экземпляры IDisposable в неожидаемые задачи</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceDescription">
        <source>Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Also, the difference between out and ref parameters is not widely understood.</source>
        <target state="translated">Для передачи типов по ссылке (с использованием "out" или "ref") необходим опыт работы с указателями, понимание различий между типами значений и ссылочными типами, а также использование методов с несколькими возвращаемыми значениями. Кроме того, разница между параметрами "out" и "ref" не является очевидной.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceMessage">
        <source>Consider a design that does not require that '{0}' be a reference parameter</source>
        <target state="translated">Измените архитектуру, так чтобы "{0}" не был ссылочным параметром.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceTitle">
        <source>Do not pass types by reference</source>
        <target state="translated">Не передавайте типы по ссылке</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameDescription">
        <source>An enumeration's values should not start with the type name of the enumeration.</source>
        <target state="translated">Значения перечисления не могут начинаться с имени типа перечисления.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameMessage">
        <source>Do not prefix enum values with the name of the enum type '{0}'</source>
        <target state="translated">Не добавлять к значениям перечисления префикс в виде типа перечисления "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameTitle">
        <source>Do not prefix enum values with type name</source>
        <target state="translated">Не добавлять к значениям перечисления префикс в виде имени типа</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesMessageDuplicatedBitwiseValuePart">
        <source>The field reference '{0}' is duplicated in this bitwise initialization</source>
        <target state="translated">Ссылка на поле "{0}" дублируется в этой побитовой инициализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesMessageDuplicatedValue">
        <source>The enum member '{0}' has the same constant value '{1}' as member '{2}'</source>
        <target state="translated">Элемент перечисления "{0}" имеет то же постоянное значение "{1}", что и элемент "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesTitle">
        <source>Enums values should not be duplicated</source>
        <target state="translated">Значения перечислений не должны повторяться</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixDescription">
        <source>Event names should describe the action that raises the event. To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions. For example, when naming a pair of events that is raised when closing a resource, you might name it 'Closing' and 'Closed', instead of 'BeforeClose' and 'AfterClose'.</source>
        <target state="translated">Имена событий должны описывать действия, которые вызывают событие. Для именования связанных событий, возникающих в определенной последовательности, используйте настоящее или прошедшее время, чтобы указать относительное положение в последовательности действий. Например, при именовании двух событий, возникающих при закрытии ресурса, вы можете присвоить им имена Closing и Closed вместо BeforeClose и AfterClose.</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixMessage">
        <source>Events should not have 'Before' or 'After' prefix</source>
        <target state="translated">3 - ReadyForReview</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixTitle">
        <source>Events should not have 'Before' or 'After' prefix</source>
        <target state="translated">3 - ReadyForReview</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageMultiple">
        <source>Rename {0} to end in either '{1}' or '{2}'</source>
        <target state="translated">Переименуйте {0} так, чтобы окончание было "{1}" или "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresCodeFixTitle">
        <source>Remove underscores</source>
        <target state="translated">Удалить символы подчеркивания</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeOverride">
        <source>Remove the finalizer from type '{0}', override Dispose(bool disposing), and put the finalization logic in the code path where 'disposing' is false. Otherwise, it might lead to duplicate Dispose invocations as the Base type '{1}' also provides a finalizer.</source>
        <target state="translated">Удалите метод завершения из типа '{0}', переопределите Dispose(bool disposing) и поместите логику завершения в путь кода, туда где 'disposing' имеет значение false. В противном случае это может привести к дублированию вызовов метода Dispose, так как базовый тип '{1}' также предоставляет метод завершения.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringDescription">
        <source>The logging message template should not vary between calls.</source>
        <target state="translated">Шаблон сообщения о ведении журнала не должен изменяться между вызовами.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringMessage">
        <source>The logging message template should not vary between calls to '{0}'</source>
        <target state="translated">Шаблон сообщения о ведении журнала не должен изменяться между вызовами в "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringTitle">
        <source>Template should be a static expression</source>
        <target state="translated">Шаблон должен быть статическим выражением</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchDescription">
        <source>Number of parameters supplied in the logging message template do not match the number of named placeholders.</source>
        <target state="translated">Количество параметров, указанных в шаблоне сообщения о ведении журнала, не соответствует количеству именованных заполнителей.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchMessage">
        <source>Number of parameters supplied in the logging message template do not match the number of named placeholders</source>
        <target state="translated">Количество параметров, указанных в шаблоне сообщения о ведении журнала, не соответствует количеству именованных заполнителей</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchTitle">
        <source>Parameter count mismatch</source>
        <target state="translated">Несоответствие количества параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchDescription">
        <source>The braces present in the message template are invalid. Ensure any braces in the message template are valid opening/closing braces, or are escaped.</source>
        <target state="translated">В шаблоне сообщения есть недопустимые фигурные скобки. Убедитесь, что все фигурные скобки в шаблоне сообщения являются допустимыми открывающими/закрывающими скобками или экранированы.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchMessage">
        <source>The braces present in the message template are invalid</source>
        <target state="translated">В шаблоне сообщения есть недопустимые фигурные скобки</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchTitle">
        <source>Invalid braces in message template</source>
        <target state="translated">Недопустимые фигурные скобки в шаблоне сообщения</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringDescription">
        <source>Named placeholders in the logging message template should not be comprised of only numeric characters.</source>
        <target state="translated">Именованные заполнители в шаблоне сообщения о ведении журнала не должны состоять только из цифр.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringMessage">
        <source>Named placeholders in the logging message template should not be comprised of only numeric characters</source>
        <target state="translated">Именованные заполнители в шаблоне сообщения о ведении журнала не должны состоять только из цифр</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringTitle">
        <source>Named placeholders should not be numeric values</source>
        <target state="translated">Именованные заполнители не должны быть числовыми значениями</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesDescription">
        <source>For improved performance, use the LoggerMessage delegates.</source>
        <target state="translated">Для повышения производительности используйте делегаты LoggerMessage.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesMessage">
        <source>For improved performance, use the LoggerMessage delegates instead of calling '{0}'</source>
        <target state="translated">Для повышения производительности используйте делегаты LoggerMessage вместо вызова "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesTitle">
        <source>Use the LoggerMessage delegates</source>
        <target state="translated">Использовать делегаты LoggerMessage</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensDescription">
        <source>Use PascalCase for named placeholders in the logging message template.</source>
        <target state="translated">Используйте PascalCase для именованных заполнителей в шаблоне сообщения о ведении журнала.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensMessage">
        <source>Use PascalCase for named placeholders in the logging message template</source>
        <target state="translated">Использовать PascalCase для именованных заполнителей в шаблоне сообщения о ведении журнала</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensTitle">
        <source>Use PascalCase for named placeholders</source>
        <target state="translated">Использовать PascalCase для именованных заполнителей</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalCodeFixTitle">
        <source>Make the public type internal</source>
        <target state="translated">Сделать общедоступный тип внутренним</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalDescription">
        <source>Unlike a class library, an application's API isn't typically referenced publicly, so types can be marked internal.</source>
        <target state="translated">В отличие от библиотеки классов, для API приложения обычно не используется общедоступная ссылка, поэтому типы можно пометить как внутренние.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalMessage">
        <source>Because an application's API isn't typically referenced from outside the assembly, types can be made internal</source>
        <target state="translated">Так как для API приложения обычно не используется ссылка из-за пределов сборки, типы можно сделать внутренними</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalTitle">
        <source>Consider making public types internal</source>
        <target state="translated">Рассмотрите возможность сделать общедоступные типы внутренними</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageCodeFix">
        <source>Apply 'AttributeUsageAttribute'</source>
        <target state="translated">Применить "AttributeUsageAttribute"</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesCodeFixTitle">
        <source>Add operator overload named alternate</source>
        <target state="translated">Добавление перегрузки оператора с другим именем</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantElementInitializationCodeFixTitle">
        <source>Remove redundant element initializer</source>
        <target state="translated">Удалите лишний инициализатор элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableTitle">
        <source>Types that own disposable fields should be disposable</source>
        <target state="translated">Типы, владеющие высвобождаемыми полями, должны быть высвобождаемыми</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableDescription">
        <source>A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</source>
        <target state="translated">Класс объявляет и реализует поле экземпляра, имеющее тип System.IDisposable, и не реализует IDisposable. Класс, который объявляет поле IDisposable, косвенно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking">
        <source>Type '{0}' owns disposable field(s) '{1}' but is not disposable</source>
        <target state="translated">Тип "{0}" владеет высвобождаемыми полями "{1}", но не является высвобождаемым</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsCodeFixTitle">
        <source>Add 'System.Uri' overloads</source>
        <target state="translated">Добавить перегрузки 'System.Uri'</target>
        <note>{Locked="System.Uri"}</note>
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsDescription">
        <source>This rule detects usage of platform-specific intrinsics that can be replaced with an equivalent cross-platform intrinsic instead.</source>
        <target state="translated">Это правило обнаруживает использование встроенных функций, специфичных для платформы, которые можно заменить эквивалентной кроссплатформенной встроенной функцией.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opAddition">
        <source>The addition operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор сложения</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opBitwiseAnd">
        <source>The bitwise-and operator should be preferred</source>
        <target state="translated">Следует предпочитать побитовый оператор И</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opBitwiseOr">
        <source>The bitwise-or operator should be preferred</source>
        <target state="translated">Следует предпочитать побитовый оператор ИЛИ</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opDivison">
        <source>The division operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор деления</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opExclusiveOr">
        <source>The exclusive-or operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор исключающего ИЛИ</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opLeftShift">
        <source>The left-shift operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор левого сдвига</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opMultiply">
        <source>The multiply operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор умножения</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opOnesComplement">
        <source>The ones-complement operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор дополнения до единицы</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opRightShift">
        <source>The right-shift operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор правого сдвига</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opSubtraction">
        <source>The subtraction operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор вычитания</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opUnaryNegation">
        <source>The unary-negation operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор унарного отрицания</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opUnsignedRightShift">
        <source>The unsigned right-shift operator should be preferred</source>
        <target state="translated">Следует предпочитать оператор беззнакового правого сдвига</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsTitle">
        <source>Use cross-platform intrinsics</source>
        <target state="translated">Используйте кроссплатформенные встроенные функции</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesTitle">
        <source>Use generic event handler instances</source>
        <target state="translated">Используйте экземпляры обработчика универсальных событий</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueTitle">
        <source>Enums should have zero value</source>
        <target state="translated">Перечисления должны иметь нулевое значение</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueDescription">
        <source>The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.</source>
        <target state="translated">Значение по умолчанию для неинициализированного перечисления, как и другие типы значений, равно нулю. Перечисление без атрибута Flags должно определять член с использованием нулевого значения, чтобы значение по умолчанию было допустимым значение перечисления. Если перечисление с примененным атрибутом FlagsAttribute определяет нулевой член, его имя должно быть равно "None", указывая, что в этом перечислении нет заданных значений.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsRename">
        <source>In enum {0}, change the name of {1} to 'None'</source>
        <target state="translated">В перечислении {0} измените имя {1} на "None".</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsMultipleZeros">
        <source>Remove all members that have the value zero from {0} except for one member that is named 'None'</source>
        <target state="translated">Удалите из {0} все члены с нулевым значением, за исключением одного, с именем "None".</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue">
        <source>Add a member to {0} that has a value of zero with a suggested name of 'None'</source>
        <target state="translated">Добавьте в {0} член с нулевым значением и предлагаемым именем "None".</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsTitle">
        <source>Abstract types should not have public constructors</source>
        <target state="translated">Абстрактные типы не должны иметь открытых конструкторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsDescription">
        <source>Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</source>
        <target state="translated">Конструкторы для абстрактных типов могут вызываться только производными типами. Так как общие конструкторы создают экземпляры типа, и вы не можете создавать экземпляры абстрактного типа, абстрактный тип с общим конструктором спроектирован неправильно.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsMessage">
        <source>Abstract type '{0}' should not have public constructors</source>
        <target state="translated">Абстрактный тип "{0}" не должен иметь открытых конструкторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantTitle">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">Пометить сборки как CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantDescription">
        <source>The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.</source>
        <target state="translated">Спецификация CLS определяет ограничения именования, типы данных и правила, которым должны соответствовать сборки, если они будут использоваться в разных языках программирования. Принципы хорошего проектирования требуют, чтобы все сборки явно указывали соответствие спецификации CLS с помощью CLSCompliantAttribute. Сборки без этого атрибута считаются несоответствующими.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantMessage">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">Пометить сборки как CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionTitle">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">Пометить сборки версией сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionDescription">
        <source>The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.</source>
        <target state="translated">Платформа .NET Framework использует номер версии для однозначной идентификации сборки, а также для привязки к типам в сборках со строгим именем. Этот номер версии используется вместе с версией и политикой издателя. По умолчанию приложения выполняются только с версией сборки, использованной при их сборке.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionMessage">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">Пометить сборки версией сборки</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleTitle">
        <source>Mark assemblies with ComVisible</source>
        <target state="translated">Пометить сборки как ComVisible</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleDescription">
        <source>ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.</source>
        <target state="translated">ComVisibleAttribute определяет, как COM-клиенты обращаются к управляемому коду. Принципы хорошего проектирования требуют, чтобы сборки явно указывали COM-видимость. COM-видимость можно задать для всей сборки и затем переопределить для отдельных типов и их членов. Если этот атрибут отсутствует, COM-клиенты видят содержимое сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageTitle">
        <source>Mark attributes with AttributeUsageAttribute</source>
        <target state="translated">Пометить атрибуты как AttributeUsageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageDefault">
        <source>Specify AttributeUsage on {0}</source>
        <target state="translated">Укажите AttributeUsage в {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsTitle">
        <source>Define accessors for attribute arguments</source>
        <target state="translated">Определите методы доступа для аргументов атрибута</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageDefault">
        <source>Add a public read-only property accessor for positional argument {0} of Attribute {1}</source>
        <target state="translated">Добавьте открытый метод доступа для свойства доступа только для чтения к позиционному аргументу {0} для атрибута {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageRemoveSetter">
        <source>Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}</source>
        <target state="translated">Удалите метод задания свойства из {0} или уменьшите область его доступности, так как он соответствует позиционному аргументу {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility">
        <source>If {0} is the property accessor for positional argument {1}, make it public</source>
        <target state="translated">Если {0} — это метод доступа к свойству для позиционного аргумента {1}, сделайте его открытым.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateTitle">
        <source>Use properties where appropriate</source>
        <target state="translated">Используйте свойства, когда это уместно</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateDescription">
        <source>A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.</source>
        <target state="translated">Общедоступный метод имеет имя, начинающееся с "Get", не принимает параметры и возвращает значение, отличное от массива. Этот метод может быть хорошим кандидатом на то, чтобы стать свойством.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateMessage">
        <source>Use properties where appropriate</source>
        <target state="translated">Используйте свойства, когда это уместно</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsTitle">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">Пометьте перечисления с помощью FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsDescription">
        <source>An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</source>
        <target state="translated">Перечисление — это тип значения, определяющий набор связанных именованных констант. Примените FlagsAttribute к перечислению, когда его именованные константы можно объединить значимым образом.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsMessage">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">Пометьте перечисления с помощью FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesTitle">
        <source>Interface methods should be callable by child types</source>
        <target state="translated">Методы интерфейса должны быть доступны для вызова дочерним типам</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesDescription">
        <source>An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</source>
        <target state="translated">Незапечатанный и видимый снаружи тип предоставляет явную реализацию метода для общедоступного интерфейса и не предоставляет альтернативный видимый снаружи метод с таким же именем.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesMessage">
        <source>Make '{0}' sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of '{1}' and is visible to derived classes</source>
        <target state="translated">Сделайте "{0}" запечатанным (критическое изменение, если этот класс уже был поставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет доступ к функциям "{1}" и видим производным классам.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesTitle">
        <source>Override methods on comparable types</source>
        <target state="translated">Переопределите методы в сопоставимых типах</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesDescription">
        <source>A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.</source>
        <target state="translated">Общедоступный или защищенный тип реализует интерфейс System.IComparable. Он не переопределяет Object.Equals и не перегружает языковой оператор на предмет сравнений равно, неравно, меньше, меньше или равно, больше, больше или равно.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageEquals">
        <source>{0} should override Equals since it implements IComparable</source>
        <target state="translated">{0} должен переопределить оператор Equals, так как он реализует IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageOperator">
        <source>{0} should define operator(s) '{1}' since it implements IComparable</source>
        <target state="translated">{0} должен определять операторы "{1}", так как он реализует IComparable.</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassTitle">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">Переместите вызовы PInvoke в класс собственных методов</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassDescription">
        <source>Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</source>
        <target state="translated">Методы вызова неуправляемого кода, например, помеченные атрибутом System.Runtime.InteropServices.DllImportAttribute, или методы, определенные с помощью ключевого слова Declare в Visual Basic, обращаются к неуправляемому коду. Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassMessage">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">Переместите вызовы PInvoke в класс собственных методов</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseTitle">
        <source>Identifiers should differ by more than case</source>
        <target state="translated">Идентификаторы должны отличаться не только регистром</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseDescription">
        <source>Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</source>
        <target state="translated">Идентификаторы для пространств имен, типов, членов и параметров не могут отличаться только регистром, так как языки, ориентированные на среду CLR, не учитывают регистр.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseMessage">
        <source>Names of '{0}' and '{1}' should differ by more than case</source>
        <target state="translated">Имена "{0}" и "{1}" должны отличаться не только регистром.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixTitle">
        <source>Identifiers should have correct prefix</source>
        <target state="translated">Идентификаторы должны иметь правильные префиксы</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixDescription">
        <source>The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".</source>
        <target state="translated">Имя видимых снаружи интерфейсов не начинается с прописной буквы "I". Имя параметра универсального типа для видимого снаружи типа или метода не начинается с прописной буквы "T".</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageInterface">
        <source>Prefix interface name {0} with 'I'</source>
        <target state="translated">Добавьте префикс "I" к имени интерфейса {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageTypeParameter">
        <source>Prefix generic type parameter name {0} with 'T'</source>
        <target state="translated">Добавьте префикс "T" к имени параметра универсального типа {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleTitle">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">Поля, не являющиеся константами, не должны быть видимыми</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleDescription">
        <source>Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</source>
        <target state="translated">Статические поля, не являющиеся ни константами, ни доступными только для чтения, не потокобезопасны. Доступ к таким полям следует тщательно контролировать, а для синхронизации доступа к объекту класса требуется применять расширенные методики программирования.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleMessage">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">Поля, не являющиеся константами, не должны быть видимыми</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsTitle">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">Не помечайте перечисления с помощью FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsDescription">
        <source>An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</source>
        <target state="translated">Видимое снаружи перечисление помечается с помощью FlagsAttribute и имеет одно или несколько значений, отличных от степеней двойки или сочетания других определенных значений в этом перечислении.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsMessage">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">Не помечайте перечисления с помощью FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesTitle">
        <source>Operator overloads have named alternates</source>
        <target state="translated">Для перегрузок операторов существуют варианты с именами</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesDescription">
        <source>An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</source>
        <target state="translated">Обнаружена перегрузка оператора, а ожидаемый именованный альтернативный метод не найден. Именованный альтернативный член предоставляет доступ к тем же функциям, что и этот оператор, и предназначен для разработчиков, которые используют языки, не поддерживающие перегруженные операторы.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageDefault">
        <source>Provide a method named '{0}' as a friendly alternate for operator {1}</source>
        <target state="translated">Предоставьте метод с именем "{0}" в качестве понятной альтернативы оператору {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageProperty">
        <source>Provide a property named '{0}' as a friendly alternate for operator {1}</source>
        <target state="translated">Предоставьте свойство с именем "{0}" в качестве понятной альтернативы оператору {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageMultiple">
        <source>Provide a method named '{0}' or '{1}' as an alternate for operator {2}</source>
        <target state="translated">Предоставьте метод с именем "{0}" или "{1}" в качестве альтернативы оператору {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageVisibility">
        <source>Mark {0} as public because it is a friendly alternate for operator {1}</source>
        <target state="translated">Пометьте {0} как открытый, так как он является понятной альтернативой оператору {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsTitle">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">Перегрузки операторов должны быть симметричными</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsDescription">
        <source>A type implements the equality or inequality operator and does not implement the opposite operator.</source>
        <target state="translated">Тип реализует оператор равенства или неравенства и не реализует противоположный оператор.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyTitle">
        <source>Collection properties should be read only</source>
        <target state="translated">Свойства коллекций должны быть доступны только для чтения</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyDescription">
        <source>A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.</source>
        <target state="translated">Доступное для записи свойство коллекции позволяет пользователю заменить коллекцию на другую коллекцию. Свойство, доступное только для чтения, не позволяет заменить коллекцию, но при этом позволяет задавать отдельные члены.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyMessage">
        <source>Change '{0}' to be read-only by removing the property setter</source>
        <target state="translated">Удалите метод задания свойств для "{0}", чтобы сделать его доступным только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">Оператор перегрузки равен переопределяющему типу значения Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription">
        <source>In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals.</source>
        <target state="translated">В большинстве языков программирования нет реализации оператора равенства (==) по умолчанию для типов значений. Если ваш язык программирования поддерживает перегрузки операторов, рекомендуется реализовать оператор равенства. Он должен работать аналогично Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage">
        <source>Implement the equality operators and make their behavior identical to that of the Equals method</source>
        <target state="translated">Реализуйте операторы равенства и сделайте их поведение идентичным поведению метода "Equals".</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsTitle">
        <source>Pass system uri objects instead of strings</source>
        <target state="translated">Передавайте объекты системного URI вместо строк</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsDescription">
        <source>A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</source>
        <target state="translated">Выполнен вызов метода со строковым параметром, имя которого содержит "uri", "URI", "urn", "URN", "url" или "URL". Объявляющий тип метода содержит соответствующую перегрузку метода с параметром System.Uri.</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsMessage">
        <source>Modify '{0}' to call '{1}' instead of '{2}'</source>
        <target state="translated">Измените "{0}", чтобы вызывать "{1}" вместо "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsTitle">
        <source>Implement IEquatable when overriding Object.Equals</source>
        <target state="translated">Реализуйте IEquatable при переопределении Object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsMessage">
        <source>Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</source>
        <target state="translated">Тип {0} должен реализовывать IEquatable&lt;T&gt;, так как он переопределяет Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastTitle">
        <source>CancellationToken parameters must come last</source>
        <target state="translated">Параметры CancellationToken должны находиться в конце</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastMessage">
        <source>Method '{0}' should take CancellationToken as the last parameter</source>
        <target state="translated">Метод "{0}" должен принимать CancellationToken в качестве параметра</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesTitle">
        <source>Identifier contains type name</source>
        <target state="translated">Идентификатор содержит имя типа</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesDescription">
        <source>Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.</source>
        <target state="translated">Имена параметров и членов лучше использовать для описания их значения, а не для указания их типа, который должен быть предоставлен средствами разработки. Если для имен членов нужно использовать имя типа данных, используйте независимое от языка имя вместо зависимого от языка.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesMessage">
        <source>Identifier '{0}' contains type name</source>
        <target state="translated">Идентификатор "{0}" содержит имя типа</target>
        <note />
      </trans-unit>
      <trans-unit id="CreatePropertyAccessorForParameter">
        <source>Create a property accessor.</source>
        <target state="translated">Создайте метод доступа свойства.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeGetterPublic">
        <source>Make the getter of the property public</source>
        <target state="translated">Сделайте метод получения свойства общим</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeSetterNonPublic">
        <source>Make the setter of the property non-public</source>
        <target state="translated">Сделайте метод задания свойства не общим</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAssemblyLevelComVisibleFalse">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true)</source>
        <target state="translated">Так как {0} публикует типы, видимые извне, пометьте его как ComVisible(false) на уровне сборки, а затем пометьте все типы в сборке, которые должны быть предоставлены COM-клиентам, как ComVisible(true).</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeAssemblyLevelComVisibleToFalse">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level</source>
        <target state="translated">Рекомендуется присвоить атрибуту ComVisible {0} значение "false" и дать согласие на уровне типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementComparable">
        <source>Implement Equality and Comparison methods and operators</source>
        <target state="translated">Реализуйте методы и операторы Equality и Comparison</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementEquatable">
        <source>Implement IEquatable</source>
        <target state="translated">Реализуйте IEquatable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableInterface">
        <source>Implement IDisposable Interface</source>
        <target state="translated">Реализуйте интерфейс IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsCodeFix">
        <source>Remove FlagsAttribute from enum.</source>
        <target state="translated">Удалите FlagsAttribute из перечисления.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsCodeFix">
        <source>Apply FlagsAttribute to enum.</source>
        <target state="translated">Примените FlagsAttribute к перечислению.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsMultipleZeroCodeFix">
        <source>Remove all members that have the value zero except for one member that is named 'None'.</source>
        <target state="translated">Удалите все члены с нулевым значением, за исключением одного, с именем "None".</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsRenameCodeFix">
        <source>Rename zero-valued enum field to 'None'.</source>
        <target state="translated">Переименуйте поле перечисления с нулевым значением в "None".</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix">
        <source>Add a zero-valued member 'None' to enum.</source>
        <target state="translated">Добавьте нулевой член "None" в перечисление.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHavePublicConstructorsCodeFix">
        <source>Change the accessibility of public constructors to protected.</source>
        <target state="translated">Измените область доступности общих конструкторов на защищенную.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesTitle">
        <source>Do not declare static members on generic types</source>
        <target state="translated">Не объявляйте статические члены в универсальных типах</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesDescription">
        <source>When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.</source>
        <target state="translated">При вызове статического члена универсального типа требуется указать аргумент типа для типа. При вызове члена универсального экземпляра, не поддерживающего вывод, требуется указать аргумент типа для члена. В этих двух случаях синтаксис для указания аргумента типа различается, и его легко перепутать.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesMessage">
        <source>Do not declare static members on generic types</source>
        <target state="translated">Не объявляйте статические члены в универсальных типах</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceTitle">
        <source>Generic interface should also be implemented</source>
        <target state="translated">Также необходимо реализовать универсальный интерфейс</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceDescription">
        <source>To broaden the usability of a type, implement one of the generic interfaces. This is especially true for collections as they can then be used to populate generic collection types.</source>
        <target state="translated">Чтобы расширить использование типа, реализуйте один из универсальных интерфейсов. Это особенно важно для коллекций, так как в этом случае их можно использовать для заполнения универсальных типов коллекций.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMessage">
        <source>Type '{0}' directly or indirectly inherits '{1}' without implementing '{2}'. Publicly-visible types should implement the generic version to broaden usability.</source>
        <target state="translated">Тип "{0}" прямо или косвенно наследует "{1}" без реализации "{2}". Общедоступные типы должны реализовывать универсальную версию для более широкого использования.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Title">
        <source>Enum Storage should be Int32</source>
        <target state="translated">Хранилище перечислений должно относиться к типу Int32</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Description">
        <source>An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.</source>
        <target state="translated">Перечисление — это тип значения, определяющий набор связанных именованных констант. По умолчанию тип данных System.Int32 используется для хранения постоянного значения. Хотя вы можете изменить этот базовый тип, для большинства сценариев делать это не требуется или не рекомендуется.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Message">
        <source>If possible, make the underlying type of {0} System.Int32 instead of {1}</source>
        <target state="translated">По возможности используйте для {0} базовый тип System.Int32 вместо {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateTitle">
        <source>Use events where appropriate</source>
        <target state="translated">Используйте события, когда это уместно</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateDescription">
        <source>This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.</source>
        <target state="translated">Это правило обнаруживает методы с именами, которые в общем случае использовались бы для событий. Если метод вызывается в ответ на четко определенное изменение состояния, его должен вызывать обработчик событий. Объекты, вызывающие этот метод, должны порождать события вместо вызова метода напрямую.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateMessage">
        <source>Consider making '{0}' an event</source>
        <target state="translated">Рекомендуется сделать "{0}" событием.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsTitle">
        <source>Implement standard exception constructors</source>
        <target state="translated">Реализуйте стандартные конструкторы исключения</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsDescription">
        <source>Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</source>
        <target state="translated">Неспособность предоставить полный набор конструкторов может затруднить правильную обработку исключений.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageMissingConstructor">
        <source>Add the following constructor to {0}: {1}</source>
        <target state="translated">Добавьте в {0} следующий конструктор: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleTitle">
        <source>Nested types should not be visible</source>
        <target state="translated">Вложенные типы не должны быть видимыми</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleDescription">
        <source>A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.</source>
        <target state="translated">Вложенным является тип, объявленный в области другого типа. Вложенные типы удобны для инкапсуляции сведений о закрытой реализации для содержащего типа. Применяемые для этого вложенные типы не должны быть видимы снаружи.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageDefault">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible.</source>
        <target state="translated">Не делайте тип {0} вложенным. Вместо этого измените режим доступа к нему так, чтобы он не был виден снаружи.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageVisualBasicModule">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module.</source>
        <target state="translated">Не делайте тип {0} вложенным. Вместо этого измените режим доступа к нему так, чтобы он не был виден снаружи. Если данный тип был определен в модуле Visual Basic, другими языками .NET он будет рассматриваться как вложенный тип. В этом случае рекомендуется переместить тип за пределы модуля.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesTitle">
        <source>Avoid empty interfaces</source>
        <target state="translated">Не используйте пустые интерфейсы</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesDescription">
        <source>Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</source>
        <target state="translated">Интерфейсы определяют члены, предоставляющие поведение или контракт на использование. Описываемую интерфейсом функциональность может использовать любой тип, находящийся в любой части иерархии наследования. Тип реализует интерфейс, предоставляя реализации для членов интерфейса. Пустой интерфейс не определяет никакие члены, и поэтому он не определяет контракт, который можно реализовать.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesMessage">
        <source>Avoid empty interfaces</source>
        <target state="translated">Не используйте пустые интерфейсы</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageTitle">
        <source>Provide ObsoleteAttribute message</source>
        <target state="translated">Укажите сообщение ObsoleteAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageDescription">
        <source>A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.</source>
        <target state="translated">Тип или член помечен с помощью атрибута System.ObsoleteAttribute, для которого не задано свойство ObsoleteAttribute.Message. При компиляции типа или члена, помеченного с помощью ObsoleteAttribute, отображается свойство Message этого атрибута. Оно предоставляет пользователю сведения об устаревшем типе или члене.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageMessage">
        <source>Provide a message for the ObsoleteAttribute that marks {0} as Obsolete</source>
        <target state="translated">Укажите сообщение для ObsoleteAttribute, помечающего {0} как устаревший</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyTitle">
        <source>Properties should not be write only</source>
        <target state="translated">Свойства не могут быть доступны только на запись</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyDescription">
        <source>Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</source>
        <target state="translated">Хотя свойства, доступные только для чтения, использовать разрешено и часто необходимо, рекомендации по разработке запрещают использовать свойства, доступные только для записи. Это вызвано тем, что процедура, позволяющая пользователю задать значение и не позволяющая его считать, является небезопасной. Кроме того, без доступа на чтение невозможно просмотреть состояние общих объектов, что ограничивает возможности их применения.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageAddGetter">
        <source>Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method</source>
        <target state="translated">Так как свойство {0} доступно только для чтения, добавьте для него метод получения, уровень доступности которого больше или равен уровню доступности метода задания, либо преобразуйте это свойство в метод.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible">
        <source>Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter</source>
        <target state="translated">Так как метод получения свойства {0} имеет меньшую видимость, чем метод задания, увеличьте уровень доступности для метода получения или уменьшите его для метода задания.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesTitle">
        <source>Declare types in namespaces</source>
        <target state="translated">Объявите типы в пространствах имен</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesDescription">
        <source>Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</source>
        <target state="translated">Типы объявляются в пространствах имен во избежание конфликтов имен, а также для упорядочивания связанных типов в иерархии объектов.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesMessage">
        <source>Declare types in namespaces</source>
        <target state="translated">Объявите типы в пространствах имен</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsTitle">
        <source>Do not declare visible instance fields</source>
        <target state="translated">Не объявляйте видимые поля экземпляров</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsDescription">
        <source>The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.</source>
        <target state="translated">Основной вид использования поля должен соответствовать сведениям о реализации. Поля должны быть частными или внутренними и предоставляться с помощью свойств.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsMessage">
        <source>Do not declare visible instance fields</source>
        <target state="translated">Не объявляйте видимые поля экземпляров</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsTitle">
        <source>URI-like parameters should not be strings</source>
        <target state="translated">Параметры, напоминающие URI, не должны быть строками</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsDescription">
        <source>This rule assumes that the parameter represents a Uniform Resource Identifier (URI). A string representation or a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. 'System.Uri' class provides these services in a safe and secure manner.</source>
        <target state="translated">Это правило предполагает, что параметр представляет универсальный код ресурса (URI). Строковое представление URI подвержено возникновению ошибок анализа и кодирования, а также может создавать уязвимости в системе безопасности. Класс "System.Uri" предоставляет эти услуги надежным и безопасным образом.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsMessage">
        <source>Change the type of parameter '{0}' of method '{1}' from 'string' to 'System.Uri', or provide an overload to '{1}' that allows '{0}' to be passed as a 'System.Uri' object</source>
        <target state="translated">Измените тип параметра "{0}" метода "{1}" со "string" на "System.Uri" или обеспечьте перегрузку метода "{1}", позволяющую передавать параметр "{0}" как объект "System.Uri".</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsTitle">
        <source>URI-like return values should not be strings</source>
        <target state="translated">Возвращаемые значения, напоминающие URI, не должны быть строками</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsDescription">
        <source>This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">Это правило предполагает, что метод возвращает URI. Строковое представление URI подвержено возникновению ошибок анализа и кодирования, а также может создавать уязвимости в системе безопасности. Класс System.Uri предоставляет эти службы безопасным образом.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsMessage">
        <source>Change the return type of method '{0}' from 'string' to 'System.Uri'</source>
        <target state="translated">Измените тип возвращаемого значения для метода "{0}" со "string" на "System.Uri".</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsTitle">
        <source>URI-like properties should not be strings</source>
        <target state="translated">Свойства, напоминающие URI, не должны быть строками</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsDescription">
        <source>This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">Это правило предполагает, что свойство представляет универсальный код ресурса (URI). Строковое представление URI подвержено возникновению ошибок анализа и кодирования, а также может создавать уязвимости в системе безопасности. Класс System.Uri предоставляет эти службы безопасным образом.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsMessage">
        <source>Change the type of property '{0}' from 'string' to 'System.Uri'</source>
        <target state="translated">Измените тип свойства "{0}" со "string" на "System.Uri".</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyTitle">
        <source>Implement IDisposable Correctly</source>
        <target state="translated">Правильно реализуйте IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyDescription">
        <source>All IDisposable types should implement the Dispose pattern correctly.</source>
        <target state="translated">Во всех типах IDisposable шаблон Dispose должен быть реализован правильно.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageIDisposableReimplementation">
        <source>Remove IDisposable from the list of interfaces implemented by '{0}' as it is already implemented by base type '{1}'</source>
        <target state="translated">Удалите IDisposable из списка интерфейсов, реализованных в "{0}", так как он уже реализован базовым типом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeOverride">
        <source>Remove '{0}', override Dispose(bool disposing), and put the dispose logic in the code path where 'disposing' is true</source>
        <target state="translated">Удалите "{0}", переопределите Dispose(bool disposing) и поместите логику метода dispose в пути кода, там где "disposing" имеет значение true.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeSignature">
        <source>Ensure that '{0}' is declared as public and sealed</source>
        <target state="translated">Убедитесь, что тип "{0}" объявлен как открытый и запечатанный.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageRenameDispose">
        <source>Rename '{0}' to 'Dispose' and ensure that it is declared as public and sealed</source>
        <target state="translated">Переименуйте "{0}" в "Dispose" и убедитесь, что он объявлен как открытый и запечатанный.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeBoolSignature">
        <source>Ensure that '{0}' is declared as protected, virtual, and unsealed</source>
        <target state="translated">Убедитесь, что тип "{0}" объявлен как защищенный, виртуальный и незапечатанный.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeImplementation">
        <source>Modify '{0}' so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance ('this' or 'Me' in Visual Basic), and then returns</source>
        <target state="translated">Измените "{0}", так чтобы он вызывал Dispose(true), затем вызывал GC.SuppressFinalize для экземпляра текущего объекта ("this" или "Me" в Visual Basic) и затем выполнял возврат.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeImplementation">
        <source>Modify '{0}' so that it calls Dispose(false) and then returns</source>
        <target state="translated">Измените "{0}", так чтобы он вызывал Dispose(false) и затем выполнял возврат.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageProvideDisposeBool">
        <source>Provide an overridable implementation of Dispose(bool) on '{0}' or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources.</source>
        <target state="translated">Предоставьте переопределяемую реализацию Dispose(bool) в '{0}' или пометьте тип как запечатанный. При вызове Dispose(false) должны удаляться только собственные ресурсы. При вызове Dispose(true) должны удаляться как управляемые, так и собственные ресурсы.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicTitle">
        <source>Exceptions should be public</source>
        <target state="translated">Исключения должны быть общими</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicDescription">
        <source>An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.</source>
        <target state="translated">Внутреннее исключение видно только внутри своей внутренней области. Когда исключение выходит за пределы внутренней области, для его перехвата можно использовать только базовое исключение. Если внутреннее исключение унаследовано от T:System.Exception, T:System.SystemException или T:System.ApplicationException, внешний код не будет располагать достаточной информацией о том, что нужно сделать с этим исключением.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicMessage">
        <source>Exceptions should be public</source>
        <target state="translated">Исключения должны быть общими</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsTitle">
        <source>Do not raise exceptions in unexpected locations</source>
        <target state="translated">Не вызывайте исключения в непредвиденных местах</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsDescription">
        <source>A method that is not expected to throw exceptions throws an exception.</source>
        <target state="translated">Метод, который не должен выдавать исключение, делает это.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property's logic so that it no longer raises an exception.</source>
        <target state="translated">{0} создает исключение типа {1}, который не должен порождаться в свойстве. Если этот экземпляр исключения может быть порожден, используйте другой тип исключения, преобразуйте это свойство в метод или измените логику этого свойства, чтобы оно больше не порождало исключение.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method's logic so that it no longer raises an exception.</source>
        <target state="translated">{0} создает исключение типа {1}, который не должен порождаться в этом типе метода. Если этот экземпляр исключения может быть порожден, используйте другой тип исключения или измените логику этого метода, чтобы он больше не порождал исключение.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions">
        <source>{0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method's logic so it no longer raises an exception.</source>
        <target state="translated">{0} создает исключение типа {1}. В этом типе метода не должны порождаться исключения. Если этот экземпляр исключения может быть порожден, измените логику этого метода, чтобы он больше не порождал исключение.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresTitle">
        <source>Identifiers should not contain underscores</source>
        <target state="translated">Идентификаторы не должны содержать символы подчеркивания</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresDescription">
        <source>By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.</source>
        <target state="translated">По соглашению имена идентификаторов не содержат символ подчеркивания (_). Это правило проверяет пространства имен, типы, члены и параметры.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageAssembly">
        <source>Remove the underscores from assembly name {0}</source>
        <target state="translated">Удалите символы подчеркивания из имени сборки {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageNamespace">
        <source>Remove the underscores from namespace name '{0}'</source>
        <target state="translated">Удалите символы подчеркивания из имени пространства имен "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageType">
        <source>Remove the underscores from type name {0}</source>
        <target state="translated">Удалите символы подчеркивания из имени типа {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMember">
        <source>Remove the underscores from member name {0}</source>
        <target state="translated">Удалите символы подчеркивания из имени члена {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter">
        <source>On type {0}, remove the underscores from generic type parameter name {1}</source>
        <target state="translated">В типе {0} удалите символы подчеркивания из имени параметра универсального типа {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter">
        <source>On method {0}, remove the underscores from generic type parameter name {1}</source>
        <target state="translated">В методе {0} удалите символы подчеркивания из имени параметра универсального типа {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMemberParameter">
        <source>In member {0}, remove the underscores from parameter name {1}</source>
        <target state="translated">В члене {0} удалите символы подчеркивания из имени параметра {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageDelegateParameter">
        <source>In delegate {0}, remove the underscores from parameter name {1}</source>
        <target state="translated">В делегате {0} удалите символы подчеркивания из имени параметра {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixTitle">
        <source>Identifiers should have correct suffix</source>
        <target state="translated">Идентификаторы должны иметь правильные суффиксы</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixDescription">
        <source>By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</source>
        <target state="translated">По соглашению имена типов, расширяющих определенные базовые типы или реализующих определенные интерфейсы, или производных от них типов имеют суффикс, связанный с базовым типом или интерфейсом.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageDefault">
        <source>Rename {0} to end in '{1}'</source>
        <target state="translated">Переименуйте {0}, чтобы в конце стояло "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixTitle">
        <source>Identifiers should not have incorrect suffix</source>
        <target state="translated">Идентификаторы не должны иметь неправильных суффиксов</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixDescription">
        <source>By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.</source>
        <target state="translated">По соглашению только имена типов, расширяющих определенные базовые типы или реализующих определенные интерфейсы, или производных от них типов должны заканчиваться определенными зарезервированными суффиксами. Другие имена типов эти суффиксы содержать не должны.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate">
        <source>Rename type name {0} so that it does not end in '{1}'</source>
        <target state="translated">Измените имя типа {0}, чтобы оно не заканчивалось на "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion">
        <source>Either replace the suffix '{0}' in member name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the member it replaces</source>
        <target state="translated">Либо замените суффикс "{0}" в имени члена {1} предложенным числом "2", либо подберите более значимый суффикс, который отличит его от заменяемого члена.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion">
        <source>Either replace the suffix '{0}' in type name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the type it replaces</source>
        <target state="translated">Либо замените суффикс "{0}" в имени типа {1} предложенным числом "2", либо подберите более значимый суффикс, который отличит его от заменяемого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate">
        <source>Either replace the suffix '{0}' in member name '{1}' with the suggested alternate '{2}' or remove the suffix completely</source>
        <target state="translated">Либо замените суффикс "{0}" в имени члена "{1}" предложенной альтернативой "{2}", либо полностью удалите суффикс.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsTitle">
        <source>Identifiers should not match keywords</source>
        <target state="translated">Идентификаторы не должны совпадать с ключевыми словами</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsDescription">
        <source>A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</source>
        <target state="translated">Имя пространства имен или типа совпадает с зарезервированным ключевым словом в языке программирования. Идентификаторы для пространств имен и типов не должны совпадать с ключевыми словами, определенными в языках, которые ориентированы на среду CLR.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMemberParameter">
        <source>In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword '{2}'. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">В виртуальном члене или в члене интерфейса {0} переименуйте параметр {1} так, чтобы он больше не находился в конфликте с зарезервированным ключевым словом языка "{2}". Использование зарезервированного ключевого слова в качестве имени параметра виртуального члена или члена интерфейса затрудняет переопределение или реализацию члена для потребителей в других языках.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMember">
        <source>Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">Переименуйте виртуальный член или член интерфейса {0}, чтобы он больше не находился в конфликте с зарезервированным ключевым словом языка "{1}". Использование зарезервированного ключевого слова в качестве имени виртуального члена или члена интерфейса затрудняет переопределение или реализацию члена для потребителей в других языках.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageType">
        <source>Rename type {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type.</source>
        <target state="translated">Переименуйте тип {0}, чтобы он больше не находился в конфликте с зарезервированным ключевым словом языка "{1}". Использование зарезервированного ключевого слова в качестве имени типа затрудняет использование этого типа потребителями в других языках.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageNamespace">
        <source>Rename namespace {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace.</source>
        <target state="translated">Переименуйте пространство имен {0}, чтобы оно больше не находилось в конфликте с зарезервированным ключевым словом языка "{1}". Использование зарезервированного ключевого слова в качестве имени пространства имен затрудняет использование этого пространства имен потребителями в других языках.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsTitle">
        <source>Property names should not match get methods</source>
        <target state="translated">Имена свойств не должны совпадать с именами методов get</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsDescription">
        <source>The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.</source>
        <target state="translated">Имя общего или защищенного члена начинается с "Get" и по остальным признакам соответствует имени общего или защищенного свойства. Свойства и методы "Get" должны иметь имена, явно различающие их функции.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsMessage">
        <source>The property name '{0}' is confusing given the existence of method '{1}'. Rename or remove one of these members.</source>
        <target state="translated">Ошибочное имя свойства "{0}", уже существует метод "{1}". Переименуйте или удалите один из этих членов.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesTitle">
        <source>Type names should not match namespaces</source>
        <target state="translated">Имена типов не должны совпадать с именами пространств имен</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesDescription">
        <source>Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.</source>
        <target state="translated">Имена типов не должны совпадать с именами пространств имен, определенными в библиотеке классов .NET Framework. Нарушение этого правила ограничит возможности по использованию библиотеки.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageDefault">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}'. Change either name to eliminate the conflict.</source>
        <target state="translated">Имя типа {0} полностью или частично конфликтует с именем пространства имен "{1}". Измените одно из имен, чтобы устранить конфликт.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageSystem">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}' defined in the .NET Framework. Rename the type to eliminate the conflict.</source>
        <target state="translated">Имя типа {0} полностью или частично конфликтует с именем пространства имен "{1}", определенным в .NET Framework. Переименуйте тип, чтобы устранить конфликт.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationTitle">
        <source>Parameter names should match base declaration</source>
        <target state="translated">Имена параметров должны соответствовать базовому объявлению</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationDescription">
        <source>Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</source>
        <target state="translated">Согласованное именование параметров в иерархии переопределений расширяет возможности по использованию переопределений методов. Имя параметра в производном методе, которое отличается от имени в базовом объявлении, может привести к путанице с тем, является ли метод переопределением базового метода или новой перегрузкой метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationMessage">
        <source>In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}</source>
        <target state="translated">В члене {0} измените имя параметра {1} на {2}, чтобы привести идентификатор в соответствие с объявлением в {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesTitle">
        <source>Override equals and operator equals on value types</source>
        <target state="translated">Переопределите операторы Equals и равенства для типов значений</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesDescription">
        <source>For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</source>
        <target state="translated">Для типов значений унаследованная реализация Equals использует библиотеку отражения и сравнивает содержимое всех полей. Отражение требует большого объема вычислений, и сравнение каждого поля на предмет равенства может не требоваться. Если вы ожидаете, что пользователи будут сравнивать или сортировать экземпляры либо использовать их в качестве ключей хэш-таблицы, ваш тип значения должен реализовывать Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals">
        <source>{0} should override Equals</source>
        <target state="translated">{0} должен переопределить метод Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality">
        <source>{0} should override the equality (==) and inequality (!=) operators</source>
        <target state="translated">{0} должен переопределить операторы равенства (==) и неравенства (!=).</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysTitle">
        <source>Properties should not return arrays</source>
        <target state="translated">Свойства не должны возвращать массивы</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysDescription">
        <source>Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.</source>
        <target state="translated">Возвращаемый свойствами массивы не защищены от записи, даже если свойство доступно только для чтения. Чтобы предотвратить незаконное изменение массива, свойство должно возвращать копию массива. Обычно пользователи не осознают, какое негативное влияние на производительность оказывает вызов такого свойства.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysMessage">
        <source>Properties should not return arrays</source>
        <target state="translated">Свойства не должны возвращать массивы</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsTitle">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">Переопределите GetHashCode при переопределении Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsDescription">
        <source>GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code.</source>
        <target state="translated">GetHashCode возвращает значение, основанное на текущем экземпляре, которое подходит для хэш-алгоритмов и структур данных, таких как хэш-таблица. Два равных объекта одного типа должны возвращать одинаковый хэш-код.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsMessage">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">Переопределите GetHashCode при переопределении Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsTitle">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">Переопределите Equals при перегрузке оператора равенства</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsDescription">
        <source>A public type implements the equality operator but does not override Object.Equals.</source>
        <target state="translated">Общий тип реализует оператор равенства, но не переопределяет Object.Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsMessage">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">Переопределите Equals при перегрузке оператора равенства</target>
        <note />
      </trans-unit>
      <trans-unit id="Since_0_redefines_operator_1_it_should_also_redefine_operator_2">
        <source>Since '{0}' redefines operator '{1}', it should also redefine operator '{2}'</source>
        <target state="translated">Так как "{0}" переопределяет оператор "{1}", он должен переопределять и оператор "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_missing_operators">
        <source>Generate missing operators</source>
        <target state="translated">Создайте отсутствующие операторы</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">Переопределите object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnImplementingIEquatableCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">Переопределите object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsCodeActionTitle">
        <source>Override object.GetHashCode</source>
        <target state="translated">Переопределите object.GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeExceptionPublic">
        <source>Make exception public</source>
        <target state="translated">Сделайте исключение общим</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix1">
        <source>Make '{0}' protected.</source>
        <target state="translated">Сделайте "{0}" защищенным.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix2">
        <source>Change '{0}' to a public interface implementation.</source>
        <target state="translated">Измените "{0}" на реализацию общего интерфейса.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix3">
        <source>Make the containing type '{0}' sealed.</source>
        <target state="translated">Сделайте содержащий тип "{0}" запечатанным.</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypeIsNotStatic">
        <source>Type '{0}' is a static holder type but is neither static nor NotInheritable</source>
        <target state="translated">Тип "{0}" относится к статическим заполнителям, однако не является ни Static, ни NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypesShouldBeStaticOrNotInheritable">
        <source>Static holder types should be Static or NotInheritable</source>
        <target state="translated">Типы статических заполнителей должны быть Static или NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeClassStatic">
        <source>Make Class Static</source>
        <target state="translated">Сделайте класс статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsMessage">
        <source>Type {0} should override Equals because it implements IEquatable&lt;T&gt;</source>
        <target state="translated">Тип {0} должен переопределять Equals, так как он реализует IEquatable&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsTitle">
        <source>Override Object.Equals(object) when implementing IEquatable&lt;T&gt;</source>
        <target state="translated">Переопределите Object.Equals(object) при реализации IEquatable&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersDescription">
        <source>Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.</source>
        <target state="translated">Индексаторы, представляющие собой индексированные свойства, должны использовать для индекса целочисленные или строковые типы. Эти типы обычно используются для индексирования структур данных и расширяют возможности по использованию библиотеки. Тип Object разрешено использовать только в тех случаях, когда не удается задать определенный целочисленный или строковый тип во время разработки. Если для проектируемой структуры требуются другие типы индексов, перепроверьте, что тип представляет логическое хранилище данных. Если он этого не делает, используйте метод.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersMessage">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">Используйте целый или строковый аргумент для индексаторов</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersTitle">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">Используйте целый или строковый аргумент для индексаторов</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskDescription">
        <source>When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.</source>
        <target state="translated">Когда асинхронный метод непосредственно ожидает задачу, продолжение происходит в том же потоке, в котором была создана задача. Попробуйте вызвать Task.ConfigureAwait(Boolean), чтобы сообщить о том, что планируется продолжение. Вызовите ConfigureAwait(false) для задачи, чтобы запланировать продолжения для пула потоков, избежав таким образом взаимоблокировки в потоке пользовательского интерфейса. Передача значения false является хорошим вариантом для библиотек, независимых от приложений. Поведение при вызове ConfigureAwait(true) для задачи такое же, как при неявном вызове ConfigureAwait. При явном вызове этого метода вы сообщаете читателям, что вы намеренно хотите выполнить продолжение в исходном контексте синхронизации.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskMessage">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">Попробуйте вызвать ConfigureAwait для ожидаемой задачи</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskTitle">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">Попробуйте вызвать ConfigureAwait для ожидаемой задачи</target>
        <note />
      </trans-unit>
      <trans-unit id="AppendConfigureAwaitFalse">
        <source>Append .ConfigureAwait(false)</source>
        <target state="translated">Добавьте .ConfigureAwait(false)</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsDescription">
        <source>When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.</source>
        <target state="translated">Если тип T переопределяет Object.Equals(object), реализация должна привести аргумент object к правильному типу T перед выполнением сравнения. Если тип реализует IEquatable&lt;T&gt;и поэтому предоставляет метод T.Equals(T), а также известно, что этот аргумент во время компиляции имеет тип T, компилятор может вызывать IEquatable&lt;T&gt;.Equals(T) вместо Object.Equals(object) и приведение не требуется, что повышает производительность.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsDescription">
        <source>When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".</source>
        <target state="translated">Когда тип T реализует интерфейс IEquatable&lt;T&gt;, он предлагает пользователю, который видит вызов метода Equals в исходном коде, что экземпляр типа можно сравнить с экземпляром любого другого типа. Пользователь может быть озадачен, если его попытка сравнить этот тип с экземпляром другого типа не компилируется. Это нарушает "принцип наименьшего удивления".</target>
        <note />
      </trans-unit>
      <trans-unit id="RenameToTitle">
        <source>Rename to '{0}'</source>
        <target state="translated">Измените имя на "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsDescription">
        <source>A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</source>
        <target state="translated">Метод в базовом классе скрывается аналогично названным методом в производном типе, когда сигнатура параметра производного метода отличается только типами, которые унаследованы слабее, чем соответствующие типы в сигнатуре параметра базового метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsMessage">
        <source>Change or remove '{0}' because it hides a more specific base class method: '{1}'</source>
        <target state="translated">Измените или удалите "{0}", так как он скрывает более конкретный метод базового класса: "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsTitle">
        <source>Do not hide base class methods</source>
        <target state="translated">Не скрывайте методы базовых классов</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateMessage">
        <source>Remove '{0}' and replace its usage with a generic EventHandler, for example EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">Удалите "{0}" и замените его использование универсальным EventHandler, например EventHandler&lt;T&gt;, где T — это допустимый EventArgs.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateDescription">
        <source>A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый является объектом, а второй — типом, назначаемым для EventArgs), а содержащая сборка ориентирована на платформу Microsoft .NET Framework 2.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventMessage">
        <source>Change the event '{0}' to replace the type '{1}' with a generic EventHandler, for example EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">Измените событие "{0}", чтобы заменить тип "{1}" универсальным EventHandler, например EventHandler&lt;T&gt;, где T — это допустимый EventArgs.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventDescription">
        <source>A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.</source>
        <target state="translated">Делегат, который обрабатывает общедоступное или защищенное событие, имеет неверную сигнатуру, тип возвращаемого значения или имена параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Message">
        <source>Change the event '{0}' to use a generic EventHandler by defining the event type explicitly, for e.g. Event MyEvent As EventHandler(Of MyEventArgs).</source>
        <target state="translated">Измените событие "{0}" так, чтобы использовать универсальный обработчик событий, явно определив тип события. Например: Event MyEvent As EventHandler(Of MyEventArgs).</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Description">
        <source>A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">Тип содержит событие, которое объявляет делегат EventHandler. Этот делегат возвращает значение void, а его сигнатура содержит два параметра (первый является объектом, а второй — типом, назначаемым для EventArgs). Используемая сборка нацелена на платформу Microsoft .NET Framework 2.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageBoth">
        <source>{0} should define operator(s) '{1}' and Equals since it implements IComparable</source>
        <target state="translated">{0} должен определять операторы "{1}" и Equals, так как он реализует IComparable.</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixTitle">
        <source>Avoid using cref tags with a prefix</source>
        <target state="translated">Не используйте теги cref в префиксе</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixDescription">
        <source>Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax.</source>
        <target state="translated">Теги cref не следует использовать в префиксах, так как это мешает компилятору проверить ссылки, а интегрированной среде разработки — обновить их во время рефакторинга. Эту ошибку можно скрыть на отдельном сайте документации, если для cref нужен префикс, так как упомянутый тип не может быть найден компилятором. Например, если cref упоминает специальный атрибут в полной платформе, но вы работаете с файлом, который компилируется для переносимой платформы, или хотите сослаться на тип на более высоком уровне Roslyn, вам следует скрыть эту ошибку. Не следует скрывать эту ошибку, если вы хотите сократить объем работы и не использовать полный синтаксис.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixMessage">
        <source>Avoid using cref tags with a prefix</source>
        <target state="translated">Не используйте теги cref в префиксе</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">"{0}" всегда является "{1}". Удалите эти условия или выполните их рефакторинг, чтобы избежать появления неиспользуемого кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">"{0}" никогда не является "{1}". Удалите эти условия или выполните их рефакторинг, чтобы избежать появления неиспользуемого кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="translated">Предотвращение появления неиспользуемого условного кода</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">Это правило измеряет взаимозависимость классов посредством подсчета количества уникальных ссылок на типы, которые содержат символ. Символы, которые имеют высокую степень взаимозависимости классов, может быть трудно поддерживать. Рекомендуется иметь типы и методы, которые обладают низкой взаимозависимостью и высокой связностью. Чтобы устранить это нарушение, попробуйте реорганизовать код, чтобы уменьшить число типов, которые участвуют в формировании взаимозависимости.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">'{0}' связан с различными типами ('{1}') из различных пространств имен ('{2}'). Перепишите или оптимизируйте код, чтобы уменьшить степень взаимозависимости классов ниже '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">Избегать чрезмерной взаимозависимости классов</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">Цикломатическая сложность измеряет число линейно-независимых путей через метод, что определяется числом и сложностью условных ветвлений. Низкая цикломатическая сложность обычно указывает на метод, который легко понять, тестировать и обслуживать. Цикломатическая сложность вычисляется по графу потока управления по следующей формуле: "цикломатическая сложность = число краев – число узлов + 1", где узел представляет логическую точку ветвления, а край — линию между узлами.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">'{0}' имеет цикломатическую сложность '{1}'. Перепишите или оптимизируйте код, чтобы уменьшить его сложность ниже '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">Избегать чрезмерной сложности</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">Иерархии типов с высоким уровнем вложенности могут представлять сложности в понимании и поддержке. Это правило ограничивает анализ, включая в него только иерархии в том же модуле. Чтобы устранить нарушение этого правила, определите производный тип из базового типа с более низким уровнем вложенности в иерархии наследования или исключите некоторые из промежуточных базовых типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'.</source>
        <target state="translated">"{0}" имеет уровень вложенности иерархии "{1}" в определяющем модуле. Если возможно, исключите базовые классы из иерархии, чтобы уменьшить уровень вложенности иерархии ниже "{2}": "{3}"</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">Избегать чрезмерного наследования</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">Индекс удобства поддержки вычисляется с помощью следующих метрик: строк кода, объема программы и цикломатической сложности. Объем программы — это мера сложности понимания символа, основанная на количестве операторов и операндов в коде. Цикломатическая сложность — это мера структурной сложности типа или метода. Низкий индекс удобства поддержки означает, что код, скорее всего, сложно обслуживать, поэтому следует рассмотреть возможность его переработки.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">'{0}' имеет индекс удобства поддержки '{1}'. Перепишите или оптимизируйте код, чтобы уменьшить индекс удобства поддержки ниже '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">Разрешить неподдерживаемый код</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file.</source>
        <target state="translated">Недопустимая запись в файле спецификации правил метрик кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">Недопустимая запись '{0}' в файле спецификации правила метрик кода '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Недопустимая запись в файле спецификации правила метрик кода</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">Не игнорируйте результаты метода</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">Созданный объект не используется, вызван метод, создающий и возвращающий строку, которая не используется, либо метод COM или P/Invoke возвращает результат HRESULT или код ошибки, который не используется.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">{0} создает экземпляр {1}, который не используется. Передайте этот экземпляр в качестве аргумента другому методу, присвойте экземпляр переменной, или удалите создание объекта, если он не нужен.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">{0} вызывает {1}, но не использует новый экземпляр строки, возвращаемый методом. Передайте этот экземпляр в качестве аргумента другому методу, присвойте экземпляр переменной или удалите вызов, если он не нужен.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} вызывает {1}, но не использует HRESULT или код ошибки, возвращаемые методом. Это может привести к непредвиденному поведению при возникновении ошибок или нехватке ресурсов. Используйте результат в условном операторе, присвойте его переменной или передайте его в качестве аргумента другому методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">{0} вызывает {1}, но явно не проверяет успешность преобразования. Либо используйте возвращаемое значение в условном операторе, либо проверьте, что источник вызова предполагает, что при ошибке преобразования для аргумента out будет установлено значение по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">Избегайте внутренних классов, не имеющих экземпляры</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">В этой сборке код не создает экземпляр типа на уровне сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>'{0}' is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it 'static' (Module in Visual Basic).</source>
        <target state="translated">"{0}" является внутренним классом, экземпляр которого никогда не создается. Если это так, удалите код из сборки. Если этот класс должен содержать только статические элементы, сделайте его "статическим" (Module в Visual Basic).</target>
        <note>{Locked="Module"}</note>
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">Избегайте неиспользуемых частных полей</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">В сборке обнаружены частные поля, к которым не осуществляется доступ.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'</source>
        <target state="translated">Неиспользуемое поле "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} вызывает {1}, но не использует значение, возвращаемое методом. Так как {1} помечен как метод Pure, он не может иметь побочные эффекты. Используйте результат в условном операторе, присвойте его переменной или передайте его в качестве аргумента другому методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">Использование nameof позволяет обеспечить работоспособность кода при рефакторинге.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">Используйте nameof вместо строкового литерала "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">Используйте nameof для выражения имен символов</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself</source>
        <target state="translated">Свойство {0} запрещено назначать самому себе.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself</source>
        <target state="translated">Запрет назначения свойства самому себе</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">Сделать статическим</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">Не удалось исправить некоторые ссылки на "{0}". Их следует исправить вручную.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">Используйте литералы, когда это уместно</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at runtime.</source>
        <target state="translated">Поле объявлено как статическое и доступное только для чтения (Shared и ReadOnly в Visual Basic) и инициализировано с помощью значения, вычисляемого во время компиляции. Так как значение, присвоенное целевому полю, вычисляется во время компиляции, измените объявление на поле константы (Const в Visual Basic), чтобы значение вычислялось во время компиляции, а не во время выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">Поле "{0}" объявлено как "readonly", но инициализировано как константа. Вместо этого пометьте поле как "const".</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">Поле "{0}" объявлено как "readonly", но инициализировано как пустая строка (""). Вместо этого пометьте поле как "const".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Не делайте лишних инициализаций</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The .NET runtime initializes all fields of reference types to their default values before running the constructor. In most cases, explicitly initializing a field to its default value in a constructor is redundant, adding maintenance costs and potentially degrading performance (such as with increased assembly size), and the explicit initialization can be removed.  In some cases, such as with static readonly fields that permanently retain their default value, consider instead changing them to be constants or properties.</source>
        <target state="translated">Среда выполнения .NET инициализирует все поля ссылочных типов значениями по умолчанию перед запуском конструктора. В большинстве случаев явная инициализация поля значением по умолчанию в конструкторе является избыточной: в этом случае появляются затраты на обслуживание и может ухудшиться производительность (например, из-за увеличения размера сборки), а явная инициализация может быть удалена.  В некоторых случаях, например при использовании статических полей только для чтения, которые постоянно сохраняют значение по умолчанию, рекомендуется заменить их на константы или свойства.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Member '{0}' is explicitly initialized to its default value</source>
        <target state="translated">Элемент "{0}" явно инициализирован со значением по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">Используйте массивы массивов вместо многомерных массивов</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">Массив массивов состоит из массивов. Массивы, элементы которых могут иметь разный размер, позволяют экономнее расходовать место для нескольких наборов данных.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} является многомерным массивом. По возможности замените его массивом массивов.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} возвращает многомерный массив размером {1}. По возможности замените его массивом массивов.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} использует многомерный массив размером {1}. По возможности замените его массивом массивов.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">Пометьте члены как статические</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static. After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">Члены, которые не обращаются к данным экземпляров и не вызывают методы экземпляров, можно пометить как статические. После этого компилятор создаст невиртуальные места для вызова этих членов. Это может привести к ощутимому росту производительности для чувствительного к производительности кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member '{0}' does not access instance data and can be marked as static</source>
        <target state="translated">Член "{0}" не обращается к данным экземпляров, поэтому его можно пометить как статический.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Запечатайте методы, соответствующие частным интерфейсам</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">Наследуемый общий тип предоставляет переопределяемую реализацию метода для внутреннего интерфейса (Friend в Visual Basic). Чтобы устранить нарушение этого правила, предотвратите переопределение этого метода вне сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Запечатайте методы, соответствующие частным интерфейсам</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">Удалите пустые завершающие методы</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">Если возможно, следует избегать завершающих методов, чтобы исключить дополнительные издержки, связанные с отслеживанием времени существования объектов.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Не вызывайте переопределяемые методы в конструкторах</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">Виртуальные методы, определенные в классе, не следует вызывать из конструкторов. Если производный класс переопределил метод, будет вызвана версия производного класса (до вызова конструктора производного класса).</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information</source>
        <target state="translated">Повторное порождение перехваченного исключения изменяет сведения стека.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Повторно порождайте исключения для сохранения сведений стека</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">Сделайте объявляющий тип внутренним.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">Сделайте объявляющий тип запечатанным.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">Сделайте член непереопределяемым.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">Когда в предложении finally порождается исключение, новое исключение скрывает активное исключение. Это затрудняет обнаружение и отладку исходной ошибки.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause</source>
        <target state="translated">Не порождайте исключение изнутри предложения finally.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">Не порождайте исключения в предложениях finally</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">Измените на константу</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">При индексации элементов в инициализаторах объектов необходимо инициализировать уникальные элементы. Повторяющийся индекс может перезаписать предыдущую инициализацию элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>Redundant element initialization at index '{0}'. Object initializer has another element initializer with the same index that overwrites this value.</source>
        <target state="translated">Избыточная инициализация элемента с индексом "{0}". Инициализатор объекта содержит другой инициализатор элементов с тем же индексом, который перезаписывает это значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">Не повторяйте инициализацию индексируемых элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is 'null' ('Nothing' in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against 'null'. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">Видимый извне метод разыменовывает один из своих аргументов ссылки, не проверяя, имеет ли этот аргумент значение NULL (Nothing в Visual Basic). Все аргументы ссылки, передаваемые в видимые извне методы, следует проверять на значение NULL. При необходимости следует вызвать исключение ArgumentNullException, если аргумент равен NULL. Если метод предназначен для вызова только известными сборками, следует сделать его внутренним.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'.</source>
        <target state="translated">В видимом извне методе "{0}" перед использованием параметра "{1}" нужно убедиться, что его значение отличается от NULL. При необходимости следует вызвать исключение ArgumentNullException, если аргумент равен NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">Проверить аргументы или открытые методы</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>