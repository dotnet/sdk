<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../MicrosoftCodeQualityAnalyzersResources.resx">
    <body>
      <trans-unit id="AppendConfigureAwaitTrue">
        <source>Append .ConfigureAwait(true)</source>
        <target state="translated">Dołącz element .ConfigureAwait(true)</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementDescription">
        <source>Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements.</source>
        <target state="translated">Przypisywanie do symbolu i jego składowej (pole/właściwość) w tej samej instrukcji nie jest zalecane. W takiej sytuacji nie jest jasne, czy dostęp do składowej miał obejmować użycie starej wartości symbolu przed przypisaniem, czy nowej wartości z przypisania w tej instrukcji. W celu zachowania jednoznaczności rozważ rozdzielenie przypisań na oddzielne instrukcje.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementMessage">
        <source>Symbol '{0}' and its member '{1}' are both assigned in the same statement. You are at risk of assigning the member of an unintended object.</source>
        <target state="translated">Symbol „{0}” i jego składowa „{1}” są przypisane w tej samej instrukcji. Istnieje ryzyko przypisania składowej niezamierzonego obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementTitle">
        <source>Assigning symbol and its member in the same statement</source>
        <target state="translated">Przypisywanie symbolu i jego składowej w tej samej instrukcji</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesDescription">
        <source>The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</source>
        <target state="translated">Im więcej parametrów typu zawiera typ ogólny, tym trudniej jest dowiedzieć się zapamiętać, co reprezentuje każdy parametr typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesMessage">
        <source>Consider a design where '{0}' has no more than {1} type parameters</source>
        <target state="translated">Rozważ użycie projektu, w którym element „{0}” ma nie więcej niż następująca liczba parametrów typu: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveParametersOnGenericTypesTitle">
        <source>Avoid excessive parameters on generic types</source>
        <target state="translated">Unikaj nadmiernego użycia parametrów w typach ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionMessageMaybe">
        <source>Do not assign the property within its setter. This call might result in an infinite recursion.</source>
        <target state="translated">Nie przypisuj właściwości za pomocą jej metody ustawiającej. To wywołanie może spowodować nieskończoną rekursję.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionMessageSure">
        <source>Do not assign the property within its setter. This call will result in an infinite recursion.</source>
        <target state="translated">Nie przypisuj właściwości za pomocą jej metody ustawiającej. To wywołanie spowoduje nieskończoną rekursję.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidInfiniteRecursionTitle">
        <source>Avoid infinite recursion</source>
        <target state="translated">Unikaj nieskończonej rekursji</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndCodeFixTitle">
        <source>Remove redundant length argument</source>
        <target state="translated">Usuń argument długości nadmiarowej</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndDescription">
        <source>An explicit length calculation can be error-prone and can be avoided when slicing to end of the buffer.</source>
        <target state="translated">Wyraźne obliczenie długości może być podatne na błędy i można go uniknąć podczas wycinania do końca bufora.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndMessage">
        <source>'{0}' uses a redundant length calculation that can be removed</source>
        <target state="translated">„{0}” używa nadmiarowego obliczenia długości, które można usunąć</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidLengthCalculationWhenSlicingToEndTitle">
        <source>Avoid redundant length argument</source>
        <target state="translated">Unikaj argumentu długości nadmiarowej</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidMultipleEnumerationsMessage">
        <source>Possible multiple enumerations of 'IEnumerable' collection. Consider using an implementation that avoids multiple enumerations.</source>
        <target state="translated">Możliwe wielokrotne wyliczenia kolekcji „IEnumerable”. Rozważ użycie implementacji, która pozwala uniknąć wielu wyliczeń.</target>
        <note>{Locked="IEnumerable"}</note>
      </trans-unit>
      <trans-unit id="AvoidMultipleEnumerationsTitle">
        <source>Possible multiple enumerations of 'IEnumerable' collection</source>
        <target state="translated">Możliwe wielokrotne wyliczenia kolekcji „IEnumerable“</target>
        <note>{Locked="IEnumerable"}</note>
      </trans-unit>
      <trans-unit id="AvoidOutParametersDescription">
        <source>Passing types by reference (using 'out' or 'ref') requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between 'out' and 'ref' parameters is not widely understood.</source>
        <target state="translated">Przekazywanie typów przez odwołanie (zastosowanie parametrów „out” lub „ref”) wymaga doświadczenia w pracy ze wskaźnikami, rozumienia różnic między typami wartości i typami odwołań oraz umiejętności stosowania metod z wieloma wartościami zwracanymi. Ponadto różnice między parametrami „out” i „ref” nie są powszechnie zrozumiałe.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersMessage">
        <source>Avoid 'out' parameters as they are not designed for general audience</source>
        <target state="translated">Unikaj parametrów „out”, ponieważ nie są one przeznaczone dla wszystkich</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOutParametersTitle">
        <source>Avoid out parameters</source>
        <target state="translated">Unikaj parametrów out</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMultipleMessage">
        <source>Type '{0}' directly or indirectly inherits '{1}' without implementing any of '{2}'. Publicly-visible types should implement the generic version to broaden usability.</source>
        <target state="translated">Typ „{0}” bezpośrednio lub pośrednio dziedziczy element „{1}”, bez implementowania żadnego z elementów „{2}”. Typy widoczne publicznie powinny implementować wersję ogólną, aby zwiększyć użyteczność.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesDescription">
        <source>A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught.</source>
        <target state="translated">W instrukcji catch przechwycono wyjątek ogólny, taki jak System.Exception lub System.SystemException albo wyjątek niedozwolonego typu, lub jest używana ogólna klauzula catch. Wyjątki ogólne i niedozwolone nie powinny być przechwytywane.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesMessage">
        <source>Modify '{0}' to catch a more specific allowed exception type, or rethrow the exception</source>
        <target state="translated">Zmodyfikuj element „{0}”, aby przechwytywać dokładniej określony dozwolony typ wyjątku, lub ponownie zgłoś wyjątek</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesTitle">
        <source>Do not catch general exception types</source>
        <target state="translated">Nie przechwytuj ogólnych typów wyjątków</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesDescription">
        <source>Types declare protected members so that inheriting types can access or override the member. By definition, you cannot inherit from a sealed type, which means that protected methods on sealed types cannot be called.</source>
        <target state="translated">Typy deklarują chronione składowe, więc dziedziczące typy mogą uzyskać dostęp do składowej lub ją przesłonić. Zgodnie z definicją nie można dziedziczyć z zapieczętowanego typu, co oznacza, że nie można wywoływać chronionych metod w zapieczętowanych typach.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesMessage">
        <source>'{0}' is a new protected member in the 'NonInheritable' class '{1}'</source>
        <target state="translated">„{0}” to nowa chroniona składowa w klasie „NonInheritable” „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareProtectedMembersInSealedTypesTitle">
        <source>Do not declare protected member in sealed type</source>
        <target state="translated">Nie deklaruj chronionej składowej w zapieczętowanym typie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageLinqMethod">
        <source>'{0}' calls '{1}' but does not use the value the method returns. Linq methods are known to not have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">Element „{0}” wywołuje element „{1}”, ale nie używa wartości zwracanej przez metodę. Metody linq mają efekty uboczne. Użyj wyniku w instrukcji warunkowej, przypisz wynik do zmiennej lub przekaż go jako argument do innej metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageUserDefinedMethod">
        <source>'{0}' calls '{1}' but does not use the value the method returns. This method is defined as a user-option. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">Element „{0}” wywołuje element „{1}”, ale nie używa wartości zwracanej przez metodę. Ta metoda jest zdefiniowana jako opcja użytkownika. Użyj wyniku w instrukcji warunkowej, przypisz wynik do zmiennej lub przekaż go jako argument do innej metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyFix">
        <source>Remove the unnecessary assignment.</source>
        <target state="translated">Usuń niepotrzebne przypisanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedDescription">
        <source>This rule assumes that an enumeration member that has a name that contains "reserved" is not currently used but is a placeholder to be renamed or removed in a future version. Renaming or removing a member is a breaking change.</source>
        <target state="translated">W tej regule przyjęto założenie, że element członkowski wyliczenia, który ma nazwę zawierającą wyraz „reserved”, nie jest obecnie używany, ale jest symbolem zastępczym, którego nazwa może zostać zmieniona lub usunięta w przyszłej wersji. Zmiana nazwy lub usunięcie elementu członkowskiego jest zmianą powodującą niezgodność.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedMessage">
        <source>If '{0}.{1}' is not used in the current implementation, remove it. Otherwise give it a meaningful name.</source>
        <target state="translated">Jeśli element „{0}.{1}” nie jest używany w bieżącej implementacji, usuń go. W przeciwnym razie nadaj mu zrozumiałą nazwę.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNameEnumValuesReservedTitle">
        <source>Do not name enum values 'Reserved'</source>
        <target state="translated">Nie nadawaj wartościom wyliczeniowym nazwy Reserved</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsDescription">
        <source>System.Collections.Generic.List&lt;T&gt; is a generic collection that's designed for performance and not inheritance. List&lt;T&gt; does not contain virtual members that make it easier to change the behavior of an inherited class.</source>
        <target state="translated">System.Collections.Generic.List&lt;T&gt; to ogólna kolekcja zaprojektowana pod kątem wydajności, a nie dziedziczenia. Element List&lt;T&gt; nie zawiera wirtualnych składowych, które ułatwiają zmianę zachowania dziedziczonej klasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsMessage">
        <source>Change '{0}' in '{1}' to use 'Collection&lt;T&gt;', 'ReadOnlyCollection&lt;T&gt;' or 'KeyedCollection&lt;K,V&gt;'</source>
        <target state="translated">Zmień element „{0}” w „{1}”, aby użyć elementu „Collection&lt;T&gt;”, „ReadOnlyCollection&lt;T&gt;” lub „KeyedCollection&lt;K,V&gt;”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotExposeGenericListsTitle">
        <source>Do not expose generic lists</source>
        <target state="translated">Nie ujawniaj list ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualDescription">
        <source>Do not declare virtual events in a base class. Overridden events in a derived class have undefined behavior. The C# compiler does not handle this correctly and it is unpredictable whether a subscriber to the derived event will actually be subscribing to the base class event.</source>
        <target state="translated">Nie deklaruj zdarzeń wirtualnych w klasie bazowej. Przesłonięte zdarzenia w klasie pochodnej mają niezdefiniowane zachowanie. Kompilator języka C# nie obsługuje takiej sytuacji poprawnie i nie da się przewidzieć, czy subskrybent zdarzenia pochodnego w rzeczywistości będzie subskrybował zdarzenie klasy bazowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualMessage">
        <source>Event '{0}' should not be declared virtual</source>
        <target state="translated">Zdarzenie „{0}” nie powinno być zadeklarowane jako wirtualne</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareEventFieldsAsVirtualTitle">
        <source>Do not declare event fields as virtual</source>
        <target state="translated">Nie deklaruj pól zdarzeń jako wirtualnych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesDescription">
        <source>For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. If the operator is providing meaningful value equality, the type should implement the generic 'System.IEquatable' interface.</source>
        <target state="translated">W przypadku typów referencyjnych domyślna implementacja operatora równości jest prawie zawsze prawidłowa. Domyślnie dwa odwołania są równe tylko wtedy, gdy wskazują ten sam obiekt. Jeśli operator zapewnia istotną równość wartość, typ powinien implementować ogólny interfejs „System.IEquatable”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesMessage">
        <source>'{0}' should not overload the equality operator</source>
        <target state="translated">Element „{0}” nie powinien przeciążać operatora równości</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotOverloadOperatorEqualsOnReferenceTypesTitle">
        <source>Do not overload equality operator on reference types</source>
        <target state="translated">Nie przeciążaj operatora równości w typach referencyjnych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksDescription">
        <source>Unawaited tasks that use 'IDisposable' instances may use those instances long after they have been disposed. Ensure tasks using those instances are completed before the instances are disposed.</source>
        <target state="translated">Nieoczekiwane zadania używające wystąpień „IDisposable” mogą używać tych wystąpień długo po ich usunięciu. Przed usunięciem wystąpień upewnij się, że zadania korzystające z tych wystąpień zostały ukończone.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksMessage">
        <source>Ensure tasks using 'IDisposable' instances complete before the instances are disposed</source>
        <target state="translated">Upewnij się, że zadania używające wystąpień „IDisposable” zostały ukończone przed usunięciem wystąpień</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassDisposablesIntoUnawaitedTasksTitle">
        <source>Do not pass 'IDisposable' instances into unawaited tasks</source>
        <target state="translated">Nie przekazuj wystąpień „IDisposable” do zadań, które nie są oczekiwane</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceDescription">
        <source>Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Also, the difference between out and ref parameters is not widely understood.</source>
        <target state="translated">Przekazywanie typów przez odwołanie (zastosowanie parametrów „out” lub „ref”) wymaga doświadczenia w pracy ze wskaźnikami, rozumienia różnic między typami wartości i typami odwołań oraz umiejętności stosowania metod z wieloma wartościami zwracanymi. Ponadto różnice między parametrami „out” i „ref” nie są powszechnie zrozumiałe.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceMessage">
        <source>Consider a design that does not require that '{0}' be a reference parameter</source>
        <target state="translated">Rozważ użycie projektu, który nie wymaga, aby element „{0}” był parametrem w formie odwołania</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassTypesByReferenceTitle">
        <source>Do not pass types by reference</source>
        <target state="translated">Nie przekazuj typów przez referencję</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameDescription">
        <source>An enumeration's values should not start with the type name of the enumeration.</source>
        <target state="translated">Wartości wyliczenia nie powinny rozpoczynać się od nazwy typu wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameMessage">
        <source>Do not prefix enum values with the name of the enum type '{0}'</source>
        <target state="translated">Nie dodawaj do wartości wyliczenia prefiksu w postaci nazwy typu wyliczenia „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameTitle">
        <source>Do not prefix enum values with type name</source>
        <target state="translated">Nie dodawaj do wartości wyliczenia prefiksu w postaci nazwy typu</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesMessageDuplicatedBitwiseValuePart">
        <source>The field reference '{0}' is duplicated in this bitwise initialization</source>
        <target state="translated">Odwołanie do pola „{0}” jest zduplikowane w tym inicjowaniu bitowym</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesMessageDuplicatedValue">
        <source>The enum member '{0}' has the same constant value '{1}' as member '{2}'</source>
        <target state="translated">Składowa wyliczenia „{0}” ma tę samą stałą wartość „{1}” co składowa „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumShouldNotHaveDuplicatedValuesTitle">
        <source>Enums values should not be duplicated</source>
        <target state="translated">Wartości wyliczenia nie powinny być duplikowane</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixDescription">
        <source>Event names should describe the action that raises the event. To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions. For example, when naming a pair of events that is raised when closing a resource, you might name it 'Closing' and 'Closed', instead of 'BeforeClose' and 'AfterClose'.</source>
        <target state="translated">Nazwy zdarzeń powinny opisywać akcję, która wywołuje zdarzenie. Aby nazwać zdarzenia pokrewne, które są wywoływane w konkretnej kolejności, użyj czasu teraźniejszego lub przeszłego, aby wskazać względną pozycję w sekwencji akcji. Na przykład podczas nadawania nazw parze zdarzeń, które są wywoływane podczas zamykania zasobu, możesz nadać nazwy „Zamykanie” i „Zamknięto” zamiast „PrzedZamknięciem” i „PoZamknięciu”.</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixMessage">
        <source>Events should not have 'Before' or 'After' prefix</source>
        <target state="translated">Zdarzenia nie powinny mieć prefiksu „Przed” ani „Po”</target>
        <note />
      </trans-unit>
      <trans-unit id="EventsShouldNotHaveBeforeOrAfterPrefixTitle">
        <source>Events should not have 'Before' or 'After' prefix</source>
        <target state="translated">Zdarzenia nie powinny mieć prefiksu „Przed” ani „Po”</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageMultiple">
        <source>Rename {0} to end in either '{1}' or '{2}'</source>
        <target state="translated">Zmień nazwę {0}, aby kończyła się na „{1}” lub „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresCodeFixTitle">
        <source>Remove underscores</source>
        <target state="translated">Usuwanie podkreśleń</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeOverride">
        <source>Remove the finalizer from type '{0}', override Dispose(bool disposing), and put the finalization logic in the code path where 'disposing' is false. Otherwise, it might lead to duplicate Dispose invocations as the Base type '{1}' also provides a finalizer.</source>
        <target state="translated">Usuń finalizator z typu „{0}”, przesłoń funkcję Dispose(bool disposing) i umieść logikę finalizacji w ścieżce kodu, gdzie element „disposing” ma wartość false. W przeciwnym razie mogą pojawić się zduplikowane wywołania funkcji Dispose, ponieważ typ bazowy „{1}” także udostępnia finalizator.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringDescription">
        <source>The logging message template should not vary between calls.</source>
        <target state="translated">Szablon wiadomości rejestrowania nie powinien się różnić między wywołaniami.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringMessage">
        <source>The logging message template should not vary between calls to '{0}'</source>
        <target state="translated">Szablon wiadomości rejestrowania nie powinien się różnić między wywołaniami elementu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticConcatenationInFormatStringTitle">
        <source>Template should be a static expression</source>
        <target state="translated">Szablon powinien być wyrażeniem statycznym</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchDescription">
        <source>Number of parameters supplied in the logging message template do not match the number of named placeholders.</source>
        <target state="translated">Liczba parametrów podanych w szablonie wiadomości rejestrowania jest niezgodna z liczbą nazwanych symboli zastępczych.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchMessage">
        <source>Number of parameters supplied in the logging message template do not match the number of named placeholders</source>
        <target state="translated">Liczba parametrów podanych w szablonie wiadomości rejestrowania jest niezgodna z liczbą nazwanych symboli zastępczych</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticFormatParameterCountMismatchTitle">
        <source>Parameter count mismatch</source>
        <target state="translated">Niezgodność liczby parametrów</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchDescription">
        <source>The braces present in the message template are invalid. Ensure any braces in the message template are valid opening/closing braces, or are escaped.</source>
        <target state="translated">Nawiasy klamrowe obecne w szablonie komunikatu są nieprawidłowe. Upewnij się, że wszystkie nawiasy klamrowe w szablonie komunikatu są prawidłowymi nawiasami klamrowymi otwierającymi/zamykającymi lub że zostały zmienione.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchMessage">
        <source>The braces present in the message template are invalid</source>
        <target state="translated">Nawiasy klamrowe obecne w szablonie komunikatu są nieprawidłowe</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticMessageTemplateBracesMismatchTitle">
        <source>Invalid braces in message template</source>
        <target state="translated">Nieprawidłowe nawiasy klamrowe w szablonie wiadomości</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringDescription">
        <source>Named placeholders in the logging message template should not be comprised of only numeric characters.</source>
        <target state="translated">Nazwane symbole zastępcze w szablonie wiadomości rejestrowania nie powinny składać się tylko z samych cyfr.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringMessage">
        <source>Named placeholders in the logging message template should not be comprised of only numeric characters</source>
        <target state="translated">Nazwane symbole zastępcze w szablonie wiadomości rejestrowania nie powinny składać się tylko z samych cyfr</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticNumericsInFormatStringTitle">
        <source>Named placeholders should not be numeric values</source>
        <target state="translated">Nazwane symbole zastępcze nie powinny być wartościami liczbowymi</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesDescription">
        <source>For improved performance, use the LoggerMessage delegates.</source>
        <target state="translated">Aby zwiększyć wydajność, użyj delegatów LoggerMessage.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesMessage">
        <source>For improved performance, use the LoggerMessage delegates instead of calling '{0}'</source>
        <target state="translated">Aby zwiększyć wydajność, użyj delegatów LoggerMessage zamiast wywoływać metodę „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUseCompiledLogMessagesTitle">
        <source>Use the LoggerMessage delegates</source>
        <target state="translated">Użyj delegatów LoggerMessage</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensDescription">
        <source>Use PascalCase for named placeholders in the logging message template.</source>
        <target state="translated">Użyj formatu PascalCase dla nazwanych symboli zastępczych w szablonie wiadomości rejestrowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensMessage">
        <source>Use PascalCase for named placeholders in the logging message template</source>
        <target state="translated">Użyj formatu PascalCase dla nazwanych symboli zastępczych w szablonie wiadomości rejestrowania</target>
        <note />
      </trans-unit>
      <trans-unit id="LoggerMessageDiagnosticUsePascalCasedLogMessageTokensTitle">
        <source>Use PascalCase for named placeholders</source>
        <target state="translated">Używanie języka PascalCase dla nazwanych symboli zastępczych</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalCodeFixTitle">
        <source>Make the public type internal</source>
        <target state="translated">Ustaw typ publiczny jako wewnętrzny</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalDescription">
        <source>Unlike a class library, an application's API isn't typically referenced publicly, so types can be marked internal.</source>
        <target state="translated">W przeciwieństwie do biblioteki klas, interfejs API aplikacji nie jest zwykle przywoływany publicznie, więc typy mogą być oznaczone jako wewnętrzne.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalMessage">
        <source>Because an application's API isn't typically referenced from outside the assembly, types can be made internal</source>
        <target state="translated">Ze względu na to, że interfejs API aplikacji nie jest zwykle odwoływany spoza zespołu, typy mogą być wewnętrzne</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeTypesInternalTitle">
        <source>Consider making public types internal</source>
        <target state="translated">Rozważ wprowadzenie typów publicznych jako wewnętrznych</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageCodeFix">
        <source>Apply 'AttributeUsageAttribute'</source>
        <target state="translated">Zastosuj element „AttributeUsageAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesCodeFixTitle">
        <source>Add operator overload named alternate</source>
        <target state="translated">Dodawanie nazwanego elementu alternatywnego przeciążenia operatora</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveRedundantElementInitializationCodeFixTitle">
        <source>Remove redundant element initializer</source>
        <target state="translated">Usuń nadmiarowy inicjator elementów</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableTitle">
        <source>Types that own disposable fields should be disposable</source>
        <target state="translated">Typy zawierające pola możliwe do likwidacji powinny być możliwe do likwidacji</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableDescription">
        <source>A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</source>
        <target state="translated">Klasa deklaruje i implementuje pole wystąpienia typu System.IDisposable oraz nie implementuje interfejsu IDisposable. Klasa deklarująca pole IDisposable jest pośrednio właścicielem zasobu niezarządzanego i powinna implementować interfejs IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking">
        <source>Type '{0}' owns disposable field(s) '{1}' but is not disposable</source>
        <target state="translated">Typ „{0}” zawiera pola możliwe do likwidacji („{1}”), ale sam nie jest możliwy do likwidacji</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsCodeFixTitle">
        <source>Add 'System.Uri' overloads</source>
        <target state="translated">Dodaj przeciążenia 'System.Uri'</target>
        <note>{Locked="System.Uri"}</note>
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsDescription">
        <source>This rule detects usage of platform-specific intrinsics that can be replaced with an equivalent cross-platform intrinsic instead.</source>
        <target state="translated">Ta reguła wykrywa użycie funkcji wewnętrznych specyficznych dla platformy, które można zastąpić równoważną wewnętrzną funkcją międzyplatformową.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opAddition">
        <source>The addition operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator addition</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opBitwiseAnd">
        <source>The bitwise-and operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator bitwise-and</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opBitwiseOr">
        <source>The bitwise-or operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator bitwise-or</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opDivison">
        <source>The division operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator division</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opExclusiveOr">
        <source>The exclusive-or operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator exclusive-or</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opLeftShift">
        <source>The left-shift operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator left-shift</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opMultiply">
        <source>The multiply operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator multiply</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opOnesComplement">
        <source>The ones-complement operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator ones-complement</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opRightShift">
        <source>The right-shift operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator right-shift</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opSubtraction">
        <source>The subtraction operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator subtraction</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opUnaryNegation">
        <source>The unary-negation operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator unary-negation</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsMessage_opUnsignedRightShift">
        <source>The unsigned right-shift operator should be preferred</source>
        <target state="translated">Preferowany powinien być operator bez podpisu right-shift</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCrossPlatformIntrinsicsTitle">
        <source>Use cross-platform intrinsics</source>
        <target state="translated">Korzystanie z funkcji wewnętrznych międzyplatformowych</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesTitle">
        <source>Use generic event handler instances</source>
        <target state="translated">Używaj ogólnych wystąpień procedur obsługi zdarzeń</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueTitle">
        <source>Enums should have zero value</source>
        <target state="translated">Wyliczenia powinny mieć wartość zero</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueDescription">
        <source>The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.</source>
        <target state="translated">Wartość domyślna niezainicjowanego wyliczenia to zero, tak samo jak w przypadku innych typów. Wyliczenie bez atrybutu FlagsAttribute powinno definiować element członkowski za pomocą wartości zero, tak aby wartość domyślna była prawidłową wartością wyliczenia. Jeśli wyliczenie z zastosowanym atrybutem FlagsAttribute definiuje element członkowski o wartości zero, powinien on mieć nazwę „None”, co wskazuje, że w wyliczeniu nie ustawiono żadnych wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsRename">
        <source>In enum {0}, change the name of {1} to 'None'</source>
        <target state="translated">W wyliczeniu {0} zmień nazwę elementu {1} na „None”</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsMultipleZeros">
        <source>Remove all members that have the value zero from {0} except for one member that is named 'None'</source>
        <target state="translated">Usuń wszystkie składowe o wartości zero z wyliczenia {0}, z wyjątkiem jednej składowej o nazwie „None”</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue">
        <source>Add a member to {0} that has a value of zero with a suggested name of 'None'</source>
        <target state="translated">Dodaj składową o wartości zero do wyliczenia {0} z sugerowaną nazwą „None”</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsTitle">
        <source>Abstract types should not have public constructors</source>
        <target state="translated">Typy abstrakcyjne nie powinny mieć konstruktorów publicznych</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsDescription">
        <source>Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</source>
        <target state="translated">Konstruktory typów abstrakcyjnych mogą być wywoływane tylko przez typy pochodne. Konstruktory publiczne tworzą wystąpienia typu, ale nie można tworzyć wystąpień typu abstrakcyjnego, dlatego typ abstrakcyjny z konstruktorem publicznym jest niepoprawnie zaprojektowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsMessage">
        <source>Abstract type '{0}' should not have public constructors</source>
        <target state="translated">Typ abstrakcyjny „{0}” nie powinien mieć konstruktorów publicznych</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantTitle">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">Oznacz zestawy atrybutem CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantDescription">
        <source>The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.</source>
        <target state="translated">Specyfikacja CLS (Common Language Specification) definiuje ograniczenia nazewnictwa, typy danych i reguły, z którymi muszą być zgodne zestawy, jeśli będą używane z różnymi językami programowania. Reguły poprawnego projektowania nakazują, aby wszystkie zestawy jawnie deklarowały zgodność ze specyfikacją CLS za pomocą atrybutu CLSCompliantAttribute. Jeśli zestaw nie ma tego atrybutu, nie jest zgodny.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantMessage">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">Oznacz zestawy atrybutem CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionTitle">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">Oznacz zestawy za pomocą wersji zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionDescription">
        <source>The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.</source>
        <target state="translated">Program .NET Framework używa numeru wersji do unikatowego identyfikowania zestawu i tworzenia powiązań z typami w zestawach o silnej nazwie. Numer wersji jest używany w połączeniu z zasadami wersji i wydawcy. Domyślnie aplikacje działają tylko z wersją zestawu, dla której zostały skompilowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionMessage">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">Oznacz zestawy za pomocą wersji zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleTitle">
        <source>Mark assemblies with ComVisible</source>
        <target state="translated">Oznacz zestawy atrybutem ComVisible</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleDescription">
        <source>ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.</source>
        <target state="translated">Atrybut ComVisibleAttribute określa, w jaki sposób klienci modelu COM uzyskują dostęp do kodu zarządzanego. Zasady poprawnego projektowania nakazują, aby zestawy jawnie deklarowały widoczność modelu COM. Widoczność modelu COM można ustawić dla całego zestawu, a następnie przesłonić dla poszczególnych typów i elementów członkowskich typów. Jeśli nie ma tego atrybutu, zawartość zestawu jest widoczna dla klientów modelu COM.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageTitle">
        <source>Mark attributes with AttributeUsageAttribute</source>
        <target state="translated">Oznacz atrybuty za pomocą atrybutu AttributeUsageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageDefault">
        <source>Specify AttributeUsage on {0}</source>
        <target state="translated">Określ atrybut AttributeUsage dla elementu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsTitle">
        <source>Define accessors for attribute arguments</source>
        <target state="translated">Zdefiniuj metody dostępu dla argumentów atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageDefault">
        <source>Add a public read-only property accessor for positional argument {0} of Attribute {1}</source>
        <target state="translated">Dodaj publiczną metodę dostępu do właściwości tylko do odczytu dla argumentu pozycyjnego {0} atrybutu {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageRemoveSetter">
        <source>Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}</source>
        <target state="translated">Usuń metodę ustawiającą właściwość z argumentu {0} lub ogranicz jej dostępność, ponieważ odpowiada ona argumentowi pozycyjnemu {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility">
        <source>If {0} is the property accessor for positional argument {1}, make it public</source>
        <target state="translated">Jeśli {0} to metoda dostępu do właściwości dla argumentu pozycyjnego {1}, zadeklaruj ją jako publiczną</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateTitle">
        <source>Use properties where appropriate</source>
        <target state="translated">Użyj właściwości w odpowiednich miejscach</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateDescription">
        <source>A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.</source>
        <target state="translated">Metoda publiczna lub chroniona ma nazwę zaczynającą się od „Get”, nie pobiera parametrów i zwraca wartość, która nie jest tablicą. Ta metoda może być dobrym kandydatem na właściwość.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateMessage">
        <source>Use properties where appropriate</source>
        <target state="translated">Użyj właściwości w odpowiednich miejscach</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsTitle">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">Oznacz wyliczenia atrybutem FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsDescription">
        <source>An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</source>
        <target state="translated">Wyliczenie to typ wartości, który definiuje zestaw powiązanych stałych nazwanych. Zastosuj atrybut FlagsAttribute do wyliczenia, jeśli jego stałe nazwane można połączyć w znaczący sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsMessage">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">Oznacz wyliczenia atrybutem FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesTitle">
        <source>Interface methods should be callable by child types</source>
        <target state="translated">Typy podrzędne powinny móc wywoływać metody interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesDescription">
        <source>An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</source>
        <target state="translated">Niezapieczętowany typ widoczny zewnętrznie udostępnia jawną implementację metody interfejsu publicznego i nie udostępnia alternatywnej metody widocznej zewnętrznie o tej samej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesMessage">
        <source>Make '{0}' sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of '{1}' and is visible to derived classes</source>
        <target state="translated">Zapięczętuj element „{0}” (zmiana powodująca niezgodność, jeśli ta klasa została wcześniej dostarczona), wdróż metodę niejawnie lub wdróż nową metodę, która ujawnia funkcjonalność {1} i jest widoczna dla klas pochodnych</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesTitle">
        <source>Override methods on comparable types</source>
        <target state="translated">Przesłoń metody porównywalnych typów</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesDescription">
        <source>A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.</source>
        <target state="translated">Typ publiczny lub chroniony implementuje interfejs System.IComparable. Nie przesłania on metody Object.Equals ani nie przeciąża specyficznego dla języka operatora równości, nierówności, mniejszości, mniejszości lub równości, większości ani większości lub równości.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageEquals">
        <source>{0} should override Equals since it implements IComparable</source>
        <target state="translated">Typ {0} powinien przesłaniać metodę Equals, ponieważ implementuje interfejs IComparable</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageOperator">
        <source>{0} should define operator(s) '{1}' since it implements IComparable</source>
        <target state="translated">Typ {0} powinien definiować operatory „{1}”, ponieważ implementuje interfejs IComparable</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassTitle">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">Przenieś metody pinvoke do klasy metod natywnych</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassDescription">
        <source>Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</source>
        <target state="translated">Metody wywoływania platformy, takie jak metody oznaczone atrybutem System.Runtime.InteropServices.DllImportAttribute, lub metody zdefiniowane za pomocą słowa kluczowego Declare w języku Visual Basic uzyskują dostęp do kodu niezarządzanego. Te metody powinny należeć do klasy NativeMethods, SafeNativeMethods lub UnsafeNativeMethods.</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassMessage">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">Przenieś metody pinvoke do klasy metod natywnych</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseTitle">
        <source>Identifiers should differ by more than case</source>
        <target state="translated">Identyfikatory powinny różnić się nie tylko wielkością liter</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseDescription">
        <source>Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</source>
        <target state="translated">Identyfikatory przestrzeni nazw, typów, elementów członkowskich i parametrów nie mogą różnić się tylko wielkością liter, ponieważ języki docelowe środowiska uruchomieniowego języka wspólnego nie muszą rozróżniać wielkości liter.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseMessage">
        <source>Names of '{0}' and '{1}' should differ by more than case</source>
        <target state="translated">Nazwy elementów „{0}” i „{1}” powinny różnić się nie tylko wielkością liter</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixTitle">
        <source>Identifiers should have correct prefix</source>
        <target state="translated">Identyfikatory powinny mieć poprawny prefiks</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixDescription">
        <source>The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".</source>
        <target state="translated">Nazwa interfejsu widocznego zewnętrznie nie zaczyna się wielką literą „I”. Nazwa parametru typu ogólnego dla typu lub metody widocznych zewnętrznie nie zaczyna się wielką literą „T”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageInterface">
        <source>Prefix interface name {0} with 'I'</source>
        <target state="translated">Dodaj do nazwy interfejsu {0} prefiks „I”</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageTypeParameter">
        <source>Prefix generic type parameter name {0} with 'T'</source>
        <target state="translated">Dodaj do nazwy parametru typu ogólnego {0} prefiks „T”</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleTitle">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">Pola niebędące stałymi nie powinny być widoczne</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleDescription">
        <source>Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</source>
        <target state="translated">Pola statyczne, które nie są stałymi ani wartościami tylko do odczytu, nie są bezpieczne wątkowo. Dostęp do takiego pola musi być starannie kontrolowany i wymaga zaawansowanych technik programistycznych do synchronizowania dostępu do obiektu klasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleMessage">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">Pola niebędące stałymi nie powinny być widoczne</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsTitle">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">Nie oznaczaj wyliczeń atrybutem FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsDescription">
        <source>An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</source>
        <target state="translated">Wyliczenie widoczne zewnętrznie jest oznaczone atrybutem FlagsAttribute i ma co najmniej jedną wartość, która nie jest potęgą dwójki ani kombinacją innych wartości zdefiniowanych dla wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsMessage">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">Nie oznaczaj wyliczeń atrybutem FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesTitle">
        <source>Operator overloads have named alternates</source>
        <target state="translated">Przeciążenia operatora mają nazwane alternatywy</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesDescription">
        <source>An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</source>
        <target state="translated">Wykryto przeciążenie operatora i nie znaleziono oczekiwanej nazwanej metody alternatywnej. Nazwany alternatywny element członkowski udostępnia tę samą funkcjonalność co operator i jest udostępniany dla deweloperów programujących w językach, które nie obsługują przeciążonych operatorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageDefault">
        <source>Provide a method named '{0}' as a friendly alternate for operator {1}</source>
        <target state="translated">Określ metodę o nazwie „{0}” jako metodę alternatywną operatora {1} o przyjaznej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageProperty">
        <source>Provide a property named '{0}' as a friendly alternate for operator {1}</source>
        <target state="translated">Określ właściwość o nazwie „{0}” jako właściwość alternatywną operatora {1} o przyjaznej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageMultiple">
        <source>Provide a method named '{0}' or '{1}' as an alternate for operator {2}</source>
        <target state="translated">Określ metodę o nazwie „{0}” lub „{1}” jako metodę alternatywną operatora {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageVisibility">
        <source>Mark {0} as public because it is a friendly alternate for operator {1}</source>
        <target state="translated">Oznacz metodę {0} jako publiczną, ponieważ jest ona metodą alternatywną operatora {1} o przyjaznej nazwie</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsTitle">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">Operatory powinny mieć symetryczne przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsDescription">
        <source>A type implements the equality or inequality operator and does not implement the opposite operator.</source>
        <target state="translated">Typ implementuje operator równości lub nierówności i nie implementuje operatora przeciwnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyTitle">
        <source>Collection properties should be read only</source>
        <target state="translated">Właściwości kolekcji powinny być dostępne tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyDescription">
        <source>A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.</source>
        <target state="translated">Właściwość kolekcji dostępna do zapisu umożliwia użytkownikowi zamianę kolekcji na inną kolekcję. Właściwość tylko do odczytu uniemożliwia zastąpienie kolekcji, lecz nadal umożliwia ustawianie poszczególnych elementów członkowskich.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyMessage">
        <source>Change '{0}' to be read-only by removing the property setter</source>
        <target state="translated">Zmień element „{0}” w tylko do odczytu, usuwając metodę ustawiającą właściwości</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">Przeciąż operator równości przy przesłanianiu metody Equals dla typu wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription">
        <source>In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals.</source>
        <target state="translated">W większości języków programowania nie ma domyślnej implementacji operatora równości (==) dla typów wartości. Jeśli używasz języka programowania, który obsługuje przeciążanie operatorów, rozważ zaimplementowanie operatora równości. Jego zachowanie powinno być takie samo jak metody Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage">
        <source>Implement the equality operators and make their behavior identical to that of the Equals method</source>
        <target state="translated">Zaimplementuj operatory równości i ustaw ich zachowanie na identyczne z metodą Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsTitle">
        <source>Pass system uri objects instead of strings</source>
        <target state="translated">Przekazuj systemowe obiekty URI zamiast ciągów</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsDescription">
        <source>A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</source>
        <target state="translated">Wywołano metodę z parametrem ciągu o nazwie zawierającej ciąg „uri”, „URI”, „urn”, „URN”, „url” lub „URL”. Typ deklarujący metody zawiera odpowiednie przeciążenie metody z parametrem System.Uri.</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsMessage">
        <source>Modify '{0}' to call '{1}' instead of '{2}'</source>
        <target state="translated">Zmodyfikuj element „{0}” w celu wywoływania metody „{1}” zamiast „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsTitle">
        <source>Implement IEquatable when overriding Object.Equals</source>
        <target state="translated">Zaimplementuj interfejs IEquatable przy przesłanianiu metody Object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsMessage">
        <source>Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</source>
        <target state="translated">Typ {0} powinien implementować interfejs IEquatable&lt;T&gt;, ponieważ przesłania metodę Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastTitle">
        <source>CancellationToken parameters must come last</source>
        <target state="translated">Parametry CancellationToken muszą występować na końcu</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastMessage">
        <source>Method '{0}' should take CancellationToken as the last parameter</source>
        <target state="translated">Metoda „{0}” powinna pobierać wartość CancellationToken jako ostatni parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesTitle">
        <source>Identifier contains type name</source>
        <target state="translated">Identyfikator zawiera nazwę typu</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesDescription">
        <source>Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.</source>
        <target state="translated">Nazwy parametrów i elementów członkowskich powinny raczej określać ich znaczenie niż opisywać ich typ, który powinien być udostępniany przez narzędzia programistyczne. Jeśli jest konieczne użycie nazwy typu danych w nazwach elementów członkowskich, użyj nazwy niezależnej od języka zamiast nazwy specyficznej dla języka.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesMessage">
        <source>Identifier '{0}' contains type name</source>
        <target state="translated">Identyfikator „{0}” zawiera nazwę typu</target>
        <note />
      </trans-unit>
      <trans-unit id="CreatePropertyAccessorForParameter">
        <source>Create a property accessor.</source>
        <target state="translated">Utwórz metodę dostępu do właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeGetterPublic">
        <source>Make the getter of the property public</source>
        <target state="translated">Zadeklaruj metodę pobierającą właściwość jako publiczną</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeSetterNonPublic">
        <source>Make the setter of the property non-public</source>
        <target state="translated">Zadeklaruj metodę ustawiającą właściwość jako niepubliczną</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAssemblyLevelComVisibleFalse">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true)</source>
        <target state="translated">Ponieważ zestaw {0} udostępnia typy widoczne zewnętrznie, oznacz go atrybutem ComVisible(false) na poziomie zestawu, a następnie oznacz atrybutem ComVisible(true) wszystkie typy w zestawie, które powinny być dostępne dla klientów modelu COM</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeAssemblyLevelComVisibleToFalse">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level</source>
        <target state="translated">Rozważ zmianę atrybutu ComVisible dla zestawu {0} na wartość false i użycie wartości true na poziomie typów</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementComparable">
        <source>Implement Equality and Comparison methods and operators</source>
        <target state="translated">Zaimplementuj metody i operatory równości i porównania</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementEquatable">
        <source>Implement IEquatable</source>
        <target state="translated">Zaimplementuj interfejs IEquatable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableInterface">
        <source>Implement IDisposable Interface</source>
        <target state="translated">Zaimplementuj interfejs IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsCodeFix">
        <source>Remove FlagsAttribute from enum.</source>
        <target state="translated">Usuń atrybut FlagsAttribute z wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsCodeFix">
        <source>Apply FlagsAttribute to enum.</source>
        <target state="translated">Zastosuj atrybut FlagsAttribute do wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsMultipleZeroCodeFix">
        <source>Remove all members that have the value zero except for one member that is named 'None'.</source>
        <target state="translated">Usuń wszystkie elementy członkowskie o wartości zero z wyjątkiem elementu członkowskiego o nazwie „None”.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsRenameCodeFix">
        <source>Rename zero-valued enum field to 'None'.</source>
        <target state="translated">Zmień nazwę pola wyliczenia o wartości zero na „None”.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix">
        <source>Add a zero-valued member 'None' to enum.</source>
        <target state="translated">Dodaj element członkowski o wartości zero i nazwie „None” do wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHavePublicConstructorsCodeFix">
        <source>Change the accessibility of public constructors to protected.</source>
        <target state="translated">Zmień poziom dostępu do konstruktorów publicznych na chroniony.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesTitle">
        <source>Do not declare static members on generic types</source>
        <target state="translated">Nie deklaruj statycznych elementów członkowskich dla typów ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesDescription">
        <source>When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.</source>
        <target state="translated">Gdy jest wywoływany statyczny element członkowski typu ogólnego, dla tego typu musi być określony argument typu. Gdy jest wywoływany ogólny element członkowski wystąpienia nieobsługujący wnioskowania, dla tego elementu członkowskiego musi być określony argument typu. W tych dwóch przypadkach składnie określania argumentu typu są różne i można je łatwo pomylić.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesMessage">
        <source>Do not declare static members on generic types</source>
        <target state="translated">Nie deklaruj statycznych elementów członkowskich dla typów ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceTitle">
        <source>Generic interface should also be implemented</source>
        <target state="translated">Interfejs ogólny powinien być także zaimplementowany</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceDescription">
        <source>To broaden the usability of a type, implement one of the generic interfaces. This is especially true for collections as they can then be used to populate generic collection types.</source>
        <target state="translated">Aby rozszerzyć przydatność typu, zaimplementuj jeden z interfejsów ogólnych. Jest to szczególnie prawdziwe w przypadku kolekcji, które można następnie wykorzystać do wypełniania ogólnych typów kolekcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMessage">
        <source>Type '{0}' directly or indirectly inherits '{1}' without implementing '{2}'. Publicly-visible types should implement the generic version to broaden usability.</source>
        <target state="translated">Typ „{0}” bezpośrednio lub pośrednio dziedziczy element „{1}” bez implementowania elementu „{2}”. Typy widoczne publicznie powinny dziedziczyć wersję ogólną w celu rozszerzenia użyteczności.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Title">
        <source>Enum Storage should be Int32</source>
        <target state="translated">Wyliczenia powinny być przechowywane jako typ Int32</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Description">
        <source>An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.</source>
        <target state="translated">Wyliczenie to typ wartości, który definiuje zestaw powiązanych stałych nazwanych. Domyślnie do przechowywania wartości stałej jest używany typ danych System.Int32. Można zmienić ten typ bazowy, ale nie jest to wymagane ani zalecane w większości scenariuszy.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Message">
        <source>If possible, make the underlying type of {0} System.Int32 instead of {1}</source>
        <target state="translated">Jeśli to możliwe, zmień typ bazowy wyliczenia {0} na System.Int32 zamiast {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateTitle">
        <source>Use events where appropriate</source>
        <target state="translated">Użyj zdarzeń w odpowiednich miejscach</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateDescription">
        <source>This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.</source>
        <target state="translated">Ta reguła wykrywa metody z nazwami, które zwykle są używane dla zdarzeń. Jeśli metoda jest wywoływana w odpowiedzi na wyraźnie zdefiniowaną zmianę stanu, powinna być wywoływana przez procedurę obsługi zdarzeń. Obiekty wywołujące metodę powinny zgłaszać zdarzenia zamiast bezpośredniego wywoływania metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateMessage">
        <source>Consider making '{0}' an event</source>
        <target state="translated">Rozważ przekształcenie metody „{0}” w zdarzenie</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsTitle">
        <source>Implement standard exception constructors</source>
        <target state="translated">Zaimplementuj standardowe konstruktory wyjątku</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsDescription">
        <source>Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</source>
        <target state="translated">Jeśli pełny zestaw konstruktorów nie zostanie zdefiniowany, może to utrudnić poprawną obsługę wyjątków.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageMissingConstructor">
        <source>Add the following constructor to {0}: {1}</source>
        <target state="translated">Dodaj następujący konstruktor do elementu {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleTitle">
        <source>Nested types should not be visible</source>
        <target state="translated">Typy zagnieżdżone nie powinny być widoczne</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleDescription">
        <source>A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.</source>
        <target state="translated">Typ zagnieżdżony to typ zadeklarowany w zakresie innego typu. Typy zagnieżdżone są przydatne do hermetyzowania prywatnych szczegółów implementacji zawierającego typu. Typy zagnieżdżone użyte do tego celu nie powinny być widoczne zewnętrznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageDefault">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible.</source>
        <target state="translated">Nie zagnieżdżaj typu {0}. Możesz też zmienić jego dostępność tak, aby nie był widoczny zewnętrznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageVisualBasicModule">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module.</source>
        <target state="translated">Nie zagnieżdżaj typu {0}. Możesz też zmienić jego dostępność tak, aby nie był widoczny zewnętrznie. Jeśli ten typ jest zdefiniowany w module języka Visual Basic, będzie uznawany za typ zagnieżdżony przez inne języki .NET. W takim przypadku rozważ przeniesienie typu poza moduł.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesTitle">
        <source>Avoid empty interfaces</source>
        <target state="translated">Unikaj pustych interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesDescription">
        <source>Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</source>
        <target state="translated">Interfejsy definiują elementy członkowskie udostępniające kontrakt zachowania lub użycia. Funkcjonalność opisana przez interfejs może zostać zaadaptowana przez dowolny typ, niezależnie od miejsca występowania tego typu w hierarchii dziedziczenia. Typ implementuje interfejs przez udostępnienie implementacji dla elementów członkowskich interfejsu. Pusty interfejs nie definiuje żadnych elementów członkowskich, a zatem nie definiuje kontraktu, który można zaimplementować.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesMessage">
        <source>Avoid empty interfaces</source>
        <target state="translated">Unikaj pustych interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageTitle">
        <source>Provide ObsoleteAttribute message</source>
        <target state="translated">Określ komunikat dla atrybutu ObsoleteAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageDescription">
        <source>A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.</source>
        <target state="translated">Typ lub element członkowski jest oznaczony atrybutem System.ObsoleteAttribute, dla którego nie określono właściwości ObsoleteAttribute.Message. Gdy jest kompilowany typ lub element członkowski oznaczony atrybutem ObsoleteAttribute, wyświetlana jest właściwość Message atrybutu. Zapewnia to użytkownikowi informację o przestarzałym typie lub elemencie członkowskim.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageMessage">
        <source>Provide a message for the ObsoleteAttribute that marks {0} as Obsolete</source>
        <target state="translated">Określ komunikat dla atrybutu ObsoleteAttribute, który oznacza element {0} jako przestarzały</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyTitle">
        <source>Properties should not be write only</source>
        <target state="translated">Właściwości nie powinny być dostępne tylko do zapisu</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyDescription">
        <source>Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</source>
        <target state="translated">Używanie właściwości tylko do odczytu jest akceptowalne i często konieczne, ale zasady projektowania zakazują używania właściwości tylko do zapisu. Przyczyną jest to, że umożliwienie użytkownikowi ustawienia wartości, a następnie uniemożliwienie odczytywania tej wartości nie stanowi żadnego zabezpieczenia. Bez dostępu do odczytu nie można także odczytywać stanu obiektów udostępnionych, co ogranicza ich użyteczność.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageAddGetter">
        <source>Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method</source>
        <target state="translated">Ponieważ właściwość {0} jest właściwością tylko do zapisu, dodaj metodę pobierającą właściwość z dostępnością co najmniej taką samą lub większą niż jej metoda ustawiająca albo przekonwertuj tę właściwość na metodę</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible">
        <source>Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter</source>
        <target state="translated">Ponieważ metoda pobierająca właściwość {0} ma mniejszą widoczność niż jej metoda ustawiająca, zwiększ dostępność metody pobierającej lub zmniejsz dostępność metody ustawiającej</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesTitle">
        <source>Declare types in namespaces</source>
        <target state="translated">Zadeklaruj typy w przestrzeniach nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesDescription">
        <source>Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</source>
        <target state="translated">Typy są deklarowane w przestrzeniach nazw w celu uniknięcia kolizji nazw oraz jako sposób organizowania powiązanych typów w hierarchię obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesMessage">
        <source>Declare types in namespaces</source>
        <target state="translated">Zadeklaruj typy w przestrzeniach nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsTitle">
        <source>Do not declare visible instance fields</source>
        <target state="translated">Nie deklaruj widocznych pól wystąpień</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsDescription">
        <source>The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.</source>
        <target state="translated">Pole powinno być używane przede wszystkim jako szczegół implementacji. Pola powinny być prywatne lub wewnętrzne i powinny być udostępniane za pomocą właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsMessage">
        <source>Do not declare visible instance fields</source>
        <target state="translated">Nie deklaruj widocznych pól wystąpień</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsTitle">
        <source>URI-like parameters should not be strings</source>
        <target state="translated">Parametry z identyfikatorami URI nie powinny być ciągami</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsDescription">
        <source>This rule assumes that the parameter represents a Uniform Resource Identifier (URI). A string representation or a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. 'System.Uri' class provides these services in a safe and secure manner.</source>
        <target state="translated">W tej regule przyjęto, że parametr reprezentuje identyfikator URI (Uniform Resource Identifier). Reprezentacja identyfikatora URI w postaci ciągu jest narażona na błędy analizy i kodowania oraz może powodować luki w zabezpieczeniach. Klasa „System.Uri” udostępnia te usługi w bezpieczny sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsMessage">
        <source>Change the type of parameter '{0}' of method '{1}' from 'string' to 'System.Uri', or provide an overload to '{1}' that allows '{0}' to be passed as a 'System.Uri' object</source>
        <target state="translated">Zmień typ parametru „{0}” metody „{1}” ze „string” na „System.Uri” lub określ przeciążenie metody „{1}” umożliwiające przekazanie parametru „{0}” jako obiektu „System.Uri”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsTitle">
        <source>URI-like return values should not be strings</source>
        <target state="translated">Zwracane wartości z identyfikatorami URI nie powinny być ciągami</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsDescription">
        <source>This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">W tej regule przyjęto, że metoda zwraca identyfikator URI. Reprezentacja identyfikatora URI w postaci ciągu jest narażona na błędy analizy i kodowania oraz może powodować luki w zabezpieczeniach. Klasa System.Uri udostępnia te usługi w bezpieczny sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsMessage">
        <source>Change the return type of method '{0}' from 'string' to 'System.Uri'</source>
        <target state="translated">Zmień zwracany typ metody {0} ze „string” na „System.Uri”</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsTitle">
        <source>URI-like properties should not be strings</source>
        <target state="translated">Właściwości z identyfikatorami URI nie powinny być ciągami</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsDescription">
        <source>This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">W tej regule przyjęto, że właściwość reprezentuje identyfikator URI (Uniform Resource Identifier). Reprezentacja identyfikatora URI w postaci ciągu jest narażona na błędy analizy i kodowania oraz może powodować luki w zabezpieczeniach. Klasa System.Uri udostępnia te usługi w bezpieczny sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsMessage">
        <source>Change the type of property '{0}' from 'string' to 'System.Uri'</source>
        <target state="translated">Zmień typ właściwości {0} ze „string” na „System.Uri”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyTitle">
        <source>Implement IDisposable Correctly</source>
        <target state="translated">Zaimplementuj poprawnie interfejs IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyDescription">
        <source>All IDisposable types should implement the Dispose pattern correctly.</source>
        <target state="translated">Wszystkie typy IDisposable powinny poprawnie implementować wzorzec Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageIDisposableReimplementation">
        <source>Remove IDisposable from the list of interfaces implemented by '{0}' as it is already implemented by base type '{1}'</source>
        <target state="translated">Usuń interfejs IDisposable z listy interfejsów implementowanych przez element „{0}”, ponieważ jest on już implementowany przez typ bazowy „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeOverride">
        <source>Remove '{0}', override Dispose(bool disposing), and put the dispose logic in the code path where 'disposing' is true</source>
        <target state="translated">Usuń funkcję „{0}”, przesłoń funkcję Dispose(bool disposing) i umieść logikę usuwania w ścieżce kodu, gdzie element „disposing” ma wartość true</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeSignature">
        <source>Ensure that '{0}' is declared as public and sealed</source>
        <target state="translated">Upewnij się, że element „{0}” jest zadeklarowany jako public i sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageRenameDispose">
        <source>Rename '{0}' to 'Dispose' and ensure that it is declared as public and sealed</source>
        <target state="translated">Zmień nazwę elementu „{0}” na „Dispose” i upewnij się, że jest on zadeklarowany jako public i sealed</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeBoolSignature">
        <source>Ensure that '{0}' is declared as protected, virtual, and unsealed</source>
        <target state="translated">Upewnij się, że element „{0}” jest zadeklarowany jako protected, virtual i unsealed</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeImplementation">
        <source>Modify '{0}' so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance ('this' or 'Me' in Visual Basic), and then returns</source>
        <target state="translated">Zmodyfikuj element „{0}” tak, aby wywoływał funkcję Dispose(true), a następnie wywoływał funkcję GC.SuppressFinalize dla bieżącego wystąpienia obiektu („this” lub „Me” w języku Visual Basic), po czym wykonywał instrukcję return</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeImplementation">
        <source>Modify '{0}' so that it calls Dispose(false) and then returns</source>
        <target state="translated">Zmodyfikuj element „{0}” tak, aby wywoływał funkcję Dispose(false), a następnie wykonywał instrukcję return</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageProvideDisposeBool">
        <source>Provide an overridable implementation of Dispose(bool) on '{0}' or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources.</source>
        <target state="translated">Zapewnij możliwą do zastąpienia implementację funkcji Dispose(bool) dla elementu „{0}” lub oznacz typ jako sealed. Wywołanie funkcji Dispose(false) powinno czyścić tylko zasoby natywne. Wywołanie funkcji Dispose(true) powinno czyścić zasoby zarządzane i natywne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicTitle">
        <source>Exceptions should be public</source>
        <target state="translated">Wyjątki powinny być publiczne</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicDescription">
        <source>An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.</source>
        <target state="translated">Wyjątek wewnętrzny jest widoczny tylko wewnątrz własnego zakresu wewnętrznego. Gdy wyjątek zostanie przekazany poza zakres wewnętrzny, do przechwycenia tego wyjątku można użyć tylko wyjątku podstawowego. Jeśli wyjątek wewnętrzny jest dziedziczony z wyjątku T:System.Exception, T:System.SystemException lub T:System.ApplicationException, kod zewnętrzny nie będzie miał wystarczających informacji do określenia, co zrobić z wyjątkiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicMessage">
        <source>Exceptions should be public</source>
        <target state="translated">Wyjątki powinny być publiczne</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsTitle">
        <source>Do not raise exceptions in unexpected locations</source>
        <target state="translated">Nie zgłaszaj wyjątków w nieoczekiwanych lokalizacjach</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsDescription">
        <source>A method that is not expected to throw exceptions throws an exception.</source>
        <target state="translated">Wyjątek zgłasza metoda, od której nie oczekuje się zgłaszania wyjątków.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property's logic so that it no longer raises an exception.</source>
        <target state="translated">Właściwość {0} tworzy wyjątek typu {1}, który nie powinien być zgłaszany przez właściwość. Jeśli to wystąpienie wyjątku może zostać zgłoszone, użyj innego typu wyjątku, przekonwertuj tę właściwość na metodę lub zmień logikę tej właściwości tak, aby nie zgłaszała wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method's logic so that it no longer raises an exception.</source>
        <target state="translated">Metoda {0} tworzy wyjątek typu {1}, który nie powinien być zgłaszany przez metodę tego typu. Jeśli to wystąpienie wyjątku może zostać zgłoszone, użyj innego typu wyjątku lub zmień logikę tej metody tak, aby nie zgłaszała wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions">
        <source>{0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method's logic so it no longer raises an exception.</source>
        <target state="translated">Metoda {0} tworzy wyjątek typu {1}. Ten typ metody nie powinien zgłaszać wyjątków. Jeśli to wystąpienie wyjątku może zostać zgłoszone, zmień logikę tej metody tak, aby nie zgłaszała wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresTitle">
        <source>Identifiers should not contain underscores</source>
        <target state="translated">Identyfikatory nie powinny zawierać znaków podkreślenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresDescription">
        <source>By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.</source>
        <target state="translated">Według konwencji nazwy identyfikatorów nie powinny zawierać znaku podkreślenia (_). Ta reguła sprawdza przestrzenie nazw, typy, elementy członkowskie i parametry.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageAssembly">
        <source>Remove the underscores from assembly name {0}</source>
        <target state="translated">Usuń znaki podkreślenia z nazwy zestawu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageNamespace">
        <source>Remove the underscores from namespace name '{0}'</source>
        <target state="translated">Usuń znaki podkreślenia z nazwy przestrzeni nazw „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageType">
        <source>Remove the underscores from type name {0}</source>
        <target state="translated">Usuń znaki podkreślenia z nazwy typu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMember">
        <source>Remove the underscores from member name {0}</source>
        <target state="translated">Usuń znaki podkreślenia z nazwy składowej {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter">
        <source>On type {0}, remove the underscores from generic type parameter name {1}</source>
        <target state="translated">W typie {0} usuń znaki podkreślenia z nazwy parametru typu ogólnego {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter">
        <source>On method {0}, remove the underscores from generic type parameter name {1}</source>
        <target state="translated">W metodzie {0} usuń znaki podkreślenia z nazwy parametru typu ogólnego {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMemberParameter">
        <source>In member {0}, remove the underscores from parameter name {1}</source>
        <target state="translated">W składowej {0} usuń znaki podkreślenia z nazwy parametru {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageDelegateParameter">
        <source>In delegate {0}, remove the underscores from parameter name {1}</source>
        <target state="translated">W delegacie {0} usuń znaki podkreślenia z nazwy parametru {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixTitle">
        <source>Identifiers should have correct suffix</source>
        <target state="translated">Identyfikatory powinny mieć poprawny sufiks</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixDescription">
        <source>By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</source>
        <target state="translated">Według konwencji nazwy typów rozszerzających pewne typy podstawowe, implementujące pewne interfejsy lub pochodzące od tych typów mają sufiks skojarzony z podstawowym typem lub interfejsem.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageDefault">
        <source>Rename {0} to end in '{1}'</source>
        <target state="translated">Zmień nazwę elementu {0} tak, aby kończyła się sufiksem „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixTitle">
        <source>Identifiers should not have incorrect suffix</source>
        <target state="translated">Identyfikatory nie powinny mieć niepoprawnego sufiksu</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixDescription">
        <source>By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.</source>
        <target state="translated">Według konwencji tylko nazwy typów rozszerzających pewne typy podstawowe, implementujące pewne interfejsy lub pochodzące od tych typów powinny kończyć się określonymi zastrzeżonymi sufiksami. Inne nazwy typów nie powinny używać tych zastrzeżonych sufiksów.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate">
        <source>Rename type name {0} so that it does not end in '{1}'</source>
        <target state="translated">Zmień nazwę typu {0} tak, aby nie kończyła się sufiksem „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion">
        <source>Either replace the suffix '{0}' in member name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the member it replaces</source>
        <target state="translated">Zamień sufiks „{0}” w nazwie składowej {1} na zalecany alternatywny sufiks liczbowy „2” lub określ bardziej opisowy sufiks, który umożliwi odróżnienie go od zamienianej składowej</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion">
        <source>Either replace the suffix '{0}' in type name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the type it replaces</source>
        <target state="translated">Zamień sufiks „{0}” w nazwie typu {1} na zalecany alternatywny sufiks liczbowy „2” lub określ bardziej opisowy sufiks, który umożliwi odróżnienie go od zamienianego typu</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate">
        <source>Either replace the suffix '{0}' in member name '{1}' with the suggested alternate '{2}' or remove the suffix completely</source>
        <target state="translated">Zamień sufiks „{0}” w nazwie składowej „{1}” na zalecany alternatywny sufiks „{2}” lub całkowicie usuń sufiks</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsTitle">
        <source>Identifiers should not match keywords</source>
        <target state="translated">Identyfikatory nie powinny być takie same jak słowa kluczowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsDescription">
        <source>A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</source>
        <target state="translated">Nazwa przestrzeni nazw lub nazwa typu jest taka sama jak zastrzeżone słowo kluczowe języka programowania. Identyfikatory przestrzeni nazw i typów nie powinny być takie same jak słowa kluczowe zdefiniowane przez języki docelowe środowiska uruchomieniowego języka wspólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMemberParameter">
        <source>In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword '{2}'. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">W elemencie członkowskim interfejsu lub wirtualnym elemencie członkowskim {0} zmień nazwę parametru {1} tak, aby nie powodowała konfliktu z zastrzeżonym słowem kluczowym języka „{2}”. Użycie zastrzeżonego słowa kluczowego jako nazwy parametru w elemencie członkowskim interfejsu lub wirtualnym elemencie członkowskim utrudnia klientom w innych językach przesłonięcie/zaimplementowanie tego elementu członkowskiego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMember">
        <source>Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">Zmień nazwę elementu członkowskiego interfejsu lub wirtualnego elementu członkowskiego {0} tak, aby nie powodowała konfliktu z zastrzeżonym słowem kluczowym języka „{1}”. Użycie zastrzeżonego słowa kluczowego jako nazwy elementu członkowskiego interfejsu lub wirtualnego elementu członkowskiego utrudnia klientom w innych językach przesłonięcie/zaimplementowanie tego elementu członkowskiego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageType">
        <source>Rename type {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type.</source>
        <target state="translated">Zmień nazwę typu {0} tak, aby nie powodowała konfliktu z zastrzeżonym słowem kluczowym języka „{1}”. Użycie zastrzeżonego słowa kluczowego jako nazwy typu utrudnia klientom użycie tego typu w innych językach.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageNamespace">
        <source>Rename namespace {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace.</source>
        <target state="translated">Zmień nazwę przestrzeni nazw {0} tak, aby nie powodowała konfliktu z zastrzeżonym słowem kluczowym języka „{1}”. Użycie zastrzeżonego słowa kluczowego jako nazwy przestrzeni nazw utrudnia klientom użycie tej przestrzeni nazw w innych językach.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsTitle">
        <source>Property names should not match get methods</source>
        <target state="translated">Nazwy właściwości nie powinny być takie same jak nazwy metod pobierających</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsDescription">
        <source>The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.</source>
        <target state="translated">Nazwa publicznego lub chronionego elementu członkowskiego zaczyna się od „Get” i jest taka sama jak nazwa właściwości publicznej lub chronionej. Metody i właściwości „Get” powinny mieć nazwy jasno określające ich funkcję.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsMessage">
        <source>The property name '{0}' is confusing given the existence of method '{1}'. Rename or remove one of these members.</source>
        <target state="translated">Nazwa właściwości „{0}” jest myląca ze względu na istnienie metody „{1}”. Zmień nazwę jednego z tych elementów członkowskich lub usuń go.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesTitle">
        <source>Type names should not match namespaces</source>
        <target state="translated">Nazwy typów nie powinny być takie same jak przestrzenie nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesDescription">
        <source>Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.</source>
        <target state="translated">Nazwy typów nie powinny być takie same jak nazwy przestrzeni nazw zdefiniowane w bibliotece klas programu .NET Framework. Naruszenie tej reguły może zmniejszyć użyteczność biblioteki.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageDefault">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}'. Change either name to eliminate the conflict.</source>
        <target state="translated">Nazwa typu {0} powoduje konflikt w całości lub częściowo z nazwą przestrzeni nazw „{1}”. Zmień jedną z tych nazw, aby wyeliminować konflikt.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageSystem">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}' defined in the .NET Framework. Rename the type to eliminate the conflict.</source>
        <target state="translated">Nazwa typu {0} powoduje konflikt w całości lub częściowo z nazwą przestrzeni nazw „{1}” zdefiniowaną w programie .NET Framework. Zmień nazwę typu, aby wyeliminować konflikt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationTitle">
        <source>Parameter names should match base declaration</source>
        <target state="translated">Nazwy parametrów powinny być zgodne z deklaracją podstawową</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationDescription">
        <source>Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</source>
        <target state="translated">Spójne nazewnictwo parametrów w hierarchii przesłaniania zwiększa użyteczność przesłonięć metod. Nazwa parametru w metodzie pochodnej różniąca się od nazwy w deklaracji podstawowej może utrudnić zrozumienie tego, czy metoda przesłania metodę podstawową, czy jest jej nowym przeciążeniem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationMessage">
        <source>In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}</source>
        <target state="translated">W składowej {0} zmień nazwę parametru {1} na {2}, aby zapewnić zgodność z identyfikatorem zadeklarowanym w elemencie {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesTitle">
        <source>Override equals and operator equals on value types</source>
        <target state="translated">Przesłoń metodę Equals i operator równości w typach wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesDescription">
        <source>For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</source>
        <target state="translated">W przypadku typów wartości dziedziczona implementacja metody Equals używa biblioteki odbić i porównuje zawartość wszystkich pól. Odbicia wymagają kosztownych obliczeń, a porównywanie wszystkich pól pod kątem równości może być niepotrzebne. Jeśli oczekujesz, że użytkownicy będą porównywać lub sortować wystąpienia albo używać wystąpień jako kluczy tablicy skrótów, typ wartości powinien implementować metodę Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals">
        <source>{0} should override Equals</source>
        <target state="translated">Typ {0} powinien przesłaniać metodę Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality">
        <source>{0} should override the equality (==) and inequality (!=) operators</source>
        <target state="translated">Typ {0} powinien przesłaniać operatory równości (==) i nierówności (!=)</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysTitle">
        <source>Properties should not return arrays</source>
        <target state="translated">Właściwości nie powinny zwracać tablic</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysDescription">
        <source>Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.</source>
        <target state="translated">Tablice zwracane przez właściwości nie są chronione przed zapisem, nawet jeśli właściwość jest dostępna tylko do odczytu. Aby uniemożliwić naruszenie tablicy, właściwość musi zwracać jej kopię. Zazwyczaj użytkownicy nie rozumieją negatywnego wpływu na wydajność, jaki ma wywoływanie takiej właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysMessage">
        <source>Properties should not return arrays</source>
        <target state="translated">Właściwości nie powinny zwracać tablic</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsTitle">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">Przesłoń metodę GetHashCode przy przesłanianiu metody Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsDescription">
        <source>GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code.</source>
        <target state="translated">Metoda GetHashCode zwraca wartość na podstawie bieżącego wystąpienia, co jest przydatne na potrzeby algorytmów skrótu i struktur danych takich jak tablica skrótów. Dwa obiekty, które są tego samego typu i są równe, muszą zwracać ten sam kod skrótu.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsMessage">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">Przesłoń metodę GetHashCode przy przesłanianiu metody Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsTitle">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">Przesłoń metodę Equals przy przeciążaniu operatora równości</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsDescription">
        <source>A public type implements the equality operator but does not override Object.Equals.</source>
        <target state="translated">Typ publiczny implementuje operator równości, lecz nie przesłania metody Object.Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsMessage">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">Przesłoń metodę Equals przy przeciążaniu operatora równości</target>
        <note />
      </trans-unit>
      <trans-unit id="Since_0_redefines_operator_1_it_should_also_redefine_operator_2">
        <source>Since '{0}' redefines operator '{1}', it should also redefine operator '{2}'</source>
        <target state="translated">Ponieważ typ „{0}” definiuje ponownie operator „{1}”, powinien także definiować ponownie operator „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_missing_operators">
        <source>Generate missing operators</source>
        <target state="translated">Wygeneruj brakujące operatory</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">Przesłoń metodę object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnImplementingIEquatableCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">Przesłoń metodę object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsCodeActionTitle">
        <source>Override object.GetHashCode</source>
        <target state="translated">Przesłoń metodę object.GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeExceptionPublic">
        <source>Make exception public</source>
        <target state="translated">Zadeklaruj wyjątek jako publiczny</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix1">
        <source>Make '{0}' protected.</source>
        <target state="translated">Zadeklaruj element „{0}” jako chroniony.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix2">
        <source>Change '{0}' to a public interface implementation.</source>
        <target state="translated">Zmodyfikuj element „{0}” zgodnie z implementacją interfejsu publicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix3">
        <source>Make the containing type '{0}' sealed.</source>
        <target state="translated">Zapieczętuj typ zawierający „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypeIsNotStatic">
        <source>Type '{0}' is a static holder type but is neither static nor NotInheritable</source>
        <target state="translated">Typ „{0}” jest statycznym typem przechowującym, ale nie jest statyczny i nie ma modyfikatora NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypesShouldBeStaticOrNotInheritable">
        <source>Static holder types should be Static or NotInheritable</source>
        <target state="translated">Statyczne typy przechowujące powinny być zadeklarowane za pomocą modyfikatora Static lub NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeClassStatic">
        <source>Make Class Static</source>
        <target state="translated">Zadeklaruj klasę jako statyczną</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsMessage">
        <source>Type {0} should override Equals because it implements IEquatable&lt;T&gt;</source>
        <target state="translated">Typ {0} powinien przesłaniać metodę Equals, ponieważ implementuje interfejs IEquatable&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsTitle">
        <source>Override Object.Equals(object) when implementing IEquatable&lt;T&gt;</source>
        <target state="translated">Przesłoń metodę Object.Equals(object) przy implementowaniu interfejsu IEquatable&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersDescription">
        <source>Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.</source>
        <target state="translated">Indeksatory (tj. indeksowane właściwości) powinny używać typów całkowitoliczbowych lub ciągów na potrzeby indeksu. Te typy są zazwyczaj używane do indeksowania struktur danych i zwiększają użyteczność biblioteki. Użycie typu Object powinno być ograniczone do przypadków, w których konkretnego typu całkowitoliczbowego lub ciągu nie można określić podczas projektowania. Jeśli projekt wymaga użycia innych typów dla indeksu, rozważ ponownie, czy typ reprezentuje logiczny magazyn danych. Jeśli typ nie reprezentuje logicznego magazynu danych, użyj metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersMessage">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">Użyj argumentu całkowitoliczbowego lub ciągu dla indeksatorów</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersTitle">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">Użyj argumentu całkowitoliczbowego lub ciągu dla indeksatorów</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskDescription">
        <source>When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.</source>
        <target state="translated">Gdy metoda asynchroniczna oczekuje na zadanie bezpośrednio, kontynuowanie następuje w tym samym wątku, w którym utworzono zadanie. Rozważ wywołanie metody Task.ConfigureAwait(wartość logiczna), aby zasygnalizować zamiar kontynuowania. Wywołaj metodę ConfigureAwait(false) w zadaniu, aby zaplanować kontynuacje do puli wątków, co pozwoli uniknąć zakleszczenia wątku interfejsu użytkownika. Przekazywanie wartości false to dobra opcja dla bibliotek niezależnych od aplikacji. Wywoływanie metody ConfigureAwait(true) w zadaniu działa tak samo jak brak jawnego wywołania metody ConfigureAwait. Wywołując jawnie tę metodę, informujesz czytelników, że celowo zamierzasz kontynuować w pierwotnym kontekście synchronizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskMessage">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">Rozważ wywołanie metody ConfigureAwait w zadaniu, na które się oczekuje</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskTitle">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">Rozważ wywołanie metody ConfigureAwait w zadaniu, na które się oczekuje</target>
        <note />
      </trans-unit>
      <trans-unit id="AppendConfigureAwaitFalse">
        <source>Append .ConfigureAwait(false)</source>
        <target state="translated">Dołącz wywołanie .ConfigureAwait(false)</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsDescription">
        <source>When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.</source>
        <target state="translated">Gdy typ T przesłania metodę Object.Equals(object), implementacja musi rzutować obiekt będący argumentem na poprawny typ T przed wykonaniem porównania. Jeśli typ implementuje interfejs IEquatable&lt;T&gt;, a więc oferuje metodę T.Equals(T), i jeśli o argumencie wiadomo w chwili kompilacji, że jest typu T, kompilator może wywołać metodę IEquatable&lt;T&gt;.Equals(T) zamiast metody Object.Equals(object) bez konieczności wykonywania rzutowania, co poprawia wydajność.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsDescription">
        <source>When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".</source>
        <target state="translated">Gdy typ T implementuje interfejs IEquatable&lt;T&gt;, sugeruje użytkownikowi, który widzi wywołanie metody Equals w kodzie źródłowym, że wystąpienie typu może zostać porównane z wystąpieniem dowolnego innego typu. Użytkownik może być zdezorientowany, gdy jego próba skompilowania porównania typu z wystąpieniem innego typu nie powiedzie się. Jest to niezgodne z „zasadą najmniejszego zaskoczenia”.</target>
        <note />
      </trans-unit>
      <trans-unit id="RenameToTitle">
        <source>Rename to '{0}'</source>
        <target state="translated">Zmień nazwę na „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsDescription">
        <source>A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</source>
        <target state="translated">Metoda w typie podstawowym jest ukryta przez metodę o takiej samej nazwie w typie pochodnym, jeśli sygnatura parametrów metody pochodnej różni się tylko typami, które są wyżej w hierarchii dziedziczenia niż odpowiadające typy w sygnaturze parametrów metody podstawowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsMessage">
        <source>Change or remove '{0}' because it hides a more specific base class method: '{1}'</source>
        <target state="translated">Zmień lub usuń metodę „{0}”, ponieważ ukrywa ona bardziej wyspecjalizowaną metodę klasy podstawowej: „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsTitle">
        <source>Do not hide base class methods</source>
        <target state="translated">Nie ukrywaj metod klasy podstawowej</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateMessage">
        <source>Remove '{0}' and replace its usage with a generic EventHandler, for example EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">Usuń element „{0}” i zamień jego użycie na ogólną procedurę EventHandler, np. EventHandler&lt;T&gt;, gdzie T to prawidłowe argumenty zdarzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateDescription">
        <source>A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">Typ zawiera delegata zwracającego typ void, którego sygnatura zawiera dwa parametry (pierwszy jest obiektem, a drugi typem, który można przypisać do typu EventArgs), a zawierający zestaw jest przeznaczony dla programu Microsoft .NET Framework 2.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventMessage">
        <source>Change the event '{0}' to replace the type '{1}' with a generic EventHandler, for example EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">Zmień zdarzenie „{0}”, aby zamienić typ „{1}” na ogólną procedurę EventHandler, np. EventHandler&lt;T&gt;, gdzie T to prawidłowy element EventArgs</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventDescription">
        <source>A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.</source>
        <target state="translated">Delegat obsługujący publiczne lub chronione zdarzenie nie ma prawidłowej sygnatury, typu zwracanego lub nazw parametrów.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Message">
        <source>Change the event '{0}' to use a generic EventHandler by defining the event type explicitly, for e.g. Event MyEvent As EventHandler(Of MyEventArgs).</source>
        <target state="translated">Zmień zdarzenie „{0}”, aby użyć ogólnego elementu EventHandler, definiując jawnie typ zdarzenia, na przykład Event MyEvent As EventHandler(Of MyEventArgs).</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Description">
        <source>A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">Typ zawiera zdarzenie, które deklaruje delegata EventHandler zwracającego wartość void i ma sygnaturę zawierającą dwa parametry (pierwszy jest obiektem, a drugi typem z możliwością przypisania do elementu EventArgs) oraz zawiera zestaw przeznaczony dla platformy Microsoft .NET Framework?2.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageBoth">
        <source>{0} should define operator(s) '{1}' and Equals since it implements IComparable</source>
        <target state="translated">Typ {0} powinien definiować operatory „{1}” i metodę Equals, ponieważ implementuje interfejs IComparable</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixTitle">
        <source>Avoid using cref tags with a prefix</source>
        <target state="translated">Unikaj korzystania z tagów cref z prefiksem</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixDescription">
        <source>Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax.</source>
        <target state="translated">Należy unikać korzystania z tagów cref z prefiksami, ponieważ uniemożliwia to weryfikowanie odwołań przez kompilator oraz aktualizowanie odwołań przez środowisko IDE podczas refaktoryzacji. Można pominąć ten błąd w jednej witrynie dokumentacji, jeśli tag cref wymaga użycia prefiksu, ponieważ kompilator nie może odnaleźć wspomnianego typu. Jeśli na przykład w tagu cref podano specjalny atrybut w pełnej platformie, ale korzystasz z pliku kompilowanego w platformie przenośnej lub chcesz odwołać się do typu w wyższej warstwie programu Roslyn, należy pominąć ten błąd. Nie należy pomijać błędu, aby ułatwić sobie pracę i uniknąć użycia pełnej składni.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixMessage">
        <source>Avoid using cref tags with a prefix</source>
        <target state="translated">Unikaj korzystania z tagów cref z prefiksem</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">Element „{0}” ma zawsze wartość „{1}”. Usuń lub zrefaktoryzuj warunki w celu uniknięcia nieaktywnego kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">Element „{0}” nigdy nie ma wartości „{1}”. Usuń lub zrefaktoryzuj warunki w celu uniknięcia nieaktywnego kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="translated">Unikaj nieaktywnego kodu warunkowego</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">Ta reguła mierzy sprzężenie klas, licząc liczbę unikatowych odwołań do typów, które zawiera symbol. Symbole o wysokim stopniu sprzężenia klas mogą być trudne w utrzymaniu. Dobrym rozwiązaniem jest tworzenie typów i metod o niskim sprzężeniu i wysokiej spójności. Aby naprawić to naruszenie, przeprojektuj kod w celu zmniejszenia liczby typów, z którymi jest sprzężony.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">Element „{0}” jest sprzężony z „{1}” różnymi typami z „{2}” różnych przestrzeni nazw. Ponownie napisz kod lub refaktoryzuj go w taki sposób, aby sprzężenie klas było niższe niż „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">Unikaj nadmiernego sprzężenia klas</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">Złożoność cyklomatyczna mierzy liczbę liniowo niezależnych ścieżek prowadzących przez metodę, która jest określana przez liczbę i złożoność gałęzi warunkowych. Niska złożoność cyklomatyczna zwykle wskazuje metodę, którą łatwo zrozumieć, testować i utrzymywać. Złożoność cyklomatyczna jest obliczana na podstawie grafu przepływu sterowania metody i podawana w następujący sposób: złożoność cyklomatyczna = liczba granic - liczba węzłów + 1, gdzie węzeł reprezentuje rozgałęzienie logiki, a granica — linię między węzłami.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">Element „{0}” ma złożoność cyklomatyczną wynoszącą „{1}”. Ponownie napisz kod lub refaktoryzuj go w taki sposób, aby złożoność była niższa niż „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">Unikaj nadmiernej złożoności</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">Głęboko zagnieżdżone hierarchie typów mogą być trudne w zrozumieniu i utrzymaniu. Ta reguła ogranicza analizę do hierarchii w tym samym module. Aby naprawić naruszenie tej reguły, utwórz typ jako pochodny typu podstawowego o mniejszej głębokości w hierarchii dziedziczenia lub wyeliminuj niektóre pośrednie typy podstawowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'.</source>
        <target state="translated">Element „{0}” ma w definiującym module hierarchię obiektów o następującej liczbie poziomów głębokości: „{1}”. Jeśli to możliwe, wyeliminuj klasy podstawowe z hierarchii, aby obniżyć poziom hierarchii poniżej „{2}”: „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">Unikaj nadmiernego dziedziczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">Indeks dostępności jest obliczany przy użyciu następujących metryk: wiersze kodu, ilość programu i złożoność cyklomatyczna. Ilość programu to miara trudności w zrozumieniu symbolu oparta na liczbie operatorów i operandów w kodzie. Złożoność cyklomatyczna to miara złożoności strukturalnej typu lub metody. Niski indeks dostępności wskazuje kod, który jest prawdopodobnie trudny w konserwacji. Byłby to dobry kandydat do przeprojektowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">Element „{0}” ma indeks dostępności „{1}”. Ponownie napisz kod lub refaktoryzuj go w taki sposób, aby indeks dostępności był wyższy niż „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">Unikaj kodu trudnego w utrzymaniu</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file.</source>
        <target state="translated">Nieprawidłowy wpis w pliku specyfikacji reguły metryk kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">Nieprawidłowy wpis „{0}” w pliku specyfikacji reguły metryk kodu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Nieprawidłowy wpis w pliku specyfikacji reguły metryk kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">Nie ignoruj wyników metody</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">Nowy obiekt został utworzony, ale nigdy nie został użyty, została wywołana metoda tworząca i zwracająca nowy ciąg, a nowy ciąg nigdy nie został użyty lub metoda COM albo P/Invoke zwraca wartość HRESULT lub kod błędu, który nigdy nie został użyty.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">Element {0} tworzy nowe wystąpienie elementu {1}, które nigdy nie zostało użyte. Przekaż wystąpienie jako argument do innej metody, przypisz wystąpienie do zmiennej lub usuń tworzenie obiektu, jeśli jest zbędne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">Element {0} wywołuje element {1}, ale nie używa wystąpienia nowego ciągu zwracanego przez metodę. Przekaż wystąpienie jako argument do innej metody, przypisz wystąpienie do zmiennej lub usuń wywołanie, jeśli jest zbędne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">Element {0} wywołuje element {1}, ale nie używa wartości HRESULT ani kodu błędu zwracanego przez metodę. Może to doprowadzić do nieoczekiwanego zachowania w warunkach błędu lub sytuacjach małej ilości zasobów. Użyj wyniku w instrukcji warunkowej, przypisz wynik do zmiennej lub przekaż go jako argument do innej metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">Element {0} wywołuje element {1}, ale nie sprawdza jawnie, czy konwersja się udała. Użyj wartości zwracanej w instrukcji warunkowej lub zweryfikuj, czy lokacja wywołania oczekuje, że argument wychodzący zostanie ustawiony na wartość domyślną w razie niepowodzenia konwersji.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">Unikaj klas wewnętrznych bez wystąpień</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">Wystąpienie typu na poziomie zestawu nie zostało utworzone przez kod w zestawie.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>'{0}' is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it 'static' (Module in Visual Basic).</source>
        <target state="translated">Element „{0}” jest klasą wewnętrzną, która najwyraźniej nigdy nie miała wystąpień. Jeśli tak, usuń kod z zestawu. Jeśli ta klasa w założeniu ma zawierać tylko statyczne składowe, zmień ją na „statyczną” (Module w języku Visual Basic).</target>
        <note>{Locked="Module"}</note>
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">Unikaj nieużywanych pól prywatnych</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">Zostały wykryte pola prywatne, dostęp do których prawdopodobnie nie będzie występował w zestawie.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'</source>
        <target state="translated">Nieużywane pole „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">Element {0} wywołuje element {1}, ale nie używa wartości zwracanej przez metodę. Ponieważ metoda {1} jest oznaczona jako metoda Pure, nie może ona mieć efektów ubocznych. Użyj wyniku w instrukcji warunkowej, przypisz wynik do zmiennej lub przekaż go jako argument do innej metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">Korzystanie z operatora pomaga zachować poprawność kodu przy refaktoryzacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">Użyj operatora nameof zamiast literału ciągu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">Używaj operatora nameof, aby wyrażać nazwy symboli</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself</source>
        <target state="translated">Właściwość {0} nie powinna być przypisana do samej siebie</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself</source>
        <target state="translated">Nie przypisuj właściwości do jej samej</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">Ustaw jako statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">Nie można naprawić niektórych odwołań do „{0}”. Należy je naprawić ręcznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">Używaj literałów w odpowiednich miejscach</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at runtime.</source>
        <target state="translated">Pole zostało zadeklarowane jako statyczne i tylko do odczytu (Shared i ReadOnly w języku Visual Basic) i zainicjowane przy użyciu wartości obliczanych w czasie kompilacji. Ponieważ wartość przypisana do pola docelowego jest obliczana w czasie kompilacji, należy zmienić deklarację na pole wartości stałej (Const w języku Visual Basic), aby wartość była obliczana w czasie kompilacji, a nie w czasie wykonywania.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">Pole „{0}” zostało zadeklarowane jako „readonly”, ale zainicjowano je za pomocą wartości stałej. Zamiast tego oznacz to pole jako „const”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">Pole „{0}” zostało zadeklarowane jako „readonly”, ale zainicjowano je za pomocą pustego ciągu (""). Zamiast tego oznacz to pole jako „const”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Nie inicjuj niepotrzebnie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The .NET runtime initializes all fields of reference types to their default values before running the constructor. In most cases, explicitly initializing a field to its default value in a constructor is redundant, adding maintenance costs and potentially degrading performance (such as with increased assembly size), and the explicit initialization can be removed.  In some cases, such as with static readonly fields that permanently retain their default value, consider instead changing them to be constants or properties.</source>
        <target state="translated">Środowisko uruchomieniowe platformy .NET inicjuje wszystkie pola typów referencyjnych wartościami domyślnymi przed uruchomieniem konstruktora. W większości przypadków jawne zainicjowanie pola jego wartością domyślną w konstruktorze jest zbędne, powoduje dodanie kosztu związanego z konserwacją i potencjalnie obniża wydajność (np. zwiększa rozmiar zestawu), dlatego jawne inicjowanie można usunąć. W niektórych przypadkach, takich jak statyczne pola tylko do odczytu, które trwale zachowują swoje wartości domyślne, warto rozważyć ich zmianę na stałe lub właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Member '{0}' is explicitly initialized to its default value</source>
        <target state="translated">Składowa „{0}” jest jawnie inicjowana do wartości domyślnej</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">Wybieraj tablice nieregularne zamiast wielowymiarowych</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">Tablica nieregularna jest tablicą, której elementami są tablice. Tablice będące elementami mogą mieć różny rozmiar, co sprawia, że w przypadku niektórych zestawów danych marnowane jest mniej miejsca.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} jest tablicą wielowymiarową. Należy ją zastąpić tablicą nieregularną, jeśli to możliwe.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} zwraca tablicę wielowymiarową {1}. Należy ją zastąpić tablicą nieregularną, jeśli to możliwe.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} powoduje użycie tablicy wielowymiarowej {1}. Należy ją zastąpić tablicą nieregularną, jeśli to możliwe.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">Oznaczaj elementy członkowskie jako statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static. After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">Składowe, które nie uzyskują dostępu do danych wystąpienia ani nie wywołują metod wystąpienia, można oznaczyć jako statyczne. Po oznaczeniu metod jako statycznych kompilator będzie emitować niewirtualne miejsca wywołań do tych składowych. Może to spowodować wymierną poprawę wydajności kodu wrażliwego na zmiany wydajności.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member '{0}' does not access instance data and can be marked as static</source>
        <target state="translated">Składowa „{0}” nie uzyskuje dostępu do danych wystąpienia i może zostać oznaczona jako statyczna</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Pieczętuj metody, które spełniają wymagania interfejsów prywatnych</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">Typ publiczny podlegający dziedziczeniu zapewnia implementację metody z możliwością przesłonięcia interfejsu (Friend w języku Visual Basic). Aby naprawić naruszenie tej reguły, należy uniemożliwić przesłonięcie tej metody poza zespołem.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Pieczętuj metody, które spełniają wymagania interfejsów prywatnych</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">Usuwaj puste finalizatory</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">W miarę możliwości należy unikać finalizatorów, aby nie mnożyć czynników powodujących zmniejszenie wydajności związane ze śledzeniem czasu życia obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Nie wywołuj w konstruktorach metod, które można przesłaniać</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">Metody wirtualne zdefiniowane dla klasy nie powinny być wywoływane z konstruktorów. Jeśli klasa pochodna przesłoniła metodę, zostanie wywołana wersja klasy pochodnej (przed wywołaniem konstruktora klasy pochodnej).</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information</source>
        <target state="translated">Ponowne zgłoszenie przechwyconego wyjątku powoduje zmianę informacji o stosie</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Zgłoś ponownie wyjątek, aby zachować szczegóły stosu</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">Ustaw typ deklarujący jako wewnętrzny.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">Ustaw typ deklarujący jako zapieczętowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">Ustaw element członkowski jako niemożliwy do przesłonięcia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">Wyjątek zgłoszony z klauzuli finally ukrywa aktywny wyjątek. Utrudnia to wykrycie i zdebugowanie pierwotnego błędu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause</source>
        <target state="translated">Nie zgłaszaj wyjątku z klauzuli finally</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">Nie zgłaszaj wyjątków w klauzulach finally</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">Zmień na stałą</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">Indeksowane elementy w inicjatorach obiektów muszą inicjować unikatowe elementy. Zduplikowany indeks może powodować zastąpienie wcześniejszego zainicjowania elementu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>Redundant element initialization at index '{0}'. Object initializer has another element initializer with the same index that overwrites this value.</source>
        <target state="translated">Nadmiarowe inicjowanie elementu w indeksie „{0}”. Inicjator obiektów ma inny inicjator elementu z tym samym indeksem, który zastępuje tę wartość.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">Nie duplikuj inicjowania indeksowanych elementów</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is 'null' ('Nothing' in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against 'null'. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">Zewnętrznie widoczna metoda wyłuszcza jeden z argumentów odwołania bez sprawdzania, czy ten argument ma wartość „null” („Nothing” w języku Visual Basic). Wszystkie argumenty odwołania przekazywane do metod widocznych zewnętrznie powinny być sprawdzane pod kątem wartości „null”. W razie potrzeby zgłoś wyjątek „ArgumentNullException”, gdy argument ma wartość „null”. Jeśli metoda została zaprojektowana tak, aby była wywoływana tylko przez znane zestawy, należy ustawić metodę jako wewnętrzną.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'.</source>
        <target state="translated">W widocznej zewnętrznie metodzie „{0}” przed użyciem sprawdź, czy parametr „{1}” nie ma wartości null. W razie potrzeby zgłoś wyjątek „ArgumentNullException”, gdy argument ma wartość „null”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">Waliduj argumenty metod publicznych</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>