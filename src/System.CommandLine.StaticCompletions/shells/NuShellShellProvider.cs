// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.CodeDom.Compiler;
using System.CommandLine.Completions;
using System.CommandLine.StaticCompletions.Resources;
using System.Text;

namespace System.CommandLine.StaticCompletions.Shells;

public class NushellShellProvider : IShellProvider
{
    public string ArgumentName => ShellNames.Nushell;

    public string Extension => "nu";

    public string HelpDescription => Strings.NuShellShellProvider_HelpDescription;

    // override the ToString method to return the argument name so that CLI help is cleaner for 'default' values
    public override string ToString() => ArgumentName;

    public string GenerateCompletions(Command command)
    {
        var binaryName = command.Name;
        using var textWriter = new StringWriter { NewLine = "\n" };
        using var writer = new IndentedTextWriter(textWriter);

        // Collect all completers needed
        var completers = new Dictionary<string, CompletionItem[]>();
        var hasDynamic = CollectCompletersAndCheckDynamic([], command, completers);

        // Write header
        writer.WriteLine($"""
            # Static completion definitions for {binaryName}.
            # Generated by `dotnet completions script nushell`.

            # Place this file in one of the paths listed in $env.NU_LIB_DIRS
            # then `use` it in your config.nu or elsewhere.

            # For example, if ~/.config/nushell/lib is in your $env.NU_LIB_DIRS,
            # you could place this file as `dotnet-completions.nu` in the above
            # directory and then put the following line in your config.nu:
            # `use dotnet-completions.nu *`

            # Of course, the above assumes that your $env.NU_LIB_DIRS is
            # actually populated; refer to
            # <https://www.nushell.sh/book/configuration.html> if it isn't.

            # Alternatively, you can put this file wherever you want and `use`
            # the absolute path to the file:
            # `use /path/to/this/file.nu *`

            """);

        // Write dynamic completer if needed
        if (hasDynamic)
        {
            WriteDynamicCompleter(writer, binaryName);
        }

        // Write static completers for items with descriptions
        WriteStaticCompleters(writer, completers);

        // Write extern definitions
        WriteExternDefinitions(writer, binaryName, [], command, completers);

        writer.Flush();
        return textWriter.ToString();
    }

    /// <summary>
    /// Recursively collects all completers needed for options and arguments,
    /// and returns whether any dynamic symbols were found.
    /// </summary>
    private static bool CollectCompletersAndCheckDynamic(
        string[] parentPath,
        Command command,
        Dictionary<string, CompletionItem[]> completers)
    {
        var hasDynamic = false;
        string[] currentPath = parentPath.Length == 0
            ? [command.Name]
            : [..parentPath, command.Name];

        // Process options (use Options, not HierarchicalOptions, to avoid duplicates)
        foreach (var option in command.Options.Where(o => !o.Hidden))
        {
            if (option.IsDynamic)
            {
                hasDynamic = true;
                continue;
            }

            if (option.IsFlag())
            {
                continue;
            }

            var items = option.GetCompletions(CompletionContext.Empty).ToArray();
            if (items.Length > 0)
            {
                var name = CompleterName(currentPath, option.Name);
                completers.TryAdd(name, items);
            }
        }

        // Process arguments
        foreach (var argument in command.Arguments.Where(a => !a.Hidden))
        {
            if (argument.IsDynamic)
            {
                hasDynamic = true;
                continue;
            }

            var items = argument.GetCompletions(CompletionContext.Empty).ToArray();
            if (items.Length > 0)
            {
                var name = CompleterName(currentPath, argument.Name);
                completers.TryAdd(name, items);
            }
        }

        // Recurse into subcommands
        foreach (var sub in command.Subcommands.Where(c => !c.Hidden))
        {
            hasDynamic |= CollectCompletersAndCheckDynamic(currentPath, sub, completers);
        }

        return hasDynamic;
    }

    /// <summary>
    /// Generates a unique completer name based on command path and symbol name.
    /// </summary>
    private static string CompleterName(string[] commandPath, string symbolName)
    {
        return string.Join(' ', commandPath) + ' ' + symbolName;
    }

    /// <summary>
    /// Generates an inline completer array for completions.
    /// Returns simple array like ["value1", "value2"].
    /// Note: Inline completers don't support descriptions in NuShell.
    /// </summary>
    private static string GenerateInlineCompleter(CompletionItem[] items)
    {
        var values = items.Select(i => $"\"{SanitizeValue(i.InsertText ?? i.Label)}\"");
        return $"[{string.Join(' ', values)}]";
    }

    /// <summary>
    /// Returns true if any completion items have descriptions.
    /// </summary>
    private static bool HasDescriptions(CompletionItem[] items) =>
        items.Any(i => i.Documentation is not null || i.Detail is not null);

    /// <summary>
    /// Writes the dynamic completer function that calls back to the binary.
    /// </summary>
    private static void WriteDynamicCompleter(IndentedTextWriter writer, string binaryName)
    {
        writer.WriteLine("# Dynamic completion function");
        writer.WriteLine($"def \"nu-complete {binaryName}-dynamic\" [context: string] {{");
        writer.Indent++;
        writer.WriteLine($"^{binaryName} complete --position ($context | str length) $context | lines");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    /// <summary>
    /// Writes static completer functions for completions that have descriptions.
    /// Simple completions without descriptions are inlined directly.
    /// </summary>
    private static void WriteStaticCompleters(
        IndentedTextWriter writer,
        Dictionary<string, CompletionItem[]> completers)
    {
        foreach (var (name, items) in completers)
        {
            if (!HasDescriptions(items))
            {
                continue; // Simple completions are inlined
            }

            writer.WriteLine($"def \"{CompleterDefName(name)}\" [] {{");
            writer.Indent++;
            writer.WriteLine("[");
            writer.Indent++;
            foreach (var item in items)
            {
                var value = SanitizeValue(item.InsertText ?? item.Label);
                var desc = FirstSentence(SanitizeDescription(item.Documentation ?? item.Detail ?? item.Label));
                writer.WriteLine($"{{ value: \"{value}\" description: \"{desc}\" }}");
            }
            writer.Indent--;
            writer.WriteLine("]");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
        }
    }

    /// <summary>
    /// Generates a completer function name for static completions with descriptions.
    /// </summary>
    private static string CompleterDefName(string completerKey) =>
        $"nu-complete {completerKey}";

    /// <summary>
    /// Recursively writes extern definitions for a command and all its subcommands.
    /// </summary>
    private static void WriteExternDefinitions(
        IndentedTextWriter writer,
        string binaryName,
        string[] parentPath,
        Command command,
        Dictionary<string, CompletionItem[]> completers)
    {
        string[] currentPath = parentPath.Length == 0
            ? [command.Name]
            : [..parentPath, command.Name];

        var commandName = string.Join(' ', currentPath);

        // Write description comment if available (first sentence only)
        var description = command.Description is not null ? FirstSentence(command.Description) : null;
        if (!string.IsNullOrEmpty(description))
        {
            writer.WriteLine($"# {description}");
        }

        writer.WriteLine($"export extern \"{commandName}\" [");
        writer.Indent++;

        // Write positional arguments first
        foreach (var arg in command.Arguments.Where(a => !a.Hidden))
        {
            writer.WriteLine(GenerateArgumentParameter(arg, binaryName, currentPath, completers));
        }

        // Write options (including inherited recursive options)
        // Skip HelpOption - users can use `help <command>` for NuShell-formatted help
        // or --help/-? for native help
        foreach (var option in command.HierarchicalOptions().Where(o => o is not Help.HelpOption))
        {
            writer.WriteLine(GenerateOptionParameter(option, binaryName, currentPath, completers));
        }

        writer.Indent--;
        writer.WriteLine("]");
        writer.WriteLine();

        // Recurse for subcommands
        foreach (var sub in command.Subcommands.Where(c => !c.Hidden))
        {
            WriteExternDefinitions(writer, binaryName, currentPath, sub, completers);
        }
    }

    /// <summary>
    /// Finds the completer key for an option by searching the completers dictionary.
    /// For recursive options inherited from parent commands, this finds the key
    /// registered at the original command where the option was defined.
    /// </summary>
    private static string? FindCompleterKey(
        Option option,
        string[] commandPath,
        Dictionary<string, CompletionItem[]> completers)
    {
        // First try the current command path
        var directKey = CompleterName(commandPath, option.Name);
        if (completers.ContainsKey(directKey))
        {
            return directKey;
        }

        // For recursive options, search parent paths
        // Walk up the command path looking for where this option's completer was registered
        for (var i = commandPath.Length - 1; i >= 1; i--)
        {
            var parentPath = commandPath[..i];
            var parentKey = CompleterName(parentPath, option.Name);
            if (completers.ContainsKey(parentKey))
            {
                return parentKey;
            }
        }

        return null;
    }

    /// <summary>
    /// Generates a NuShell parameter definition for an option.
    /// </summary>
    private static string GenerateOptionParameter(
        Option option,
        string binaryName,
        string[] commandPath,
        Dictionary<string, CompletionItem[]> completers)
    {
        var sb = new StringBuilder();

        // Get primary name and aliases
        var (primary, aliases) = option.PrimaryNameAndAliases();
        var paramName = primary.TrimStart('-');

        // Build parameter name: --long(-s) or just --long
        if (aliases?.Any(a => a.IsShortAlias()) == true)
        {
            var shortAlias = aliases.First(a => a.IsShortAlias()).TrimStart('-');
            sb.Append($"--{paramName}(-{shortAlias})");
        }
        else
        {
            sb.Append($"--{paramName}");
        }

        // Add type annotation if not a flag
        if (!option.IsFlag())
        {
            var nushellType = MapToNushellType(option.ValueType) ?? "string";
            sb.Append($": {nushellType}");

            // Add completer reference if available
            if (option.IsDynamic)
            {
                sb.Append($"@\"nu-complete {binaryName}-dynamic\"");
            }
            else
            {
                var completerKey = FindCompleterKey(option, commandPath, completers);
                if (completerKey is not null && completers.TryGetValue(completerKey, out var items))
                {
                    if (HasDescriptions(items))
                    {
                        sb.Append($"@\"{CompleterDefName(completerKey)}\"");
                    }
                    else
                    {
                        sb.Append($"@{GenerateInlineCompleter(items)}");
                    }
                }
            }
        }

        // Add description as comment (first sentence only)
        if (!string.IsNullOrEmpty(option.Description))
        {
            sb.Append($" # {FirstSentence(option.Description)}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generates a NuShell parameter definition for an argument.
    /// </summary>
    private static string GenerateArgumentParameter(
        Argument argument,
        string binaryName,
        string[] commandPath,
        Dictionary<string, CompletionItem[]> completers)
    {
        var sb = new StringBuilder();

        // Handle variadic arguments
        var isVariadic = argument.Arity.MaximumNumberOfValues > 1;
        if (isVariadic)
        {
            sb.Append("...");
        }

        // Argument name - sanitize to be a valid NuShell identifier
        var argName = SanitizeArgumentName(argument.Name);
        sb.Append(argName);

        // Optional marker (but not for variadic arguments - spread params can't have ?)
        if (argument.Arity.MinimumNumberOfValues == 0 && !isVariadic)
        {
            sb.Append('?');
        }

        // Type annotation
        var nushellType = MapToNushellType(argument.ValueType) ?? "string";
        sb.Append($": {nushellType}");

        // Add completer reference if available
        if (argument.IsDynamic)
        {
            sb.Append($"@\"nu-complete {binaryName}-dynamic\"");
        }
        else
        {
            var completerKey = CompleterName(commandPath, argument.Name);
            if (completers.TryGetValue(completerKey, out var items))
            {
                if (HasDescriptions(items))
                {
                    sb.Append($"@\"{CompleterDefName(completerKey)}\"");
                }
                else
                {
                    sb.Append($"@{GenerateInlineCompleter(items)}");
                }
            }
        }

        // Add description as comment (first sentence only)
        if (!string.IsNullOrEmpty(argument.Description))
        {
            sb.Append($" # {FirstSentence(argument.Description)}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Maps .NET types to NuShell types.
    /// </summary>
    private static string? MapToNushellType(Type type)
    {
        // Handle nullable types
        var underlying = Nullable.GetUnderlyingType(type) ?? type;

        // Handle arrays and collections
        if (underlying.IsArray)
        {
            underlying = underlying.GetElementType() ?? typeof(string);
        }

        return underlying switch
        {
            _ when underlying == typeof(string) => "string",
            _ when underlying == typeof(int) => "int",
            _ when underlying == typeof(long) => "int",
            _ when underlying == typeof(short) => "int",
            _ when underlying == typeof(byte) => "int",
            _ when underlying == typeof(float) => "number",
            _ when underlying == typeof(double) => "number",
            _ when underlying == typeof(decimal) => "number",
            _ when underlying == typeof(bool) => null, // flags have no type
            _ when underlying == typeof(FileInfo) => "path",
            _ when underlying == typeof(DirectoryInfo) => "directory",
            _ => "string"
        };
    }

    /// <summary>
    /// Sanitizes an argument name to be a valid NuShell identifier.
    /// Converts complex names like "PROJECT | SOLUTION | FILE" to simple lowercase identifiers.
    /// </summary>
    private static string SanitizeArgumentName(string name)
    {
        // If name contains pipes or spaces, extract a simple word or use a generic name
        if (name.Contains('|') || name.Contains(' '))
        {
            // Try to find a simple word in the name (prefer "file", "path", "project", etc.)
            var parts = name.Split(['|', ' '], StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            foreach (var preferred in new[] { "FILE", "PATH", "PROJECT", "SOLUTION", "PACKAGE", "NAME" })
            {
                if (parts.Any(p => p.Equals(preferred, StringComparison.OrdinalIgnoreCase)))
                {
                    return preferred.ToLowerInvariant();
                }
            }
            // Fall back to first word if no preferred match
            if (parts.Length > 0)
            {
                return parts[0].ToLowerInvariant().Replace("-", "_");
            }
            return "arg";
        }

        // Simple name - just lowercase and replace dashes with underscores
        return name.ToLowerInvariant().Replace("-", "_");
    }

    /// <summary>
    /// Sanitizes a string for use in a NuShell string literal.
    /// </summary>
    private static string SanitizeValue(string? s) =>
        s?
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
        ?? "";

    /// <summary>
    /// Sanitizes a description for use in a NuShell string literal.
    /// </summary>
    private static string SanitizeDescription(string? s) =>
        s?
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .ReplaceLineEndings(" ")
        ?? "";

    /// <summary>
    /// Sanitizes a description for use in a NuShell comment.
    /// </summary>
    private static string SanitizeComment(string? s) =>
        s?
            .ReplaceLineEndings(" ")
            .Replace("\t", " ")
        ?? "";

    /// <summary>
    /// Returns the first sentence of a string (up to the first period, or first line if no period).
    /// Returns empty string if the first line ends with punctuation that indicates an incomplete thought.
    /// Strips trailing period for consistency.
    /// </summary>
    private static string FirstSentence(string s)
    {
        s = s.Trim();

        var lineEnd = s.IndexOfAny(['\r', '\n']);

        // Find sentence-ending period: ". " followed by uppercase letter (new sentence)
        // This avoids matching periods in acronyms like ".NET"
        var periodIdx = -1;
        for (var i = 0; i < s.Length - 2; i++)
        {
            if (s[i] == '.' && s[i + 1] == ' ' && char.IsUpper(s[i + 2]))
            {
                periodIdx = i;
                break;
            }
        }

        // If no sentence-ending period found, check for period at end of string
        if (periodIdx < 0 && s.EndsWith('.'))
        {
            periodIdx = s.Length - 1;
        }

        // Take whichever comes first: end of first sentence or end of first line
        if (periodIdx >= 0 && (lineEnd < 0 || periodIdx < lineEnd))
        {
            return s[..periodIdx]; // Exclude the period
        }

        // No sentence found - use first line if it doesn't end with incomplete punctuation
        var firstLine = (lineEnd < 0 ? s : s[..lineEnd]).TrimEnd();
        if (firstLine.Length > 0 && firstLine[^1] is ':' or ',' or ';')
        {
            return "";
        }

        // Strip trailing period from first line for consistency
        if (firstLine.EndsWith('.'))
        {
            return firstLine[..^1];
        }

        return firstLine;
    }
}
