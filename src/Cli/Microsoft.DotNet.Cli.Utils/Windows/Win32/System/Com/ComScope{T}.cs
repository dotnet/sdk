// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Runtime.CompilerServices;
using Windows.Win32.Foundation;

namespace Windows.Win32.System.Com;

/// <summary>
///  Lifetime management struct for a native COM pointer. Meant to be utilized in a <see langword="using"/> statement
///  to ensure <see cref="IUnknown.Release()"/> is called when going out of scope with the using.
/// </summary>
/// <remarks>
///  <para>
///   This struct has implicit conversions to T** and void** so it can be passed directly to out methods.
///   For example:
///  </para>
///  <code>
///   using ComScope&lt;IUnknown&gt; unknown = new(null);
///   comObject-&gt;QueryInterface(&amp;iid, unknown);
///  </code>
///  <para>
///   Take care to NOT make copies of the struct to avoid accidental over-release.
///  </para>
/// </remarks>
/// <typeparam name="T">
///  This should be one of the struct COM definitions as generated by CsWin32.
/// </typeparam>
internal readonly unsafe ref struct ComScope<T> where T : unmanaged, IComIID
{
    // Keeping internal as nint allows us to use Unsafe methods to get significantly better generated code.
    private readonly nint _value;

    /// <summary>
    ///  The pointer to the COM interface.
    /// </summary>
    public T* Pointer => (T*)_value;

    /// <summary>
    ///  Initializes a new instance of the <see cref="ComScope{T}"/> struct.
    /// </summary>
    public ComScope(T* value) => _value = (nint)value;

    /// <summary>
    ///  Initializes a new instance of the <see cref="ComScope{T}"/> struct with a void pointer.
    /// </summary>
    public ComScope(void* value) => _value = (nint)value;

    /// <summary>
    ///  Implicit conversion from <see cref="ComScope{T}"/> to a <typeparamref name="T"/> pointer.
    /// </summary>
    public static implicit operator T*(in ComScope<T> scope) => (T*)scope._value;

    /// <summary>
    ///  Implicit conversion from <see cref="ComScope{T}"/> to a void pointer.
    /// </summary>
    public static implicit operator void*(in ComScope<T> scope) => (void*)scope._value;

    /// <summary>
    ///  Implicit conversion from <see cref="ComScope{T}"/> to a <see cref="nint"/> pointer.
    /// </summary>
    public static implicit operator nint(in ComScope<T> scope) => scope._value;

    /// <summary>
    ///  Implicit conversion from <see cref="ComScope{T}"/> to a <typeparamref name="T"/> pointer pointer (T**).
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator T**(in ComScope<T> scope) => (T**)Unsafe.AsPointer(ref Unsafe.AsRef(in scope._value));

    /// <summary>
    ///  Implicit conversion from <see cref="ComScope{T}"/> to a void pointer pointer (void**).
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator void**(in ComScope<T> scope) => (void**)Unsafe.AsPointer(ref Unsafe.AsRef(in scope._value));

    /// <summary>
    ///  <see langword="true"/> if the pointer is null.
    /// </summary>
    public bool IsNull => _value == 0;

    /// <summary>
    ///  Tries to query the interface for the given <typeparamref name="TInterface"/>. Throws if unsuccessful.
    /// </summary>
    public ComScope<TInterface> QueryInterface<TInterface>() where TInterface : unmanaged, IComIID
    {
        ComScope<TInterface> scope = TryQueryInterface<TInterface>(out HRESULT hr);
        hr.ThrowOnFailure();
        return scope;
    }

    /// <summary>
    ///  Tries to query the interface for the given <typeparamref name="TInterface"/>.
    ///  Returns the result in the <paramref name="result"/> parameter.
    /// </summary>
    public ComScope<TInterface> TryQueryInterface<TInterface>(out HRESULT result) where TInterface : unmanaged, IComIID
    {
        Guid iid = IID.Get<TInterface>();
        ComScope<TInterface> scope = new(null);
        result = ((IUnknown*)Pointer)->QueryInterface(&iid, scope);
        return scope;
    }

    /// <inheritdoc cref="IDisposable.Dispose"/>
    public void Dispose()
    {
        IUnknown* unknown = (IUnknown*)_value;

        // Really want this to be null after disposal to avoid double releases, but we also want
        // to maintain the readonly state of the struct to allow passing as `in` without creating implicit
        // copies (which would break the T** and void** operators).
        *(void**)this = null;
        if (unknown is not null)
        {
            unknown->Release();
        }
    }
}
