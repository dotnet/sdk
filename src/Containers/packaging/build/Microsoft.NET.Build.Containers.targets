<Project>
  <PropertyGroup>
    <_IsSDKContainerAllowedVersion>false</_IsSDKContainerAllowedVersion>
    <!-- Anything newer than 7.0.100-preview.7 is supported -->
    <_IsSDKContainerAllowedVersion
        Condition="$([MSBuild]::VersionGreaterThan($(NetCoreSdkVersion), 7.0.100))
                       OR ( $([MSBuild]::VersionEquals($(NetCoreSdkVersion), 7.0.100))
                            AND (
                                 $(NETCoreSdkVersion.Contains('-preview.7'))
                                 OR $(NETCoreSdkVersion.Contains('-rc'))
                                 OR $(NETCoreSdkVersion.Contains('-')) == false
                                )
                          )">true</_IsSDKContainerAllowedVersion>
    <_ContainerIsTargetingNet8TFM>false</_ContainerIsTargetingNet8TFM>
    <_ContainerIsTargetingNet8TFM Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '8.0'))">true</_ContainerIsTargetingNet8TFM>
    <_ContainerIsSelfContained>false</_ContainerIsSelfContained>
    <_ContainerIsSelfContained Condition="'$(SelfContained)' == 'true' or '$(PublishSelfContained)' == 'true'">true</_ContainerIsSelfContained>

    <EnableSdkContainerSupport Condition="'$(EnableSdkContainerSupport)' == '' and '$(OutputType)' != 'Library'" >true</EnableSdkContainerSupport>
    <ContainerContentStoreRoot Condition="'$(ContainerContentStoreRoot)' == ''">$([System.IO.Path]::GetTempPath())</ContainerContentStoreRoot>
  </PropertyGroup>

  <ItemGroup>
    <ProjectCapability Include="NetSdkOCIImageBuild" />
  </ItemGroup>

  <Target Name="_ContainerVerifySDKVersion"
      Condition="'$(WebPublishMethod)' == 'Container' or '$(PublishProfile)' == 'DefaultContainer'"
      BeforeTargets="AfterPublish">
    <!-- If the user has opted into container publishing via their own profile (WebPublishMethod = Container) or
            via the default Profile (PublishProfile = DefaultContainer), make sure they're on a supported SDK version.
            We do the explicit profile name check here because for preview6 for example the profile didn't exist, so we
            can't rely only on the WebPublishMethod. -->
    <Error Condition="'$(_IsSDKContainerAllowedVersion)' != 'true'" Code="CONTAINER002" Text="The current .NET SDK ($(NETCoreSdkVersion)) doesn't support containerization. Please use version 7.0.100 or higher to enable containerization." />
  </Target>

  <Target Name="ComputeContainerBaseImage"
          Returns="$(ContainerBaseImage)">
    <PropertyGroup>
      <!-- The Container RID should default to the RID used for the entire build (to ensure things run on the platform they are built for), but the user knows best and so should be able to set it explicitly.
           For builds that have a RID, we default to that RID. Otherwise, we default to the Linux RID matching the architecture of the currently-executing SDK. -->
      <ContainerRuntimeIdentifier Condition="'$(ContainerRuntimeIdentifier)' == '' and '$(RuntimeIdentifier)' != ''">$(RuntimeIdentifier)</ContainerRuntimeIdentifier>
      <ContainerRuntimeIdentifiers Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(ContainerRuntimeIdentifiers)' == '' and '$(IsRidAgnostic)' != 'true'">$(RuntimeIdentifiers)</ContainerRuntimeIdentifiers>
      <ContainerRuntimeIdentifier Condition="'$(ContainerRuntimeIdentifier)' == '' and '$(ContainerRuntimeIdentifiers)' == ''">linux-$(NETCoreSdkPortableRuntimeIdentifier.Split('-')[1])</ContainerRuntimeIdentifier>
      <!-- We want to save customer provided ContainerBaseImage to later set ContainerUser. -->
      <_InitialContainerBaseImage>$(ContainerBaseImage)</_InitialContainerBaseImage>
    </PropertyGroup>

    <ItemGroup>
      <_TargetRuntimeIdentifiers Include="$(ContainerRuntimeIdentifier)" Condition="'$(ContainerRuntimeIdentifier)' != ''" />
      <_TargetRuntimeIdentifiers Include="$(ContainerRuntimeIdentifiers)" Condition="@(_TargetRuntimeIdentifiers->Count()) == 0" />
    </ItemGroup>

    <ComputeDotnetBaseImageAndTag
      UserBaseImage="$(ContainerBaseImage)"
      SdkVersion="$(NetCoreSdkVersion)"
      TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV).0"
      FrameworkReferences="@(FrameworkReference)"
      IsSelfContained="$(_ContainerIsSelfContained)"
      IsAotPublished="$(PublishAot)"
      IsTrimmed="$(PublishTrimmed)"
      UsesInvariantGlobalization="$(InvariantGlobalization)"
      TargetRuntimeIdentifiers="@(_TargetRuntimeIdentifiers)"
      ContainerFamily="$(ContainerFamily)">
        <Output TaskParameter="ComputedContainerBaseImage" PropertyName="ContainerBaseImage" />
    </ComputeDotnetBaseImageAndTag>

    <ItemGroup>
      <_TargetRuntimeIdentifiers Remove ="$(_TargetRuntimeIdentifiers)" />
    </ItemGroup>
  </Target>

  <!-- This Target is called early on in the chain for both single-RID and multi-RID containers - but for single-RID it's important
       that we ensure all of the data necessary to create a single-RID container is computed after we exit this target. -->
  <Target Name="ComputeContainerConfig" DependsOnTargets="ComputeContainerBaseImage;_ContainerEstablishRIDNess;_ComputeContainerExecutionArgs">
    <PropertyGroup Label="VS defaults">
      <!-- RegistryUrl is used by existing VS targets for Docker builds - this lets us fill that void -->
      <ContainerRegistry Condition="'$(RegistryUrl)' != ''">$(RegistryUrl)</ContainerRegistry>
      <!-- PublishImageTag is used by existing VS targets for Docker builds - this lets us fill that void -->
      <ContainerImageTag Condition="'$(PublishImageTag)' != ''">$(PublishImageTag)</ContainerImageTag>
      <!-- This line is a compatibility shim for VS support - the VS container targets define a container tag using this property and format. This lets us be a drop-in replacement for them. -->
      <ContainerImageTag Condition="'$(AutoGenerateImageTag)' == 'true'">$([System.DateTime]::UtcNow.ToString('yyyyMMddhhmmss'))</ContainerImageTag>
    </PropertyGroup>

    <!-- Compatibility: previous versions used ImageName, but the proper term is Repository. Keep using that if explicitly set. -->
    <Warning Condition="'$(ContainerImageName)' != ''" Code="CONTAINER003" Text="The property 'ContainerImageName' was set but is obsolete - please use 'ContainerRepository' instead." />

    <!-- Container Defaults -->
    <PropertyGroup>
      <!-- An empty ContainerRegistry implies pushing to the local registry, putting this here for documentation purposes -->
      <!-- <ContainerRegistry></ContainerRegistry> -->

      <!-- An empty LocalRegistry implies detecting the local registry. LocalRegistry can be set explicity to Docker/Podman. -->
      <!-- <LocalRegistry></LocalRegistry> -->

      <!-- Compatibility: previous versions used ImageName, but the proper term is Repository. Keep using that if explicitly set. -->
      <ContainerRepository Condition="'$(ContainerImageName)' != ''">$(ContainerImageName)</ContainerRepository>
      <!-- Note: spaces will be replaced with '-' in ContainerRepository and ContainerImageTag -->
      <ContainerRepository Condition="'$(ContainerRepository)' == ''">$(AssemblyName)</ContainerRepository>

      <!-- Only default a tag name if no tag names at all are provided -->
      <ContainerImageTag Condition="'$(ContainerImageTag)' == '' and '$(ContainerImageTags)' == ''">latest</ContainerImageTag>
      <ContainerImageTag Condition="'$(AutoGenerateImageTag)' == 'true' and '$(ContainerImageTags)' == ''">$([System.DateTime]::UtcNow.ToString('yyyyMMddhhmmss'))</ContainerImageTag>
    </PropertyGroup>

    <ParseContainerProperties FullyQualifiedBaseImageName="$(ContainerBaseImage)"
                              ContainerRegistry="$(ContainerRegistry)"
                              ContainerRepository="$(ContainerRepository)"
                              ContainerImageTag="$(ContainerImageTag)"
                              ContainerImageTags="$(ContainerImageTags)"
                              ContainerEnvironmentVariables="@(ContainerEnvironmentVariable)">

      <Output TaskParameter="ParsedContainerRegistry" PropertyName="ContainerBaseRegistry" />
      <Output TaskParameter="ParsedContainerImage" PropertyName="ContainerBaseName" />
      <Output TaskParameter="ParsedContainerTag" PropertyName="ContainerBaseTag" />
      <Output TaskParameter="ParsedContainerDigest" PropertyName="ContainerBaseDigest" />
      <Output TaskParameter="NewContainerRegistry" PropertyName="ContainerRegistry" />
      <Output TaskParameter="NewContainerRepository" PropertyName="ContainerRepository" />
      <Output TaskParameter="NewContainerTags" ItemName="ContainerImageTags" />
      <Output TaskParameter="NewContainerEnvironmentVariables" ItemName="ContainerEnvironmentVariables" />
    </ParseContainerProperties>

    <PropertyGroup>
      <ContainerGenerateLabels Condition="'$(ContainerGenerateLabels)' == ''">true</ContainerGenerateLabels>
      <!-- NOTE: this label screws up incrementality - may want to disable it by default -->
      <ContainerGenerateLabelsImageCreated Condition="'$(ContainerGenerateLabelsImageCreated)' != 'true'">false</ContainerGenerateLabelsImageCreated>
      <ContainerGenerateLabelsImageDescription Condition="'$(ContainerGenerateLabelsImageDescription)' == ''">true</ContainerGenerateLabelsImageDescription>
      <ContainerGenerateLabelsImageAuthors Condition="'$(ContainerGenerateLabelsImageAuthors)' == ''">true</ContainerGenerateLabelsImageAuthors>
      <ContainerGenerateLabelsImageUrl Condition="'$(ContainerGenerateLabelsImageUrl)' == ''">true</ContainerGenerateLabelsImageUrl>
      <ContainerGenerateLabelsImageDocumentation Condition="'$(ContainerGenerateLabelsImageDocumentation)' == ''">true</ContainerGenerateLabelsImageDocumentation>
      <ContainerGenerateLabelsImageSource Condition="'$(ContainerGenerateLabelsImageSource)' == ''">true</ContainerGenerateLabelsImageSource>
      <ContainerGenerateLabelsImageVersion Condition="'$(ContainerGenerateLabelsImageVersion)' == ''">true</ContainerGenerateLabelsImageVersion>
      <ContainerGenerateLabelsImageRevision Condition="'$(ContainerGenerateLabelsImageRevision)' == ''">true</ContainerGenerateLabelsImageRevision>
      <ContainerGenerateLabelsImageVendor Condition="'$(ContainerGenerateLabelsImageVendor)' == ''">true</ContainerGenerateLabelsImageVendor>
      <ContainerGenerateLabelsImageLicenses Condition="'$(ContainerGenerateLabelsImageLicenses)' == ''">true</ContainerGenerateLabelsImageLicenses>
      <ContainerGenerateLabelsImageTitle Condition="'$(ContainerGenerateLabelsImageTitle)' == ''">true</ContainerGenerateLabelsImageTitle>
      <ContainerGenerateLabelsImageBaseDigest Condition="'$(ContainerGenerateLabelsImageBaseDigest)' == ''">true</ContainerGenerateLabelsImageBaseDigest>
      <ContainerGenerateLabelsImageBaseName Condition="'$(ContainerGenerateLabelsImageBaseName)' == ''">true</ContainerGenerateLabelsImageBaseName>
      <ContainerGenerateLabelsDotnetToolset Condition="'$(ContainerGenerateLabelsDotnetToolset)' == ''">true</ContainerGenerateLabelsDotnetToolset>
    </PropertyGroup>

    <PropertyGroup Label="Defaults for Container Labels">
      <ContainerDescription Condition="'$(ContainerDescription)' == '' and '$(Description)' != ''">$(Description)</ContainerDescription>
      <ContainerAuthors Condition="'$(ContainerAuthors)' == '' and '$(Authors)' != ''">$(Authors)</ContainerAuthors>
      <ContainerInformationUrl Condition="'$(ContainerInformationUrl)' == '' and '$(PackageProjectUrl)' != ''">$(PackageProjectUrl)</ContainerInformationUrl>
      <ContainerDocumentationUrl Condition="'$(ContainerDocumentationUrl)' == '' and '$(PackageProjectUrl)' != ''">$(PackageProjectUrl)</ContainerDocumentationUrl>
      <ContainerVersion Condition="'$(ContainerVersion)' == '' and '$(PackageVersion)' != ''">$(PackageVersion)</ContainerVersion>
      <ContainerLicenseExpression Condition="'$(ContainerLicenseExpression)' == '' and '$(PackageLicenseExpression)' != ''">$(PackageLicenseExpression)</ContainerLicenseExpression>
      <ContainerTitle Condition="'$(ContainerTitle)' == '' and '$(Title)' != ''">$(Title)</ContainerTitle>
    </PropertyGroup>

    <!-- Labels generated from descriptions from the spec at https://github.com/opencontainers/image-spec/blob/main/annotations.md#pre-defined-annotation-keys -->
    <ItemGroup Label="Conventional Label assignment" Condition="'$(ContainerGenerateLabels)' == 'true'">
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageCreated)' == 'true'" Include="org.opencontainers.image.created;org.opencontainers.artifact.created" Value="$([System.DateTime]::UtcNow.ToString('o'))" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageDescription)' == 'true' and '$(ContainerDescription)' != ''" Include="org.opencontainers.artifact.description;org.opencontainers.image.description" Value="$(ContainerDescription)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageAuthors)' == 'true' and '$(ContainerAuthors)' != ''" Include="org.opencontainers.image.authors" Value="$(ContainerAuthors)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageUrl)' == 'true' and '$(ContainerInformationUrl)' != ''" Include="org.opencontainers.image.url" Value="$(ContainerInformationUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageDocumentation)' == 'true' and '$(ContainerDocumentationUrl)' != ''" Include="org.opencontainers.image.documentation" Value="$(ContainerDocumentationUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageVersion)' == 'true' and '$(ContainerVersion)' != ''" Include="org.opencontainers.image.version" Value="$(ContainerVersion)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageVendor)' == 'true' and '$(ContainerVendor)' != ''" Include="org.opencontainers.image.vendor" Value="$(ContainerVendor)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageLicenses)' == 'true' and '$(ContainerLicenseExpression)' != ''" Include="org.opencontainers.image.licenses" Value="$(ContainerLicenseExpression)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageTitle)' == 'true' and '$(ContainerTitle)' != ''" Include="org.opencontainers.image.title" Value="$(ContainerTitle)" />
      <!-- Need to compute digests, not just names, before we can light this up. This suggests we need a task where all of the 'read' steps are done. -->
      <!-- <ContainerLabel Condition="'$(ContainerGenerateLabelsImageBaseDigest)' == 'true' and '$(ContainerBaseImageDigest)' != ''" Include="org.opencontainers.image.base.digest" Value="$(ContainerBaseImageDigest)" /> -->
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageBaseName)' == 'true' and '$(ContainerBaseImage)' != ''" Include="org.opencontainers.image.base.name" Value="$(ContainerBaseImage)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsDotnetToolset)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" Include="net.dot.runtime.majorminor" Value="$(_TargetFrameworkVersionWithoutV)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsDotnetToolset)' == 'true'" Include="net.dot.sdk.version" Value="$(NETCoreSdkVersion)" />
    </ItemGroup>

    <!-- These sourcelink-derived properties are only allowed to flow to generated artifacts if `PublishRepositoryUrl` is set as a user signal for opt-in.
             In addition, the 'nice' property names are currently set by NuGet Pack targets and so we have to use the private/generic names here. -->
    <PropertyGroup Label="Source control label assignment" Condition="'$(ContainerGenerateLabels)' == 'true' and '$(PublishRepositoryUrl)' == 'true'">
      <!-- Sourcelink gives us the .git suffix, but scanning tools aren't looking for that so we trim it off here. -->
      <_TrimmedRepositoryUrl Condition="'$(RepositoryType)' == 'git' and '$(PrivateRepositoryUrl)' != '' and $(PrivateRepositoryUrl.EndsWith('.git'))">$(PrivateRepositoryUrl.Substring(0, $(PrivateRepositoryUrl.LastIndexOf('.git'))))</_TrimmedRepositoryUrl>
      <_TrimmedRepositoryUrl Condition="'$(_TrimmedRepositoryUrl)' == '' and '$(PrivateRepositoryUrl)' != ''">$(PrivateRepositoryUrl)</_TrimmedRepositoryUrl>
    </PropertyGroup>
    <ItemGroup Label="Source control label assignment" Condition="'$(ContainerGenerateLabels)' == 'true' and '$(PublishRepositoryUrl)' == 'true'">
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageSource)' == 'true' and '$(_TrimmedRepositoryUrl)' != ''" Include="org.opencontainers.image.source" Value="$(_TrimmedRepositoryUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageRevision)' == 'true' and '$(SourceRevisionId)' != ''" Include="org.opencontainers.image.revision" Value="$(SourceRevisionId)" />
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <PublishContainerDependsOn>
      _ContainerVerifySDKVersion;
      ComputeContainerConfig;
      _CheckContainersPackage;
      _EnsureManifestsAvailable;
    </PublishContainerDependsOn>
  </PropertyGroup>

  <!-- These args are relevant to container execution and are per-RID by nature. Therefore they're a direct dependency of the _CreateSingleContainer
       target and not computed at the outer, multi-RID build layer. -->
  <Target Name="_ComputeContainerExecutionArgs" DependsOnTargets="_ContainerEstablishRIDNess" Condition="'$(_IsSingleRIDBuild)' == 'true'">
    <PropertyGroup>
      <!-- The Container RID should default to the RID used for the entire build (to ensure things run on the platform they are built for), but the user knows best and so should be able to set it explicitly.
           For builds that have a RID, we default to that RID. Otherwise, we default to the Linux RID matching the architecture of the currently-executing SDK. -->
      <_ContainerIsTargetingWindows>false</_ContainerIsTargetingWindows>
      <_ContainerIsTargetingWindows Condition="$(ContainerRuntimeIdentifier.StartsWith('win'))">true</_ContainerIsTargetingWindows>

      <!-- Set the WorkingDirectory depending on the RID -->
      <ContainerWorkingDirectory Condition="'$(ContainerWorkingDirectory)' == '' and !$(_ContainerIsTargetingWindows)">/app/</ContainerWorkingDirectory>
      <ContainerWorkingDirectory Condition="'$(ContainerWorkingDirectory)' == '' and $(_ContainerIsTargetingWindows)">C:\app\</ContainerWorkingDirectory>

      <_ContainerIsUsingMicrosoftDefaultImages Condition="'$(_InitialContainerBaseImage)' == ''">true</_ContainerIsUsingMicrosoftDefaultImages>
      <_ContainerIsUsingMicrosoftDefaultImages Condition="'$(_InitialContainerBaseImage)' != ''">false</_ContainerIsUsingMicrosoftDefaultImages>
    </PropertyGroup>

      <!-- We only set a default user when the base image is Microsoft-authored, and we're targeting a version of those images that supports a nonroot user -->
    <PropertyGroup Label="ContainerUser Assignment" Condition="$(_ContainerIsUsingMicrosoftDefaultImages) and $(_ContainerIsTargetingNet8TFM) and '$(ContainerUser)' == ''">
      <ContainerUser Condition="$(_ContainerIsTargetingWindows)">ContainerUser</ContainerUser>
    </PropertyGroup>

    <ItemGroup Label="AppCommand Assignment" Condition="'$(ContainerAppCommandInstruction)' != 'None'">
      <!-- For self-contained, invoke the native executable as a single arg -->
      <ContainerAppCommand Condition="@(ContainerAppCommand->Count()) == 0 and $(_ContainerIsSelfContained)" Include="$(ContainerWorkingDirectory)$(AssemblyName)$(_NativeExecutableExtension)" />
      <!-- For non self-contained, invoke `dotnet` `app.dll` as separate args -->
      <ContainerAppCommand Condition="@(ContainerAppCommand->Count()) == 0 and !$(_ContainerIsSelfContained)" Include="dotnet;$(ContainerWorkingDirectory)$(TargetFileName)" />
    </ItemGroup>
  </Target>

  <Target Name="_CheckContainersPackage" AfterTargets="Build">
    <PropertyGroup>
      <!-- facts to base on comparisons on -->
      <_ContainersPackageIdentity>Microsoft.NET.Build.Containers</_ContainersPackageIdentity>
      <_WebDefaultSdkVersion>7.0.300</_WebDefaultSdkVersion>
      <_WorkerDefaultSdkVersion>8.0.100</_WorkerDefaultSdkVersion>
      <_ConsoleDefaultSdkVersion>8.0.200</_ConsoleDefaultSdkVersion>

      <!-- capability detection for the executing SDK -->
      <_SdkCanPublishWeb>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_WebDefaultSdkVersion)'))</_SdkCanPublishWeb>
      <_SdkCanPublishWorker>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_WorkerDefaultSdkVersion)'))</_SdkCanPublishWorker>
      <_SdkCanPublishConsole>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_ConsoleDefaultSdkVersion)'))</_SdkCanPublishConsole>

      <!-- capability detection for the executing project -->
      <_ContainerPackageIsPresent>false</_ContainerPackageIsPresent>
      <_ContainerPackageIsPresent Condition="@(PackageReference->AnyHaveMetadataValue('Identity', '$(_ContainersPackageIdentity)'))">true</_ContainerPackageIsPresent>
      <_IsWebProject>false</_IsWebProject>
      <_IsWebProject Condition="@(ProjectCapability->AnyHaveMetadataValue('Identity', 'DotNetCoreWeb'))">true</_IsWebProject>
      <_IsWorkerProject>false</_IsWorkerProject>
      <_IsWorkerProject Condition="@(ProjectCapability->AnyHaveMetadataValue('Identity', 'DotNetCoreWorker'))">true</_IsWorkerProject>
    </PropertyGroup>

    <Warning
      Condition="$(_ContainerPackageIsPresent)
        and (
          ($(_SdkCanPublishWeb) and $(_IsWebProject)) or
          ($(_SdkCanPublishWorker) and $(_IsWorkerProject)) or
          ($(_SdkCanPublishConsole) and '$(EnableSdkContainerSupport)' == 'true')
        )"
      Code="CONTAINER005"
      Text="The $(_ContainersPackageIdentity) NuGet package is explicitly referenced but the current SDK can natively publish the project as a container. Consider removing the package reference to $(_ContainersPackageIdentity) because it is no longer needed." />
  </Target>

  <!-- Uses the outputs of ComputeContainerConfig to create incrementality structures for _EnsureManifestsAreAvailable -->
  <Target Name="_ComputeManifestInputsAndOutputs" DependsOnTargets="ComputeContainerConfig">
    <PropertyGroup>
      <_ContainerBaseImageManifestDataCacheFile>$(IntermediateOutputPath)$(MSBuildProjectName).ContainerManifestData</_ContainerBaseImageManifestDataCacheFile>
    </PropertyGroup>
    <WriteLinesToFile File="$(_ContainerBaseImageManifestDataCacheFile)" Overwrite="true"
      WriteOnlyWhenDifferent="true"
      Lines="$(ContainerBaseRegistry);$(ContainerBaseName);$(ContainerBaseTag);$(ContainerBaseDigest)" />
    <ItemGroup>
      <FileWrites Include="_ContainerBaseImageManifestDataCacheFile" />
    </ItemGroup>
  </Target>

  <!-- Downloads the manifest jsons to the content store if necessary. If the manifest is a multi-arch manifest then the child manifests are downloaded as well. -->
  <Target Name="_EnsureManifestsAvailable" DependsOnTargets="_ComputeManifestInputsAndOutputs;ComputeContainerConfig" >
    <DownloadContainerManifest
      Registry="$(ContainerBaseRegistry)"
      Repository="$(ContainerBaseName)"
      Tag="$(ContainerBaseTag)"
      Digest="$(ContainerBaseDigest)"
      ContentStore="$(ContainerContentStoreRoot)">
      <Output TaskParameter="Manifests" ItemName="_ContainerSingleArchImageManifest" />
      <Output TaskParameter="Configs" ItemName="_ContainerSingleArchImageManifestConfig" />
      <Output TaskParameter="Layers" ItemName="_ContainerSingleArchImageManifestLayer" />
    </DownloadContainerManifest>

    <ItemGroup>
      <FileWrites Include="@(_ContainerSingleArchImageManifest);@(_ContainerSingleArchImageManifestConfig);"/>
    </ItemGroup>
  </Target>

  <Target Name="_ComputeRidSpecificArtifactsForImage" DependsOnTargets="_EnsureManifestsAvailable">
    <!-- Given all the manifest artifacts above, drill down to the ones relevant for this RID -->
    <!-- Precondition: Called When RuntimeIdentifier != '' -->
    <SelectRuntimeIdentifierSpecificItems Items="@(_ContainerSingleArchImageManifest)"
                                          TargetRuntimeIdentifier="$(ContainerRuntimeIdentifier)"
                                          RuntimeIdentifierGraphPath="$(RuntimeIdentifierGraphPath)">
      <Output TaskParameter="SelectedItems" ItemName="_BaseContainerThisArchManifest" />
    </SelectRuntimeIdentifierSpecificItems>
    <SelectRuntimeIdentifierSpecificItems Items="@(_ContainerSingleArchImageManifestConfig)"
                                          TargetRuntimeIdentifier="$(ContainerRuntimeIdentifier)"
                                          RuntimeIdentifierGraphPath="$(RuntimeIdentifierGraphPath)">
      <Output TaskParameter="SelectedItems" ItemName="_BaseContainerThisArchConfig" />
    </SelectRuntimeIdentifierSpecificItems>
    <SelectRuntimeIdentifierSpecificItems Items="@(_ContainerSingleArchImageManifestLayer)"
                                          TargetRuntimeIdentifier="$(ContainerRuntimeIdentifier)"
                                          RuntimeIdentifierGraphPath="$(RuntimeIdentifierGraphPath)">
      <Output TaskParameter="SelectedItems" ItemName="_BaseContainerThisArchLayer" />
    </SelectRuntimeIdentifierSpecificItems>
  </Target>

  <Target Name="_DownloadLayers" DependsOnTargets="_ComputeRidSpecificArtifactsForImage" Inputs="@(_BaseContainerThisArchManifest)" Outputs="@(_BaseContainerThisArchLayer)">
    <DownloadLayers Registry="$(ContainerBaseRegistry)"
                    Repository="$(ContainerBaseName)"
                    ContentStore="$(ContainerContentStoreRoot)"
                    Layers="@(_BaseContainerThisArchLayer)" />
  </Target>

  <Target Name="_GenerateContainerConfigTrackingFile">
    <PropertyGroup>
      <_ContainerGeneratedConfigTrackingFile>$(IntermediateOutputPath)$(MSBuildProjectName).GeneratedContainerConfig</_ContainerGeneratedConfigTrackingFile>
    </PropertyGroup>
    <WriteLinesToFile
      File="$(_ContainerGeneratedConfigTrackingFile)" Overwrite="true"
      WriteOnlyWhenDifferent="true"
      Lines="
        $(ContainerRepository);
        @(ContainerImageTags);
        $(ContainerWorkingDirectory);
        @(ContainerEntrypoint);
        @(ContainerEntrypointArgs);
        @(ContainerAppCommand);
        @(ContainerAppCommandArgs);
        @(ContainerAppCommandInstruction);
        @(ContainerDefaultArgs);
        @(ContainerLabel->'%(Identity)=%(Value)');;
        @(ContainerPort->'%(Identity):%(Type)');
        @(ContainerEnvironmentVariables->'%(Identity)=%(Value)');" />
    <ItemGroup>
      <FileWrites Include="@(_ContainerGeneratedConfigTrackingFile)" />
    </ItemGroup>
  </Target>

  <Target Name="_CreateGeneratedContainerProperties">
    <PropertyGroup>
      <_ContainerGeneratedManifestPath>$(IntermediateOutputPath)container.manifest.json</_ContainerGeneratedManifestPath>
      <_ContainerGeneratedConfigurationPath>$(IntermediateOutputPath)container.config.json</_ContainerGeneratedConfigurationPath>
      <_ContainerGeneratedLayerPath>$(IntermediateOutputPath)container.layer.tar.gz</_ContainerGeneratedLayerPath>
    </PropertyGroup>
  </Target>

  <Target Name="_GetItemsFromPublishDirForSingleContainerPublish">
    <ItemGroup>
      <!-- Have to do this in two phases because FullPath metadata isn't available on the Include, and we can't Update inside a Target -->
      <_ContainerPublishItemBase Include="$(PublishDir)/**/*.*" />
      <!-- TODO: this doesn't help us split out _kinds_ of publish content into layers. That's still a fundamental problem. -->
      <_ContainerPublishItem Include="@(_ContainerPublishItemBase)">
        <RelativePath>$([MSBuild]::MakeRelative($(PublishDir), %(_ContainerPublishItemBase.FullPath)))</RelativePath>
      </_ContainerPublishItem>
    </ItemGroup>
  </Target>

  <Target Name="_CreateApplicationLayer"
    DependsOnTargets="_GetItemsFromPublishDirForSingleContainerPublish"
    Inputs="@(_ContainerPublishItem);$(_GenerateContainerConfigTrackingFile);@(_BaseContainerThisArchManifest)"
    Outputs="$(_ContainerGeneratedLayerPath)"
    Returns="@(_ContainerGeneratedApplicationLayer)">
    <PropertyGroup Condition="'$(DOTNET_HOST_PATH)' == ''">
      <DotNetHostDirectory>$(NetCoreRoot)</DotNetHostDirectory>
      <DotNetHostFileName>dotnet</DotNetHostFileName>
      <DotNetHostFileName Condition="'$(OS)' == 'Windows_NT'">dotnet.exe</DotNetHostFileName>
    </PropertyGroup>

    <PropertyGroup>
      <_ParentImageFormat Condition="'$(ContainerImageFormat)' != ''">$(ContainerImageFormat)</_ParentImageFormat>
      <_ParentImageFormat>%(_BaseContainerThisArchManifest.MediaType)</_ParentImageFormat>
    </PropertyGroup>

    <CreateAppLayer
      CreateLayerTarballDirectory="$(CreateLayerTarballFolder)"
      ToolPath="$(DotNetHostDirectory)"
      ToolExe="$(DotNetHostFileName)"
      PublishFiles="@(_ContainerPublishItem)"
      ContainerRootDirectory="$(ContainerWorkingDirectory)"
      TargetRuntimeIdentifier="$(ContainerRuntimeIdentifier)"
      ParentImageFormat="$(_ParentImageFormat)"
      ContentStoreRoot="$(ContainerContentStoreRoot)"
      ContainerUser="$(ContainerUser)"
      GeneratedLayerPath="$(_ContainerGeneratedLayerPath)">
      <Output TaskParameter="GeneratedAppContainerLayer" ItemName="_ContainerGeneratedApplicationLayer" />
    </CreateAppLayer>

    <ItemGroup>
      <FileWrites Include="$(_ContainerGeneratedLayerPath)" />
    </ItemGroup>
  </Target>

  <!-- There is an implicit dependency here in that both of ComputeContainerConfig and _ComputeContainerExecutionArgs must have been run, but because we call this Target
       in a few different ways we can't express that dependency directly here. -->
  <!-- NOTE: the apphost screws with incrementality because it's marked with CopyToPublishDirectory=Always in _ComputeNETCoreBuildOutputFiles - we should find a better way to handle that. -->
  <Target Name="_CreateSingleContainer"
    DependsOnTargets="_DownloadLayers;_GenerateContainerConfigTrackingFile;_CreateGeneratedContainerProperties;_CreateApplicationLayer"
    Inputs="$(_ContainerGeneratedConfigTrackingFile);@(_BaseContainerThisArchLayer);@(_BaseContainerThisArchConfig);@(_BaseContainerThisArchManifest);@(_ContainerPublishItem);@(_ContainerGeneratedApplicationLayer)"
    Outputs="$(_ContainerGeneratedManifestPath);$(_ContainerGeneratedConfigurationPath)"
    Returns="@(GeneratedContainer);@(_ContainerGeneratedApplicationLayer);@(ContainerGeneratedConfig);@(ContainerGeneratedManifest)">

    <CreateNewImage BaseRegistry="$(ContainerBaseRegistry)"
                    BaseImageName="$(ContainerBaseName)"
                    BaseImageTag="$(ContainerBaseTag)"
                    BaseImageDigest="$(ContainerBaseDigest)"
                    BaseImageManifestPath="@(_BaseContainerThisArchManifest)"
                    BaseImageConfigurationPath="@(_BaseContainerThisArchConfig)"
                    GeneratedApplicationLayer="@(_ContainerGeneratedApplicationLayer)"
                    ImageFormat="$(ContainerImageFormat)"
                    LocalRegistry="$(LocalRegistry)"
                    OutputRegistry="$(ContainerRegistry)"
                    ArchiveOutputPath="$(ContainerArchiveOutputPath)"
                    Repository="$(ContainerRepository)"
                    ImageTags="@(ContainerImageTags)"
                    WorkingDirectory="$(ContainerWorkingDirectory)"
                    Entrypoint="@(ContainerEntrypoint)"
                    EntrypointArgs="@(ContainerEntrypointArgs)"
                    AppCommand="@(ContainerAppCommand)"
                    AppCommandArgs="@(ContainerAppCommandArgs)"
                    AppCommandInstruction="$(ContainerAppCommandInstruction)"
                    DefaultArgs="@(ContainerDefaultArgs)"
                    Labels="@(ContainerLabel)"
                    ExposedPorts="@(ContainerPort)"
                    ContainerEnvironmentVariables="@(ContainerEnvironmentVariables)"
                    ContainerUser="$(ContainerUser)"
                    GenerateLabels="$(ContainerGenerateLabels)"
                    GenerateDigestLabel="$(ContainerGenerateLabelsImageBaseDigest)"
                    ContentStoreRoot="$(ContainerContentStoreRoot)"
                    GeneratedManifestPath="$(_ContainerGeneratedManifestPath)"
                    GeneratedConfigurationPath="$(_ContainerGeneratedConfigurationPath)" >

      <Output TaskParameter="GeneratedArchiveOutputPath" PropertyName="GeneratedArchiveOutputPath" />
      <Output TaskParameter="GeneratedContainerNames" ItemName="GeneratedContainerName" />
      <Output TaskParameter="GeneratedDigestLabel" ItemName="ContainerLabel" />
      <Output TaskParameter="GeneratedAppContainerConfig" ItemName="_ContainerGeneratedConfig" />
      <Output TaskParameter="GeneratedAppContainerManifest" ItemName="_ContainerGeneratedManifest" />
    </CreateNewImage>

    <ItemGroup>
      <ContainerGeneratedConfig Include="@(_ContainerGeneratedConfig)">
        <RuntimeIdentifier>$(ContainerRuntimeIdentifier)</RuntimeIdentifier>
      </ContainerGeneratedConfig>
      <ContainerGeneratedManifest Include="@(_ContainerGeneratedManifest)">
        <RuntimeIdentifier>$(ContainerRuntimeIdentifier)</RuntimeIdentifier>
      </ContainerGeneratedManifest>

      <!-- Track the generated files for cleanup later -->
      <FileWrites Include="$(ContainerGeneratedManifest);$(ContainerGeneratedConfig);" />

      <GeneratedContainer Include="GeneratedContainer">
        <ManifestPath>$(_ContainerGeneratedManifestPath)</ManifestPath>
        <ConfigurationPath>$(_ContainerGeneratedConfigurationPath)</ConfigurationPath>
        <LayerPath>$(_ContainerGeneratedLayerPath)</LayerPath>
      </GeneratedContainer>
    </ItemGroup>
  </Target>

  <Target Name="_ContainerSinglePublishComputeTrackingFile">
    <PropertyGroup>
      <_ContainerSinglePublishTrackingFile>$(IntermediateOutputPath)container.SingleContainerPublish</_ContainerSinglePublishTrackingFile>
    </PropertyGroup>
  </Target>

  <Target Name="_PublishSingleContainer"
      DependsOnTargets="_CreateSingleContainer;_ContainerSinglePublishComputeTrackingFile"
      Inputs="@(_BaseContainerThisArchLayer);@(_ContainerGeneratedApplicationLayer);@(ContainerGeneratedManifest);@(ContainerGeneratedConfig)"
      Outputs="$(_ContainerSinglePublishTrackingFile)"
      >
        <PushContainerToRemoteRegistry Condition="'$(ContainerRegistry)' != ''"
          Registry="$(ContainerRegistry)"
          Repository="$(ContainerRepository)"
          Tags="@(ContainerImageTags)"
          Manifest="@(ContainerGeneratedManifest)"
          Configuration="@(ContainerGeneratedConfig)"
          Layers="@(_BaseContainerThisArchLayer);@(_ContainerGeneratedApplicationLayer)" />

        <MakeContainerTarball Condition="'$(ContainerArchiveOutputPath)' != ''"
          ArchivePath="$(ContainerArchiveOutputPath)"
          Repository="$(ContainerRepository)"
          Tags="@(ContainerImageTags)"
          Manifest="@(ContainerGeneratedManifest)"
          Configuration="@(ContainerGeneratedConfig)"
          Layers="@(_BaseContainerThisArchLayer);@(_ContainerGeneratedApplicationLayer)">
          <Output TaskParameter="GeneratedArchiveFilePath" PropertyName="_GeneratedArchiveOutputPath" />
        </MakeContainerTarball>

        <PushContainerToLocal Condition="'$(LocalRegistry)' != '' or ('$(ContainerArchiveOutputPath)' == '' and '$(ContainerRegistry)' == '')"
          LocalRegistry="$(LocalRegistry)"
          Repository="$(ContainerRepository)"
          Tags="@(ContainerImageTags)"
          Manifest="@(ContainerGeneratedManifest)"
          Configuration="@(ContainerGeneratedConfig)"
          Layers="@(_BaseContainerThisArchLayer);@(_ContainerGeneratedApplicationLayer)" />

      <!-- These are the public-facing values that should trigger a different container publish -->
      <WriteLinesToFile
        File="$(_ContainerSinglePublishTrackingFile)"
        Overwrite="true"
        WriteOnlyWhenDifferent="true"
        Lines="
          $(ContainerRegistry);
          $(ContainerRepository);
          $(LocalRegistry);
          $(ContainerArchiveOutputPath);
          @(ContainerImageTags->'%(Identity)');" />

    <ItemGroup>
      <FileWrites Include="@(_ContainerSinglePublishTrackingFile);$(_GeneratedArchiveOutputPath)" />
    </ItemGroup>

  </Target>

  <Target Name="_ComputeMultiRidPublishDefaults">
    <PropertyGroup>
      <!--We want to skip publishing individual images in case of multi-arch tarball publishing or local daemon (only docker) publishing because all images are published in one tarball.-->
      <!--We don't want to skip publishing individual images in case of remote registry because the individual images should be available in the registry before image index is pushed.-->
      <!--We don't want to skip publishing individual images in case of local daemon podman because podman loads multi-arch tarball differently - only individual image for the current platform.-->
      <_SkipContainerPublishing>false</_SkipContainerPublishing>
      <_SkipContainerPublishing Condition="$(ContainerArchiveOutputPath) != '' or ( $(ContainerRegistry) == '' and ( $(LocalRegistry) == '' or $(LocalRegistry) == 'Docker' ) )">true</_SkipContainerPublishing>

      <!--We want to skip CreateImageIndex task in case of local daemon podman because it is not supported.-->
      <_SkipCreateImageIndex>false</_SkipCreateImageIndex>
      <_SkipCreateImageIndex Condition="$(ContainerArchiveOutputPath) == '' and $(ContainerRegistry) == '' and $(LocalRegistry) == 'Podman'">true</_SkipCreateImageIndex>

      <!-- Figure out what format the inner images should be coerced to -->
      <!-- If a user had an opinion, use that -->
      <_SingleImageContainerFormat Condition="'$(ContainerImageFormat)' != ''">$(ContainerImageFormat)</_SingleImageContainerFormat>
      <!-- If we are publishing to local tarball or to local Docker, force OCI to prevent mismatches between inner images and the outer manifest -->
      <_SingleImageContainerFormat Condition="$(_SkipContainerPublishing) == 'true' ">OCI</_SingleImageContainerFormat>
    </PropertyGroup>
  </Target>

  <Target Name="_BuildMultiRidImages" DependsOnTargets="_ComputeMultiRidPublishDefaults" Returns="@(GeneratedContainer)">
    <ItemGroup>
      <_rids Include="$(ContainerRuntimeIdentifiers)" Condition="'$(ContainerRuntimeIdentifiers)' != ''" />
      <_rids Include="$(RuntimeIdentifiers)" Condition="'$(ContainerRuntimeIdentifiers)' == '' and '$(RuntimeIdentifiers)' != ''" />
      <_InnerBuild
        Include="$(MSBuildProjectFullPath)"
        AdditionalProperties="
          ContainerRuntimeIdentifier=%(_rids.Identity);
          RuntimeIdentifier=%(_rids.Identity);
          ContainerBaseRegistry=$(ContainerBaseRegistry);
          ContainerBaseName=$(ContainerBaseName);
          ContainerBaseTag=$(ContainerBaseTag);
          ContainerBaseDigest=$(ContainerBaseDigest);
          ContainerRegistry=$(ContainerRegistry);
          _ContainerImageTags=@(ContainerImageTags, ';');
          ContainerRepository=$(ContainerRepository);
          _ContainerLabel=@(ContainerLabel->'%(Identity):%(Value)');
          _ContainerPort=@(ContainerPort->'%(Identity):%(Type)');
          _ContainerEnvironmentVariables=@(ContainerEnvironmentVariable->'%(Identity):%(Value)');
          ContainerGenerateLabels=$(ContainerGenerateLabels);
          ContainerGenerateLabelsImageBaseDigest=$(ContainerGenerateLabelsImageBaseDigest);
          ContainerImageFormat=$(_SingleImageContainerFormat);
          _IsMultiRIDBuild=false;
          _IsSingleRIDBuild=true;
          _InitialContainerBaseImage=$(_InitialContainerBaseImage)
        "/>
      <_rids Remove ="$(_rids)" />
    </ItemGroup>

    <PropertyGroup>
      <_InnerContainerBuildTargets>Publish;_ParseItemsForPublishingSingleContainer;_ComputeContainerExecutionArgs;</_InnerContainerBuildTargets>
      <_InnerContainerBuildTargets Condition="'$(_SkipContainerPublishing)' == 'true'">$(_InnerContainerBuildTargets);_PublishSingleContainer</_InnerContainerBuildTargets>
      <_InnerContainerBuildTargets Condition="'$(_SkipContainerPublishing)' != 'true'">$(_InnerContainerBuildTargets);_CreateSingleContainer</_InnerContainerBuildTargets>
    </PropertyGroup>

    <!-- NOTE: not calling the publish here - it'll be orchestrated at the next step so we can push a bunch of stuff in parallel. -->
    <MSBuild
        Projects="@(_InnerBuild)"
        Targets="$(_InnerContainerBuildTargets)"
        BuildInParallel="$([MSBuild]::ValueOrDefault('$(ContainerPublishInParallel)', 'true'))">
        <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </MSBuild>
  </Target>

  <Target Name="_ComputeMultiArchManifestInputsAndOutputs">
    <ItemGroup>
      <_MultiArchManifestInputs Include="@(GeneratedContainer->'%(ManifestPath)');@(GeneratedContainer->'%(ConfigurationPath)')" />
    </ItemGroup>
    <PropertyGroup>
      <_MultiArchManifestFilePath>$(IntermediateOutputPath)multiarchcontainer.manifest</_MultiArchManifestFilePath>
    </PropertyGroup>
  </Target>

  <Target Name="_CreateImageIndex"
          DependsOnTargets="_BuildMultiRidImages;_ComputeMultiArchManifestInputsAndOutputs"
          Inputs="@(_MultiArchManifestInputs)"
          Outputs="$(_MultiArchManifestFilePath)"
          Returns="@(GeneratedContainer)" >
    <CreateImageIndex Condition="'$(_SkipCreateImageIndex)' == 'false' "
                      GeneratedContainers="@(GeneratedContainer)"
                      LocalRegistry="$(LocalRegistry)"
                      OutputRegistry="$(ContainerRegistry)"
                      ArchiveOutputPath="$(ContainerArchiveOutputPath)"
                      Repository="$(ContainerRepository)"
                      ImageTags="@(ContainerImageTags)"
                      BaseRegistry="$(ContainerBaseRegistry)"
                      BaseImageName="$(ContainerBaseName)"
                      BaseImageTag="$(ContainerBaseTag)"
                      BaseImageDigest="$(ContainerBaseDigest)"
                      GeneratedManifestPath="$(_MultiArchManifestFilePath)">
      <Output TaskParameter="GeneratedImageIndex" PropertyName="GeneratedImageIndex" />
      <Output TaskParameter="GeneratedArchiveOutputPath" PropertyName="GeneratedArchiveOutputPath" />
    </CreateImageIndex>
    <ItemGroup>
      <FileWrites Include="$(_MultiArchManifestFilePath)" />
    </ItemGroup>
  </Target>

  <Target Name="_ParseItemsForPublishingSingleContainer">
    <ItemGroup>
      <OriginalImageTags Include="$(_ContainerImageTags)"/>
      <ContainerImageTags Include="@(OriginalImageTags->'%(Identity)-$(ContainerRuntimeIdentifier)')" />

      <_ParsedContainerLabel
        Condition="'$(_ContainerLabel)' != ':'"
        Include="$(_ContainerLabel)"/>
      <ContainerLabel
        Condition="@(_ParsedContainerLabel->Count()) > 0 "
        Include="$([System.String]::Copy('%(_ParsedContainerLabel.Identity)').Split(':')[0])"
        Value="$([System.String]::Copy('%(_ParsedContainerLabel.Identity)').Split(':')[1])" />

      <_ParsedContainerPort
        Condition="'$(_ContainerPort)' != ':'"
        Include="$(_ContainerPort)"/>
      <ContainerPort
        Condition="@(_ParsedContainerPort->Count()) > 0 "
        Include="$([System.String]::Copy('%(_ParsedContainerPort.Identity)').Split(':')[0])"
        Type="$([System.String]::Copy('%(_ParsedContainerPort.Identity)').Split(':')[1])" />

      <_ParsedContainerEnvironmentVariables
        Condition="'$(_ContainerEnvironmentVariables)' != ':'"
        Include="$(_ContainerEnvironmentVariables)"/>
      <ContainerEnvironmentVariables
        Condition="@(_ParsedContainerEnvironmentVariables->Count()) > 0 "
        Include="$([System.String]::Copy('%(_ParsedContainerEnvironmentVariables.Identity)').Split(':')[0])"
        Value="$([System.String]::Copy('%(_ParsedContainerEnvironmentVariables.Identity)').Split(':')[1])" />
    </ItemGroup>
  </Target>

  <Target Name="_ContainerEstablishRIDNess">
    <PropertyGroup>
      <_IsMultiTFMBuild Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">true</_IsMultiTFMBuild>
      <!-- we are multi-RID if:
          * we have CRIDs and no CRID
          * we have RIDs and no (CRIDs or CRID or RID)
      -->
      <_HasCRIDsAndNoCRID Condition="'$(ContainerRuntimeIdentifiers)' != '' and '$(ContainerRuntimeIdentifier)' == ''">true</_HasCRIDsAndNoCRID>
      <_HasRIDs Condition="'$(RuntimeIdentifiers)' != ''">true</_HasRIDs>
      <_NoCRIDsOrCRIDorRID Condition="'$(ContainerRuntimeIdentifiers)' == '' and '$(ContainerRuntimeIdentifier)' == '' and '$(RuntimeIdentifier)' == ''">true</_NoCRIDsOrCRIDorRID>
      <!-- these two are load-bearing for other comparisons - see _ComputeContainerExecutionArgs -->
      <_IsMultiRIDBuild Condition="'$(BuildingInsideVisualStudio)' != 'true' and ('$(_HasCRIDsAndNoCRID)' == true or ('$(_HasRIDs)' == 'true' and '$(_NoCRIDsOrCRIDorRID)' == 'true'))">true</_IsMultiRIDBuild>
      <_IsSingleRIDBuild Condition="'$(_IsMultiRIDBuild)' == ''">true</_IsSingleRIDBuild>
    </PropertyGroup>
  </Target>

  <Target Name="PublishContainer"
  DependsOnTargets="$(PublishContainerDependsOn)"
  Condition="'$(IsPublishable)' == 'true' AND '$(EnableSdkContainerSupport)' == 'true'"
  Returns="@(GeneratedContainer)"
  >
    <!-- Call _CreateImageIndex if we are in a multi-rid build, and call _CreateSingleContainer if we are in a single-RID build -->
    <CallTarget Condition="'$(_IsMultiRIDBuild)' == 'true' " Targets="_CreateImageIndex">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </CallTarget>
    <CallTarget Condition="'$(_IsSingleRIDBuild)' == 'true' " Targets="_PublishSingleContainer">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </CallTarget>

    <Error Condition="'$(_IsMultiTFMBuild)' == 'true'" Code="CONTAINERS0666" Text="Containers cannot be published for multiple TargetFrameworks at this time. Please specify a TargetFramework." />
  </Target>
</Project>
